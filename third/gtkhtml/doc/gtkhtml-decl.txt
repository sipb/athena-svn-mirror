<MACRO>
<NAME>GTK_HTML_EMBEDDED</NAME>
#define GTK_HTML_EMBEDDED(obj)         GTK_CHECK_CAST (obj, gtk_html_embedded_get_type (), GtkHTMLEmbedded)
</MACRO>
<MACRO>
<NAME>GTK_HTML_EMBEDDED_CLASS</NAME>
#define GTK_HTML_EMBEDDED_CLASS(klass) GTK_CHECK_CLASS_CAST (klass, gtk_html_embedded_get_type (), GtkHTMLEmbeddedClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_HTML_EMBEDDED</NAME>
#define GTK_IS_HTML_EMBEDDED(obj)      GTK_CHECK_TYPE (obj, gtk_html_embedded_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkHTMLEmbedded</NAME>
struct GtkHTMLEmbedded {
	GtkBin bin;

	/* class id of this object */
	char *classid;
	char *name;
        char *type;
        char *data;

	/* parameters to class */
	int width, height;
	GHashTable *params;

	GtkHTMLEmbeddedPrivate *priv;

	int descent;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_html_embedded_get_type</NAME>
<RETURNS>guint 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_embedded_new</NAME>
<RETURNS>GtkWidget 	*</RETURNS>
char *classid, char *name, char *type, char *data, int width, int height
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_embedded_set_parameter</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLEmbedded *ge, char *param, char *value
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_embedded_get_parameter</NAME>
<RETURNS>char  *</RETURNS>
GtkHTMLEmbedded *ge, char *param
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_embedded_set_descent</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLEmbedded *ge, int descent
</FUNCTION>
<ENUM>
<NAME>GtkHTMLCommandType</NAME>
typedef enum {
	GTK_HTML_COMMAND_UNDO,
	GTK_HTML_COMMAND_REDO,
	GTK_HTML_COMMAND_COPY,
	GTK_HTML_COMMAND_CUT,
	GTK_HTML_COMMAND_PASTE,

	GTK_HTML_COMMAND_CUT_LINE,

	GTK_HTML_COMMAND_INSERT_PARAGRAPH,
	GTK_HTML_COMMAND_INSERT_RULE,
	GTK_HTML_COMMAND_INSERT_RULE_PARAM,
	GTK_HTML_COMMAND_INSERT_IMAGE_PARAM,

	GTK_HTML_COMMAND_MAKE_LINK,
	GTK_HTML_COMMAND_REMOVE_LINK,

	GTK_HTML_COMMAND_DELETE,
	GTK_HTML_COMMAND_DELETE_BACK,
	GTK_HTML_COMMAND_DELETE_BACK_OR_INDENT_DEC,

	GTK_HTML_COMMAND_SET_MARK,
	GTK_HTML_COMMAND_DISABLE_SELECTION,

	GTK_HTML_COMMAND_BOLD_ON,
	GTK_HTML_COMMAND_BOLD_OFF,
	GTK_HTML_COMMAND_BOLD_TOGGLE,

	GTK_HTML_COMMAND_ITALIC_ON,
	GTK_HTML_COMMAND_ITALIC_OFF,
	GTK_HTML_COMMAND_ITALIC_TOGGLE,

	GTK_HTML_COMMAND_UNDERLINE_ON,
	GTK_HTML_COMMAND_UNDERLINE_OFF,
	GTK_HTML_COMMAND_UNDERLINE_TOGGLE,

	GTK_HTML_COMMAND_STRIKEOUT_ON,
	GTK_HTML_COMMAND_STRIKEOUT_OFF,
	GTK_HTML_COMMAND_STRIKEOUT_TOGGLE,

	GTK_HTML_COMMAND_SIZE_MINUS_2,
	GTK_HTML_COMMAND_SIZE_MINUS_1,
	GTK_HTML_COMMAND_SIZE_PLUS_0,
	GTK_HTML_COMMAND_SIZE_PLUS_1,
	GTK_HTML_COMMAND_SIZE_PLUS_2,
	GTK_HTML_COMMAND_SIZE_PLUS_3,
	GTK_HTML_COMMAND_SIZE_PLUS_4,

	GTK_HTML_COMMAND_SIZE_INCREASE,
	GTK_HTML_COMMAND_SIZE_DECREASE,

	GTK_HTML_COMMAND_ALIGN_LEFT,
	GTK_HTML_COMMAND_ALIGN_CENTER,
	GTK_HTML_COMMAND_ALIGN_RIGHT,

	GTK_HTML_COMMAND_INDENT_ZERO,
	GTK_HTML_COMMAND_INDENT_INC,
	GTK_HTML_COMMAND_INDENT_DEC,
	GTK_HTML_COMMAND_INDENT_PARAGRAPH,

	GTK_HTML_COMMAND_PARAGRAPH_STYLE_NORMAL,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_H1,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_H2,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_H3,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_H4,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_H5,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_H6,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_ADDRESS,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_PRE,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_ITEMDOTTED,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_ITEMROMAN,
	GTK_HTML_COMMAND_PARAGRAPH_STYLE_ITEMDIGIT,

	GTK_HTML_COMMAND_MODIFY_SELECTION_UP,
	GTK_HTML_COMMAND_MODIFY_SELECTION_DOWN,
	GTK_HTML_COMMAND_MODIFY_SELECTION_LEFT,
	GTK_HTML_COMMAND_MODIFY_SELECTION_RIGHT,
	GTK_HTML_COMMAND_MODIFY_SELECTION_PAGEUP,
	GTK_HTML_COMMAND_MODIFY_SELECTION_PAGEDOWN,
	GTK_HTML_COMMAND_MODIFY_SELECTION_BOL,
	GTK_HTML_COMMAND_MODIFY_SELECTION_EOL,
	GTK_HTML_COMMAND_MODIFY_SELECTION_BOD,
	GTK_HTML_COMMAND_MODIFY_SELECTION_EOD,

	GTK_HTML_COMMAND_CAPITALIZE_WORD,
	GTK_HTML_COMMAND_UPCASE_WORD,
	GTK_HTML_COMMAND_DOWNCASE_WORD,

	GTK_HTML_COMMAND_SPELL_SUGGEST,
	GTK_HTML_COMMAND_SPELL_PERSONAL_DICTIONARY_ADD,
	GTK_HTML_COMMAND_SPELL_SESSION_DICTIONARY_ADD,

	GTK_HTML_COMMAND_SEARCH,
	GTK_HTML_COMMAND_SEARCH_INCREMENTAL_FORWARD,
	GTK_HTML_COMMAND_SEARCH_INCREMENTAL_BACKWARD,
	GTK_HTML_COMMAND_SEARCH_REGEX,

	GTK_HTML_COMMAND_FOCUS_FORWARD,
	GTK_HTML_COMMAND_FOCUS_BACKWARD,

	GTK_HTML_COMMAND_POPUP_MENU,
	GTK_HTML_COMMAND_PROPERTIES_DIALOG,

	GTK_HTML_COMMAND_CURSOR_FORWARD,
	GTK_HTML_COMMAND_CURSOR_BACKWARD
} GtkHTMLCommandType;
</ENUM>
<ENUM>
<NAME>GtkHTMLCursorSkipType</NAME>
typedef enum {
	GTK_HTML_CURSOR_SKIP_ONE,
	GTK_HTML_CURSOR_SKIP_WORD,
	GTK_HTML_CURSOR_SKIP_PAGE,
	GTK_HTML_CURSOR_SKIP_ALL
} GtkHTMLCursorSkipType;
</ENUM>
<ENUM>
<NAME>GtkHTMLEditorEventType</NAME>
typedef enum {
	GTK_HTML_EDITOR_EVENT_COMMAND,
	GTK_HTML_EDITOR_EVENT_IMAGE_URL
} GtkHTMLEditorEventType;
</ENUM>
<ENUM>
<NAME>GtkHTMLEtchStyle</NAME>
typedef enum {
	GTK_HTML_ETCH_IN,
	GTK_HTML_ETCH_OUT,
	GTK_HTML_ETCH_NONE
} GtkHTMLEtchStyle; 
</ENUM>
<ENUM>
<NAME>GtkHTMLFontStyle</NAME>
typedef enum {
	GTK_HTML_FONT_STYLE_DEFAULT = 0,
	GTK_HTML_FONT_STYLE_SIZE_1 = 1,
	GTK_HTML_FONT_STYLE_SIZE_2 = 2,
	GTK_HTML_FONT_STYLE_SIZE_3 = 3,
	GTK_HTML_FONT_STYLE_SIZE_4 = 4,
	GTK_HTML_FONT_STYLE_SIZE_5 = 5,
	GTK_HTML_FONT_STYLE_SIZE_6 = 6,
	GTK_HTML_FONT_STYLE_SIZE_7 = 7,
	GTK_HTML_FONT_STYLE_SIZE_MASK = 0x7,
	GTK_HTML_FONT_STYLE_BOLD        = 1 << 3,
	GTK_HTML_FONT_STYLE_ITALIC      = 1 << 4,
	GTK_HTML_FONT_STYLE_UNDERLINE   = 1 << 5,
	GTK_HTML_FONT_STYLE_STRIKEOUT   = 1 << 6,
	GTK_HTML_FONT_STYLE_FIXED       = 1 << 7,
	GTK_HTML_FONT_STYLE_SUBSCRIPT   = 1 << 8,
	GTK_HTML_FONT_STYLE_SUPERSCRIPT = 1 << 9
} GtkHTMLFontStyle;
</ENUM>
<ENUM>
<NAME>GtkHTMLParagraphAlignment</NAME>
typedef enum {
	GTK_HTML_PARAGRAPH_ALIGNMENT_LEFT,
	GTK_HTML_PARAGRAPH_ALIGNMENT_RIGHT,
	GTK_HTML_PARAGRAPH_ALIGNMENT_CENTER
} GtkHTMLParagraphAlignment;
</ENUM>
<ENUM>
<NAME>GtkHTMLParagraphStyle</NAME>
typedef enum {
	GTK_HTML_PARAGRAPH_STYLE_NORMAL,
	GTK_HTML_PARAGRAPH_STYLE_H1,
	GTK_HTML_PARAGRAPH_STYLE_H2,
	GTK_HTML_PARAGRAPH_STYLE_H3,
	GTK_HTML_PARAGRAPH_STYLE_H4,
	GTK_HTML_PARAGRAPH_STYLE_H5,
	GTK_HTML_PARAGRAPH_STYLE_H6,
	GTK_HTML_PARAGRAPH_STYLE_ADDRESS,
	GTK_HTML_PARAGRAPH_STYLE_PRE,
	GTK_HTML_PARAGRAPH_STYLE_ITEMDOTTED,
	GTK_HTML_PARAGRAPH_STYLE_ITEMROMAN,
	GTK_HTML_PARAGRAPH_STYLE_ITEMDIGIT
} GtkHTMLParagraphStyle;
</ENUM>
<ENUM>
<NAME>GtkHTMLStreamStatus</NAME>
typedef enum {
	GTK_HTML_STREAM_OK,
	GTK_HTML_STREAM_ERROR
} GtkHTMLStreamStatus;
</ENUM>
<FUNCTION>
<NAME>gtk_html_im_focus_in</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_im_focus_out</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_im_realize</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_im_unrealize</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_im_size_allocate</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_im_style_set</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_handle_key_event</NAME>
<RETURNS>gint  </RETURNS>
GtkHTML     *html,GdkEventKey *event,gboolean    *update_styles
</FUNCTION>
<STRUCT>
<NAME>GtkHTMLPrivate</NAME>
struct GtkHTMLPrivate {
	guint idle_handler_id;
	guint scroll_timeout_id;

	GtkHTMLParagraphStyle paragraph_style;
	guint paragraph_indentation;
	GtkHTMLParagraphAlignment paragraph_alignment;
	GtkHTMLFontStyle insertion_font_style;

	gint last_selection_type;
	gchar *content_type;

#ifdef GTKHTML_HAVE_GCONF
	guint set_font_id;
#endif
#ifdef GTK_HTML_USE_XIM
	GdkICAttr *ic_attr;
	GdkIC *ic;
#endif
};
</STRUCT>
<FUNCTION>
<NAME>gtk_html_private_calc_scrollbars</NAME>
<RETURNS>void  </RETURNS>
GtkHTML            *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_editor_event_command</NAME>
<RETURNS>void  </RETURNS>
GtkHTML            *html,GtkHTMLCommandType  com_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_isearch</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html, gboolean forward
</FUNCTION>
<STRUCT>
<NAME>GtkHTMLStream</NAME>
struct GtkHTMLStream {
	GtkHTMLStreamWriteFunc write_func;
	GtkHTMLStreamCloseFunc close_func;
	gpointer user_data;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_html_stream_new</NAME>
<RETURNS>GtkHTMLStream  *</RETURNS>
GtkHTML                *html,GtkHTMLStreamWriteFunc  write_func,GtkHTMLStreamCloseFunc  close_func,gpointer                user_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_stream_write</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLStream          *stream,const gchar            *buffer,size_t                  size
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_stream_destroy</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLStream          *stream
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_stream_close</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLStream          *stream,GtkHTMLStreamStatus     status
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_stream_ref</NAME>
<RETURNS>GtkHTMLStream  *</RETURNS>
GtkHTMLStream          *handle
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_stream_unref</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLStream          *handle
</FUNCTION>
<STRUCT>
<NAME>GtkHTML</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHTMLClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHTMLClassProperties</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHTMLEditorAPI</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHTMLEmbedded</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHTMLEmbeddedClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHTMLEmbeddedPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHTMLPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHTMLStream</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GtkHTMLStreamCloseFunc</NAME>
<RETURNS>void </RETURNS>
GtkHTMLStream *stream,
					 GtkHTMLStreamStatus status,
					 gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkHTMLStreamWriteFunc</NAME>
<RETURNS>void </RETURNS>
GtkHTMLStream *stream,
					 const gchar *buffer,
					 guint size,
					 gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkHTMLSaveReceiverFn</NAME>
<RETURNS>gboolean </RETURNS>
gpointer     engine,
					      const gchar *data,
					      guint        len,
					      gpointer     user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkHTMLPrintCallback</NAME>
<RETURNS>void </RETURNS>
GtkHTML *html, GnomePrintContext *print_context,
				      gdouble x, gdouble y, gdouble width, gdouble height, gpointer user_data
</USER_FUNCTION>
<MACRO>
<NAME>GTK_TYPE_HTML</NAME>
#define GTK_TYPE_HTML                  (gtk_html_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_HTML</NAME>
#define GTK_HTML(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_HTML, GtkHTML))
</MACRO>
<MACRO>
<NAME>GTK_HTML_CLASS</NAME>
#define GTK_HTML_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_HTML, GtkHTMLClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_HTML</NAME>
#define GTK_IS_HTML(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_HTML))
</MACRO>
<MACRO>
<NAME>GTK_IS_HTML_CLASS</NAME>
#define GTK_IS_HTML_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_HTML))
</MACRO>
<STRUCT>
<NAME>GtkHTML</NAME>
struct GtkHTML {
	GtkLayout layout;

	GtkBindingSet        *editor_bindings;
	GtkWidget            *iframe_parent;
	GtkHTMLEditorAPI     *editor_api;
	gpointer              editor_data;
	HTMLEngine           *engine;

	/* The URL of the link over which the pointer currently is.  NULL if
           the pointer is not over a link.  */
	gchar *pointer_url;

	/* The cursors we use within the widget.  */
	GdkCursor *hand_cursor;
	GdkCursor *arrow_cursor;
	GdkCursor *ibeam_cursor;

	gint selection_x1, selection_y1;

	guint in_selection : 1;
	guint button1_pressed : 1;
	guint load_in_progress : 1;

	guint debug : 1;
	guint allow_selection : 1;

	guint hadj_connection;
	guint vadj_connection;

	gboolean binding_handled;
	GtkHTMLPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GtkHTMLEditorAPI</NAME>
struct GtkHTMLEditorAPI
{
	/* spell checking methods */
	gboolean  (* check_word)              (GtkHTML *html, const gchar *word, gpointer data);
	void      (* suggestion_request)      (GtkHTML *html, const gchar *word, gpointer data);
	void      (* add_to_session)          (GtkHTML *html, const gchar *word, gpointer data);
	void      (* add_to_personal)         (GtkHTML *html, const gchar *word, gpointer data);

	/* unhandled commands */
	gboolean  (* command)                 (GtkHTML *html, GtkHTMLCommandType com_type, gpointer data);

	GtkArg  * (* event)                   (GtkHTML *html, GtkHTMLEditorEventType event_type, GtkArg **args, gpointer data);

	/* input line */
	GtkEntry * (* create_input_line)      (GtkHTML *html, gpointer data);
};
</STRUCT>
<FUNCTION>
<NAME>gtk_html_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_construct</NAME>
<RETURNS>void  </RETURNS>
GtkWidget        *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_new_from_string</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar      *str,gint              len
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_set_editor_api</NAME>
<RETURNS>void  </RETURNS>
GtkHTML          *html,GtkHTMLEditorAPI *api,gpointer          data
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_set_iframe_parent</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html,GtkWidget *parent
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_enable_debug</NAME>
<RETURNS>void  </RETURNS>
GtkHTML  *html,gboolean  debug
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_allow_selection</NAME>
<RETURNS>void  </RETURNS>
GtkHTML  *html,gboolean  allow
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_select_word</NAME>
<RETURNS>void  </RETURNS>
GtkHTML  *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_select_line</NAME>
<RETURNS>void  </RETURNS>
GtkHTML  *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_request_paste</NAME>
<RETURNS>int  </RETURNS>
GtkHTML  *html,gint      type,gint32    time
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_begin</NAME>
<RETURNS>GtkHTMLStream  *</RETURNS>
GtkHTML             *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_begin_content</NAME>
<RETURNS>GtkHTMLStream  *</RETURNS>
GtkHTML             *html,gchar               *content_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_write</NAME>
<RETURNS>void  </RETURNS>
GtkHTML             *html,GtkHTMLStream       *handle,const gchar         *buffer,size_t               size
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_end</NAME>
<RETURNS>void  </RETURNS>
GtkHTML             *html,GtkHTMLStream       *handle,GtkHTMLStreamStatus  status
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_load_empty</NAME>
<RETURNS>void  </RETURNS>
GtkHTML             *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_load_from_string</NAME>
<RETURNS>void  </RETURNS>
GtkHTML             *html,const gchar         *str,gint                 len
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_save</NAME>
<RETURNS>gboolean  </RETURNS>
GtkHTML               *html,GtkHTMLSaveReceiverFn  receiver,gpointer               data
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_export</NAME>
<RETURNS>gboolean  </RETURNS>
GtkHTML               *html,const char            *type,GtkHTMLSaveReceiverFn  receiver,gpointer               data
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_set_editable</NAME>
<RETURNS>void  </RETURNS>
GtkHTML       *html,gboolean       editable
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_get_editable</NAME>
<RETURNS>gboolean  </RETURNS>
const GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_print_with_header_footer</NAME>
<RETURNS>void  </RETURNS>
GtkHTML              *html,GnomePrintContext    *print_context,gdouble               header_height,gdouble               footer_height,GtkHTMLPrintCallback  header_print,GtkHTMLPrintCallback  footer_print,gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_print</NAME>
<RETURNS>void  </RETURNS>
GtkHTML              *html,GnomePrintContext    *print_context
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_get_title</NAME>
<RETURNS>const gchar  *</RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_jump_to_anchor</NAME>
<RETURNS>gboolean  </RETURNS>
GtkHTML *html,const gchar *anchor
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_get_paragraph_style</NAME>
<RETURNS>GtkHTMLParagraphStyle 	</RETURNS>
GtkHTML                   *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_set_paragraph_style</NAME>
<RETURNS>void  </RETURNS>
GtkHTML                   *html,GtkHTMLParagraphStyle      style
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_set_indent</NAME>
<RETURNS>void  </RETURNS>
GtkHTML                   *html,gint                       level
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_modify_indent_by_delta</NAME>
<RETURNS>void  </RETURNS>
GtkHTML                   *html,gint                       delta
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_set_font_style</NAME>
<RETURNS>void  </RETURNS>
GtkHTML                   *html,GtkHTMLFontStyle           and_mask,GtkHTMLFontStyle           or_mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_set_color</NAME>
<RETURNS>void  </RETURNS>
GtkHTML                   *html,HTMLColor                 *color
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_toggle_font_style</NAME>
<RETURNS>void  </RETURNS>
GtkHTML                   *html,GtkHTMLFontStyle           style
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_get_paragraph_alignment</NAME>
<RETURNS>GtkHTMLParagraphAlignment  </RETURNS>
GtkHTML                   *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_set_paragraph_alignment</NAME>
<RETURNS>void  </RETURNS>
GtkHTML                   *html,GtkHTMLParagraphAlignment  alignment
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_cut</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_copy</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_paste</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_undo</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_redo</NAME>
<RETURNS>void  </RETURNS>
GtkHTML *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_set_default_background_color</NAME>
<RETURNS>void  </RETURNS>
GtkHTML     *html,GdkColor    *c
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_set_default_content_type</NAME>
<RETURNS>void  </RETURNS>
GtkHTML     *html,gchar       *content_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_get_object_by_id</NAME>
<RETURNS>gpointer  </RETURNS>
GtkHTML     *html,const gchar *id
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_editor_command</NAME>
<RETURNS>void  </RETURNS>
GtkHTML     *html,const gchar *command_name
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_edit_make_cursor_visible</NAME>
<RETURNS>gboolean  </RETURNS>
GtkHTML     *html
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_debug_log</NAME>
<RETURNS>void  </RETURNS>
GtkHTML     *html,const gchar *format,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_debug_dump_tree</NAME>
<RETURNS>void  </RETURNS>
HTMLObject  *o,gint         level
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_debug_dump_object_type</NAME>
<RETURNS>void  </RETURNS>
HTMLObject  *o
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_debug_dump_table</NAME>
<RETURNS>void  </RETURNS>
HTMLObject  *o,gint         level
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_debug_dump_tree_simple</NAME>
<RETURNS>void  </RETURNS>
HTMLObject  *o,gint         level
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_debug_dump_list_simple</NAME>
<RETURNS>void  </RETURNS>
GList       *list,gint         level
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_debug_dump_object</NAME>
<RETURNS>void  </RETURNS>
HTMLObject  *o,gint         level
</FUNCTION>
<MACRO>
<NAME>GTK_HTML_FONT_STYLE_SIZE_MAX</NAME>
#define GTK_HTML_FONT_STYLE_SIZE_MAX 7
</MACRO>
<MACRO>
<NAME>GTK_HTML_FONT_STYLE_MAX</NAME>
#define GTK_HTML_FONT_STYLE_MAX									\
	(GTK_HTML_FONT_STYLE_SIZE_MASK | GTK_HTML_FONT_STYLE_BOLD | GTK_HTML_FONT_STYLE_ITALIC	\
	 | GTK_HTML_FONT_STYLE_UNDERLINE | GTK_HTML_FONT_STYLE_STRIKEOUT | GTK_HTML_FONT_STYLE_FIXED \
	 | GTK_HTML_FONT_STYLE_SUBSCRIPT | GTK_HTML_FONT_STYLE_SUPERSCRIPT)
</MACRO>
<MACRO>
<NAME>GTK_HTML_FONT_STYLE_MAX_FONT</NAME>
#define GTK_HTML_FONT_STYLE_MAX_FONT      ((GTK_HTML_FONT_STYLE_ITALIC) << 1)
</MACRO>
<MACRO>
<NAME>GTK_HTML_FONT_STYLE_MAX_FONT_MASK</NAME>
#define GTK_HTML_FONT_STYLE_MAX_FONT_MASK (GTK_HTML_FONT_STYLE_MAX_FONT - 1)
</MACRO>
<FUNCTION>
<NAME>gtk_html_font_style_merge</NAME>
<RETURNS>GtkHTMLFontStyle  </RETURNS>
GtkHTMLFontStyle a, GtkHTMLFontStyle b
</FUNCTION>
<MACRO>
<NAME>HTML_ANCHOR</NAME>
#define HTML_ANCHOR(x) ((HTMLAnchor *) x)
</MACRO>
<MACRO>
<NAME>HTML_ANCHOR_CLASS</NAME>
#define HTML_ANCHOR_CLASS(x) ((HTMLAnchorClass *) x)
</MACRO>
<STRUCT>
<NAME>HTMLAnchor</NAME>
struct HTMLAnchor {
	HTMLObject object;

	GString *name;
};
</STRUCT>
<FUNCTION>
<NAME>html_anchor_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_anchor_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLAnchorClass *klass,HTMLType         type,guint            object_size
</FUNCTION>
<FUNCTION>
<NAME>html_anchor_new</NAME>
<RETURNS>HTMLObject   *</RETURNS>
const gchar     *name
</FUNCTION>
<FUNCTION>
<NAME>html_anchor_init</NAME>
<RETURNS>void  </RETURNS>
HTMLAnchor      *anchor,HTMLAnchorClass *klass,const gchar     *name
</FUNCTION>
<FUNCTION>
<NAME>html_anchor_get_name</NAME>
<RETURNS>const gchar  *</RETURNS>
HTMLAnchor      *anchor
</FUNCTION>
<MACRO>
<NAME>HTML_BUTTON</NAME>
#define HTML_BUTTON(x) ((HTMLButton *) (x))
</MACRO>
<MACRO>
<NAME>HTML_BUTTON_CLASS</NAME>
#define HTML_BUTTON_CLASS(x) ((HTMLButtonClass *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLButton</NAME>
struct HTMLButton {
	HTMLEmbedded element;
	HTMLButtonType type;
};
</STRUCT>
<VARIABLE>
<NAME>html_button_class</NAME>
extern HTMLButtonClass html_button_class;
</VARIABLE>
<FUNCTION>
<NAME>html_button_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_button_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLButtonClass *klass,HTMLType         type,guint            object_size
</FUNCTION>
<FUNCTION>
<NAME>html_button_init</NAME>
<RETURNS>void  </RETURNS>
HTMLButton      *button,HTMLButtonClass *klass,GtkWidget       *parent,gchar           *name,gchar           *value,HTMLButtonType   type
</FUNCTION>
<FUNCTION>
<NAME>html_button_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
GtkWidget       *parent,gchar           *name,gchar           *value,HTMLButtonType   type
</FUNCTION>
<MACRO>
<NAME>HTML_CHECKBOX</NAME>
#define HTML_CHECKBOX(x) ((HTMLCheckBox *) (x))
</MACRO>
<MACRO>
<NAME>HTML_CHECKBOX_CLASS</NAME>
#define HTML_CHECKBOX_CLASS(x) ((HTMLCheckBoxClass *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLCheckBox</NAME>
struct HTMLCheckBox {
	HTMLEmbedded element;
	gint default_checked;
};
</STRUCT>
<VARIABLE>
<NAME>html_checkbox_class</NAME>
extern HTMLCheckBoxClass html_checkbox_class;
</VARIABLE>
<FUNCTION>
<NAME>html_checkbox_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_checkbox_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLCheckBoxClass *klass,HTMLType           type,guint              object_size
</FUNCTION>
<FUNCTION>
<NAME>html_checkbox_init</NAME>
<RETURNS>void  </RETURNS>
HTMLCheckBox      *checkbox,HTMLCheckBoxClass *klass,GtkWidget         *parent,gchar             *name,gchar             *value,gboolean           checked
</FUNCTION>
<FUNCTION>
<NAME>html_checkbox_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
GtkWidget         *parent,gchar             *name,gchar             *value,gboolean           checked
</FUNCTION>
<MACRO>
<NAME>HTML_CLUE</NAME>
#define HTML_CLUE(x) ((HTMLClue *)(x))
</MACRO>
<MACRO>
<NAME>HTML_CLUE_CLASS</NAME>
#define HTML_CLUE_CLASS(x) ((HTMLClueClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLClue</NAME>
struct HTMLClue {
	HTMLObject object;
	
	HTMLObject *head;
	HTMLObject *tail;
	HTMLObject *curr;
	
	HTMLVAlignType valign;
	HTMLHAlignType halign;
};
</STRUCT>
<VARIABLE>
<NAME>html_clue_class</NAME>
extern HTMLClueClass html_clue_class;
</VARIABLE>
<FUNCTION>
<NAME>html_clue_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_clue_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLClueClass *klass,HTMLType       type,guint          object_size
</FUNCTION>
<FUNCTION>
<NAME>html_clue_init</NAME>
<RETURNS>void  </RETURNS>
HTMLClue      *clue,HTMLClueClass *klass
</FUNCTION>
<FUNCTION>
<NAME>html_clue_get_left_clear</NAME>
<RETURNS>gint  </RETURNS>
HTMLClue      *clue,gint           y
</FUNCTION>
<FUNCTION>
<NAME>html_clue_get_right_clear</NAME>
<RETURNS>gint  </RETURNS>
HTMLClue      *clue,gint           y
</FUNCTION>
<FUNCTION>
<NAME>html_clue_find_free_area</NAME>
<RETURNS>void  </RETURNS>
HTMLClue      *clue,gint           y,gint           width,gint           height,gint           indent,gint          *y_pos,gint          *lmargin,gint          *rmargin
</FUNCTION>
<FUNCTION>
<NAME>html_clue_append_right_aligned</NAME>
<RETURNS>void  </RETURNS>
HTMLClue      *clue,HTMLClue      *aclue
</FUNCTION>
<FUNCTION>
<NAME>html_clue_append_left_aligned</NAME>
<RETURNS>void  </RETURNS>
HTMLClue      *clue,HTMLClue      *aclue
</FUNCTION>
<FUNCTION>
<NAME>html_clue_appended</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLClue      *clue,HTMLClue      *aclue
</FUNCTION>
<FUNCTION>
<NAME>html_clue_append_after</NAME>
<RETURNS>void  </RETURNS>
HTMLClue      *clue,HTMLObject    *o,HTMLObject    *where
</FUNCTION>
<FUNCTION>
<NAME>html_clue_append</NAME>
<RETURNS>void  </RETURNS>
HTMLClue      *clue,HTMLObject    *o
</FUNCTION>
<FUNCTION>
<NAME>html_clue_prepend</NAME>
<RETURNS>void  </RETURNS>
HTMLClue      *clue,HTMLObject    *o
</FUNCTION>
<FUNCTION>
<NAME>html_clue_remove</NAME>
<RETURNS>void  </RETURNS>
HTMLClue      *clue,HTMLObject    *o
</FUNCTION>
<MACRO>
<NAME>HTML_CLUEALIGNED</NAME>
#define HTML_CLUEALIGNED(x)       ((HTMLClueAligned *)(x))
</MACRO>
<MACRO>
<NAME>HTML_CLUEALIGNED_CLASS</NAME>
#define HTML_CLUEALIGNED_CLASS(x) ((HTMLClueAlignedClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLClueAligned</NAME>
struct HTMLClueAligned {
	HTMLClue clue;

	HTMLClueAligned *next_aligned;
};
</STRUCT>
<VARIABLE>
<NAME>html_cluealigned_class</NAME>
extern HTMLClueAlignedClass html_cluealigned_class;
</VARIABLE>
<FUNCTION>
<NAME>html_cluealigned_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_cluealigned_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLClueAlignedClass *klass,HTMLType              type,guint                 object_size
</FUNCTION>
<FUNCTION>
<NAME>html_cluealigned_init</NAME>
<RETURNS>void  </RETURNS>
HTMLClueAligned      *aligned,HTMLClueAlignedClass *klass,HTMLObject           *parent,gint                  x,gint                  y,gint                  max_width,gint                  percent
</FUNCTION>
<FUNCTION>
<NAME>html_cluealigned_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
HTMLObject           *parent,gint                  x,gint                  y,gint                  max_width,gint                  percent
</FUNCTION>
<MACRO>
<NAME>HTML_CLUEFLOW</NAME>
#define HTML_CLUEFLOW(x) ((HTMLClueFlow *)(x))
</MACRO>
<MACRO>
<NAME>HTML_CLUEFLOW_CLASS</NAME>
#define HTML_CLUEFLOW_CLASS(x) ((HTMLClueFlowClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLClueFlow</NAME>
struct HTMLClueFlow {
	HTMLClue clue;

	/* Paragraph style.  */
	HTMLClueFlowStyle style;

	/* Indentation level for blockquote and lists.  */
	guint8 level;
};
</STRUCT>
<VARIABLE>
<NAME>html_clueflow_class</NAME>
extern HTMLClueFlowClass html_clueflow_class;
</VARIABLE>
<FUNCTION>
<NAME>html_clueflow_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLClueFlowClass  *klass,HTMLType            type,guint               object_size
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_init</NAME>
<RETURNS>void  </RETURNS>
HTMLClueFlow       *flow,HTMLClueFlowClass  *klass,HTMLClueFlowStyle   style,guint8              indentation
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_new</NAME>
<RETURNS>HTMLObject         *</RETURNS>
HTMLClueFlowStyle   style,guint8              indentation
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_new_from_flow</NAME>
<RETURNS>HTMLObject         *</RETURNS>
HTMLClueFlow       *flow
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_get_default_font_style</NAME>
<RETURNS>GtkHTMLFontStyle  </RETURNS>
const HTMLClueFlow *self
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_split</NAME>
<RETURNS>HTMLClueFlow       *</RETURNS>
HTMLClueFlow       *clue,HTMLObject         *child
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_set_style</NAME>
<RETURNS>void  </RETURNS>
HTMLClueFlow       *flow,HTMLEngine         *engine,HTMLClueFlowStyle   style
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_get_style</NAME>
<RETURNS>HTMLClueFlowStyle  </RETURNS>
HTMLClueFlow       *flow
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_set_halignment</NAME>
<RETURNS>void  </RETURNS>
HTMLClueFlow       *flow,HTMLEngine         *engine,HTMLHAlignType      alignment
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_get_halignment</NAME>
<RETURNS>HTMLHAlignType  </RETURNS>
HTMLClueFlow       *flow
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_modify_indentation_by_delta</NAME>
<RETURNS>void  </RETURNS>
HTMLClueFlow       *flow,HTMLEngine         *engine,gint                indentation
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_set_indentation</NAME>
<RETURNS>void  </RETURNS>
HTMLClueFlow       *flow,HTMLEngine         *engine,guint8              indentation
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_get_indentation</NAME>
<RETURNS>guint8  </RETURNS>
HTMLClueFlow       *flow
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_set_properties</NAME>
<RETURNS>void  </RETURNS>
HTMLClueFlow       *flow,HTMLEngine         *engine,HTMLClueFlowStyle   style,guint8              indentation,HTMLHAlignType      alignment
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_get_properties</NAME>
<RETURNS>void  </RETURNS>
HTMLClueFlow       *flow,HTMLClueFlowStyle  *style_return,guint8             *indentation_return,HTMLHAlignType     *alignment_return
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_remove_text_slaves</NAME>
<RETURNS>void  </RETURNS>
HTMLClueFlow       *flow
</FUNCTION>
<FUNCTION>
<NAME>html_clueflow_spell_check</NAME>
<RETURNS>void  </RETURNS>
HTMLClueFlow       *flow,HTMLEngine         *e,HTMLInterval       *i
</FUNCTION>
<MACRO>
<NAME>SPELL_CHECK</NAME>
#define SPELL_CHECK(f, e) if (f && HTML_OBJECT_TYPE (f) == HTML_TYPE_CLUEFLOW) \
                                   html_clueflow_spell_check (HTML_CLUEFLOW (f), e, NULL)
</MACRO>
<MACRO>
<NAME>HTML_CLUEH</NAME>
#define HTML_CLUEH(x) ((HTMLClueH *)(x))
</MACRO>
<MACRO>
<NAME>HTML_CLUEH_CLASS</NAME>
#define HTML_CLUEH_CLASS(X) ((HTMLClueHClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLClueH</NAME>
struct HTMLClueH {
	HTMLClue clue;

	gshort indent;
};
</STRUCT>
<VARIABLE>
<NAME>html_clue_h_class</NAME>
extern HTMLClueHClass html_clue_h_class;
</VARIABLE>
<FUNCTION>
<NAME>html_clueh_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_clueh_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLClueHClass *klass,HTMLType        type,guint           object_size
</FUNCTION>
<FUNCTION>
<NAME>html_clueh_init</NAME>
<RETURNS>void  </RETURNS>
HTMLClueH      *clue,HTMLClueHClass *klass,gint            x,gint            y,gint            max_width
</FUNCTION>
<FUNCTION>
<NAME>html_clueh_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
gint            x,gint            y,gint            max_width
</FUNCTION>
<MACRO>
<NAME>HTML_CLUEV</NAME>
#define HTML_CLUEV(x) ((HTMLClueV *)(x))
</MACRO>
<MACRO>
<NAME>HTML_CLUEV_CLASS</NAME>
#define HTML_CLUEV_CLASS(x) ((HTMLClueVClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLClueV</NAME>
struct HTMLClueV {
	HTMLClue clue;
	
	/* FIXME: htmlcluealigned */
	HTMLObject *align_left_list;
	HTMLObject *align_right_list;
	gushort padding;
};
</STRUCT>
<VARIABLE>
<NAME>html_cluev_class</NAME>
extern HTMLClueVClass html_cluev_class;
</VARIABLE>
<FUNCTION>
<NAME>html_cluev_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_cluev_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLClueVClass *klass,HTMLType        type,guint           object_size
</FUNCTION>
<FUNCTION>
<NAME>html_cluev_init</NAME>
<RETURNS>void  </RETURNS>
HTMLClueV      *cluev,HTMLClueVClass *klass,gint            x,gint            y,gint            percent
</FUNCTION>
<FUNCTION>
<NAME>html_cluev_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
gint            x,gint            y,gint            percent
</FUNCTION>
<STRUCT>
<NAME>HTMLColor</NAME>
struct HTMLColor {
	GdkColor color;
	gboolean allocated;
	guint refcount;
};
</STRUCT>
<FUNCTION>
<NAME>html_color_new</NAME>
<RETURNS>HTMLColor  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_color_new_from_gdk_color</NAME>
<RETURNS>HTMLColor  *</RETURNS>
const GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>html_color_new_from_rgb</NAME>
<RETURNS>HTMLColor  *</RETURNS>
gushort red, gushort green, gushort blue
</FUNCTION>
<FUNCTION>
<NAME>html_color_ref</NAME>
<RETURNS>void  </RETURNS>
HTMLColor *color
</FUNCTION>
<FUNCTION>
<NAME>html_color_unref</NAME>
<RETURNS>void  </RETURNS>
HTMLColor *color
</FUNCTION>
<FUNCTION>
<NAME>html_color_alloc</NAME>
<RETURNS>void  </RETURNS>
HTMLColor *color, HTMLPainter *painter
</FUNCTION>
<FUNCTION>
<NAME>html_color_free</NAME>
<RETURNS>void  </RETURNS>
HTMLColor *color, HTMLPainter *painter
</FUNCTION>
<FUNCTION>
<NAME>html_color_equal</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLColor *color1, HTMLColor *color2
</FUNCTION>
<FUNCTION>
<NAME>html_color_set</NAME>
<RETURNS>void  </RETURNS>
HTMLColor *color, GdkColor *c
</FUNCTION>
<STRUCT>
<NAME>HTMLColorSet</NAME>
struct HTMLColorSet
{
	HTMLColor *color [HTMLColors];
	gboolean changed [HTMLColors];

	/* slave sets - they must be updated when setting this one
	   engine has master set and painters have slave ones
	 */
	GSList  *slaves;
};
</STRUCT>
<FUNCTION>
<NAME>html_colorset_new</NAME>
<RETURNS>HTMLColorSet      *</RETURNS>
GtkWidget *w
</FUNCTION>
<FUNCTION>
<NAME>html_colorset_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLColorSet *set
</FUNCTION>
<FUNCTION>
<NAME>html_colorset_add_slave</NAME>
<RETURNS>void  </RETURNS>
HTMLColorSet *set,HTMLColorSet *slave
</FUNCTION>
<FUNCTION>
<NAME>html_colorset_set_color</NAME>
<RETURNS>void  </RETURNS>
HTMLColorSet *set,GdkColor *color,HTMLColorId idx
</FUNCTION>
<FUNCTION>
<NAME>html_colorset_get_color</NAME>
<RETURNS>HTMLColor         *</RETURNS>
HTMLColorSet *set,HTMLColorId idx
</FUNCTION>
<FUNCTION>
<NAME>html_colorset_get_color_allocated</NAME>
<RETURNS>HTMLColor         *</RETURNS>
HTMLPainter *painter,HTMLColorId idx
</FUNCTION>
<FUNCTION>
<NAME>html_colorset_set_by</NAME>
<RETURNS>void  </RETURNS>
HTMLColorSet *s, HTMLColorSet *o
</FUNCTION>
<FUNCTION>
<NAME>html_colorset_set_unchanged</NAME>
<RETURNS>void  </RETURNS>
HTMLColorSet *s, HTMLColorSet *o
</FUNCTION>
<FUNCTION>
<NAME>html_colorset_set_style</NAME>
<RETURNS>void  </RETURNS>
HTMLColorSet *s, GtkStyle *style
</FUNCTION>
<STRUCT>
<NAME>HTMLCursor</NAME>
struct HTMLCursor {
	HTMLObject *object;
	guint offset;

	gint target_x;
	guint have_target_x : 1;

	gint position;
};
</STRUCT>
<FUNCTION>
<NAME>html_cursor_new</NAME>
<RETURNS>HTMLCursor  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLCursor       *cursor
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_dup</NAME>
<RETURNS>HTMLCursor  *</RETURNS>
const HTMLCursor *cursor
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_copy</NAME>
<RETURNS>void  </RETURNS>
HTMLCursor       *dest,const HTMLCursor *src
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_home</NAME>
<RETURNS>void  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_forward</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_backward</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_forward_n</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *e,guint      n
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_backward_n</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *e,guint      n
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_up</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_down</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_beginning_of_document</NAME>
<RETURNS>void  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_end_of_document</NAME>
<RETURNS>void  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_beginning_of_line</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_end_of_line</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_beginning_of_paragraph</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_end_of_paragraph</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_jump_to</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine,HTMLObject *obj,guint       offset
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_normalize</NAME>
<RETURNS>void  </RETURNS>
HTMLCursor *cursor
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_get_position</NAME>
<RETURNS>gint  </RETURNS>
HTMLCursor *cursor
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_jump_to_position</NAME>
<RETURNS>void  </RETURNS>
HTMLCursor *cursor,HTMLEngine *engine,gint        position
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_get_current_char</NAME>
<RETURNS>unicode_char_t  </RETURNS>
const HTMLCursor *cursor
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_get_prev_char</NAME>
<RETURNS>unicode_char_t  </RETURNS>
const HTMLCursor *cursor
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_equal</NAME>
<RETURNS>gboolean  </RETURNS>
const HTMLCursor *a,const HTMLCursor *b
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_precedes</NAME>
<RETURNS>gboolean  </RETURNS>
const HTMLCursor *a,const HTMLCursor *b
</FUNCTION>
<FUNCTION>
<NAME>html_cursor_follows</NAME>
<RETURNS>gboolean  </RETURNS>
const HTMLCursor *a,const HTMLCursor *b
</FUNCTION>
<STRUCT>
<NAME>HTMLDrawQueueClearElement</NAME>
struct HTMLDrawQueueClearElement {
	gint x, y;
	guint width, height;
	GdkColor *background_color;
	GdkPixbuf *background_image;
	guint background_image_x_offset, background_image_y_offset;
};
</STRUCT>
<STRUCT>
<NAME>HTMLDrawQueue</NAME>
struct HTMLDrawQueue {
	/* The associated engine.  */
	HTMLEngine *engine;

	/* Elements to be drawn.  */
	GList *elems;
	/* Pointer to the last element in the list, for faster appending.  */
	GList *last;

	/* Elements to be cleared (HTMLDrawQueueClearElement).  */
	GList *clear_elems;
	/* Pointer to the last element.  */
	GList *clear_last;
};
</STRUCT>
<FUNCTION>
<NAME>html_draw_queue_new</NAME>
<RETURNS>HTMLDrawQueue  *</RETURNS>
HTMLEngine    *engine
</FUNCTION>
<FUNCTION>
<NAME>html_draw_queue_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLDrawQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>html_draw_queue_flush</NAME>
<RETURNS>void  </RETURNS>
HTMLDrawQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>html_draw_queue_clear</NAME>
<RETURNS>void  </RETURNS>
HTMLDrawQueue *queue
</FUNCTION>
<FUNCTION>
<NAME>html_draw_queue_add</NAME>
<RETURNS>void  </RETURNS>
HTMLDrawQueue *queue,HTMLObject    *object
</FUNCTION>
<FUNCTION>
<NAME>html_draw_queue_add_clear</NAME>
<RETURNS>void  </RETURNS>
HTMLDrawQueue  *queue,gint            x,gint            y,guint           width,guint           height,const GdkColor *background_color
</FUNCTION>
<FUNCTION>
<NAME>html_draw_queue_add_clear_with_background</NAME>
<RETURNS>void  </RETURNS>
HTMLDrawQueue  *queue,gint            x,gint            y,guint           width,guint           height,GdkPixbuf      *background_image,guint           image_x_offset,guint           image_y_offset
</FUNCTION>
<MACRO>
<NAME>HTML_EMBEDDED</NAME>
#define HTML_EMBEDDED(x) ((HTMLEmbedded *)(x))
</MACRO>
<MACRO>
<NAME>HTML_EMBEDDED_CLASS</NAME>
#define HTML_EMBEDDED_CLASS(x) ((HTMLEmbeddedClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLEmbedded</NAME>
struct HTMLEmbedded {
	HTMLObject object;
	
	gchar *name;
	gchar *value;
	HTMLForm *form;
	GtkWidget *widget, *parent;
	gint16 width, height;

	gint abs_x, abs_y;
};
</STRUCT>
<VARIABLE>
<NAME>html_embedded_class</NAME>
extern HTMLEmbeddedClass html_embedded_class;
</VARIABLE>
<FUNCTION>
<NAME>html_embedded_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_embedded_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLEmbeddedClass *klass,HTMLType           type,guint              object_size
</FUNCTION>
<FUNCTION>
<NAME>html_embedded_init</NAME>
<RETURNS>void  </RETURNS>
HTMLEmbedded      *element,HTMLEmbeddedClass *klass,GtkWidget         *parent,gchar             *name,gchar             *value
</FUNCTION>
<FUNCTION>
<NAME>html_embedded_set_widget</NAME>
<RETURNS>void  </RETURNS>
HTMLEmbedded      *element,GtkWidget         *widget
</FUNCTION>
<FUNCTION>
<NAME>html_embedded_get_name</NAME>
<RETURNS>gchar         *</RETURNS>
HTMLEmbedded      *element
</FUNCTION>
<FUNCTION>
<NAME>html_embedded_set_form</NAME>
<RETURNS>void  </RETURNS>
HTMLEmbedded      *element,HTMLForm          *form
</FUNCTION>
<FUNCTION>
<NAME>html_embedded_reset</NAME>
<RETURNS>void  </RETURNS>
HTMLEmbedded      *element
</FUNCTION>
<FUNCTION>
<NAME>html_embedded_encode</NAME>
<RETURNS>gchar         *</RETURNS>
HTMLEmbedded      *element
</FUNCTION>
<FUNCTION>
<NAME>html_embedded_encode_string</NAME>
<RETURNS>gchar         *</RETURNS>
gchar             *str
</FUNCTION>
<FUNCTION>
<NAME>html_embedded_new_widget</NAME>
<RETURNS>HTMLEmbedded  *</RETURNS>
GtkWidget         *parent,GtkHTMLEmbedded   *eb
</FUNCTION>
<FUNCTION>
<NAME>html_embedded_size_recalc</NAME>
<RETURNS>void  </RETURNS>
HTMLEmbedded      *em
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_current_clueflow_style</NAME>
<RETURNS>HTMLClueFlowStyle  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_current_clueflow_indentation</NAME>
<RETURNS>guint  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_current_clueflow_alignment</NAME>
<RETURNS>HTMLHAlignType  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_set_clueflow_style</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine                     *engine,HTMLClueFlowStyle               style,HTMLHAlignType                  alignment,gint                            indentation_delta,HTMLEngineSetClueFlowStyleMask  mask,gboolean                        do_undo
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_current_clueflow_style</NAME>
<RETURNS>HTMLClueFlowStyle  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_current_clueflow_indentation</NAME>
<RETURNS>guint  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_current_clueflow_alignment</NAME>
<RETURNS>HTMLHAlignType  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_hide_cursor</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_show_cursor</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_draw_cursor_in_area</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine,gint        x,gint        y,gint        width,gint        height
</FUNCTION>
<FUNCTION>
<NAME>html_engine_setup_blinking_cursor</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_stop_blinking_cursor</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_reset_blinking_cursor</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_update_insertion_font_style</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine       *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_font_style</NAME>
<RETURNS>GtkHTMLFontStyle  </RETURNS>
HTMLEngine       *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_document_font_style</NAME>
<RETURNS>GtkHTMLFontStyle  </RETURNS>
HTMLEngine       *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_set_font_style</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine       *engine,GtkHTMLFontStyle  and_mask,GtkHTMLFontStyle  or_mask
</FUNCTION>
<FUNCTION>
<NAME>html_engine_toggle_font_style</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine       *engine,GtkHTMLFontStyle  style
</FUNCTION>
<FUNCTION>
<NAME>html_engine_font_size_inc_dec</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine       *e,gboolean          inc
</FUNCTION>
<FUNCTION>
<NAME>html_engine_update_insertion_color</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine       *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_set_color</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine       *engine,HTMLColor        *color
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_color</NAME>
<RETURNS>HTMLColor  *</RETURNS>
HTMLEngine       *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_document_color</NAME>
<RETURNS>HTMLColor  *</RETURNS>
HTMLEngine       *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_update_insertion_url_and_target</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine       *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_url</NAME>
<RETURNS>const gchar  *</RETURNS>
HTMLEngine       *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_set_url</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine       *e,const gchar      *url
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_target</NAME>
<RETURNS>const gchar  *</RETURNS>
HTMLEngine       *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_set_target</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine       *e,const gchar      *url
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_document_url</NAME>
<RETURNS>const gchar  *</RETURNS>
HTMLEngine       *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_document_target</NAME>
<RETURNS>const gchar  *</RETURNS>
HTMLEngine       *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_insert_image</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine     *e,const gchar    *file,const gchar    *url,const gchar    *target,gint16          width,gint16          height,gboolean        percent_width,gboolean        percent_height,gint8           border,HTMLColor *border_color,HTMLHAlignType  halign,HTMLVAlignType  valign,gint8           hspace,gint8           vspace
</FUNCTION>
<FUNCTION>
<NAME>html_engine_move_cursor</NAME>
<RETURNS>guint  </RETURNS>
HTMLEngine               *e,HTMLEngineCursorMovement  movement,guint                     count
</FUNCTION>
<FUNCTION>
<NAME>html_engine_jump_to_object</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine               *e,HTMLObject               *object,guint                     offset
</FUNCTION>
<FUNCTION>
<NAME>html_engine_jump_at</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine               *e,gint                      x,gint                      y
</FUNCTION>
<FUNCTION>
<NAME>html_engine_beginning_of_document</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_end_of_document</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_beginning_of_line</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_end_of_line</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_scroll_down</NAME>
<RETURNS>gint  </RETURNS>
HTMLEngine *engine,gint        amount
</FUNCTION>
<FUNCTION>
<NAME>html_engine_scroll_up</NAME>
<RETURNS>gint  </RETURNS>
HTMLEngine *engine,gint        amount
</FUNCTION>
<FUNCTION>
<NAME>html_engine_forward_word</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_backward_word</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_insert_rule</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine     *e,gint            length,gint            percent,gint            size,gboolean        shade,HTMLHAlignType  halign
</FUNCTION>
<FUNCTION>
<NAME>html_rule_set</NAME>
<RETURNS>void  </RETURNS>
HTMLRule       *rule,HTMLEngine     *e,gint            length,gint            percent,gint            size,gboolean        shade,HTMLHAlignType  halign
</FUNCTION>
<FUNCTION>
<NAME>html_engine_edit_selection_updater_new</NAME>
<RETURNS>HTMLEngineEditSelectionUpdater  *</RETURNS>
HTMLEngine                     *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_edit_selection_updater_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLEngineEditSelectionUpdater *updater
</FUNCTION>
<FUNCTION>
<NAME>html_engine_edit_selection_updater_reset</NAME>
<RETURNS>void  </RETURNS>
HTMLEngineEditSelectionUpdater *updater
</FUNCTION>
<FUNCTION>
<NAME>html_engine_edit_selection_updater_schedule</NAME>
<RETURNS>void  </RETURNS>
HTMLEngineEditSelectionUpdater *updater
</FUNCTION>
<FUNCTION>
<NAME>html_engine_edit_selection_updater_update_now</NAME>
<RETURNS>void  </RETURNS>
HTMLEngineEditSelectionUpdater *updater
</FUNCTION>
<FUNCTION>
<NAME>html_engine_create_table</NAME>
<RETURNS>HTMLObject  *</RETURNS>
HTMLEngine *e,gint width,gint percent,gint padding,gint spacing,gint border
</FUNCTION>
<FUNCTION>
<NAME>html_engine_insert_table</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e, gint *values
</FUNCTION>
<FUNCTION>
<NAME>html_engine_insert_table_cell</NAME>
<RETURNS>HTMLObject  *</RETURNS>
HTMLEngine *e,gint percent,gint rs,gint cs,gint pad,gint width,HTMLImagePointer *imagePtr
</FUNCTION>
<FUNCTION>
<NAME>html_engine_capitalize_word</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine       *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_upcase_downcase_word</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine       *e,gboolean          up
</FUNCTION>
<FUNCTION>
<NAME>html_engine_undo</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_redo</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_set_mark</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_select_word_editable</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_select_line_editable</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_clipboard_push</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_clipboard_pop</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_clipboard_clear</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_selection_push</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_selection_pop</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_cut_and_paste_begin</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e,gchar                     *op_name
</FUNCTION>
<FUNCTION>
<NAME>html_engine_cut_and_paste_end</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_cut_and_paste</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e,gchar                     *op_name,HTMLObjectForallFunc       iterator,gpointer                   data
</FUNCTION>
<FUNCTION>
<NAME>html_engine_spell_check_range</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e,HTMLCursor                *begin,HTMLCursor                *end
</FUNCTION>
<FUNCTION>
<NAME>html_engine_set_data_by_type</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e,HTMLType                   object_type,const gchar               *key,const gpointer             value
</FUNCTION>
<FUNCTION>
<NAME>html_engine_ensure_editable</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_new_text</NAME>
<RETURNS>HTMLObject                 *</RETURNS>
HTMLEngine                *e,const gchar               *text,gint                       len
</FUNCTION>
<FUNCTION>
<NAME>html_engine_new_text_empty</NAME>
<RETURNS>HTMLObject                 *</RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_cursor_on_bop</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_indent</NAME>
<RETURNS>guint  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_indent_pre_paragraph</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine                *e
</FUNCTION>
<FUNCTION>
<NAME>html_is_in_word</NAME>
<RETURNS>gboolean  </RETURNS>
unicode_char_t             uc
</FUNCTION>
<FUNCTION>
<NAME>paragraph_alignment_to_html</NAME>
<RETURNS>HTMLHAlignType  </RETURNS>
GtkHTMLParagraphAlignment  alignment
</FUNCTION>
<FUNCTION>
<NAME>paragraph_style_to_clueflow_style</NAME>
<RETURNS>HTMLClueFlowStyle  </RETURNS>
GtkHTMLParagraphStyle      style
</FUNCTION>
<FUNCTION>
<NAME>html_alignment_to_paragraph</NAME>
<RETURNS>GtkHTMLParagraphAlignment  </RETURNS>
HTMLHAlignType             alignment
</FUNCTION>
<FUNCTION>
<NAME>clueflow_style_to_paragraph_style</NAME>
<RETURNS>GtkHTMLParagraphStyle  </RETURNS>
HTMLClueFlowStyle          style
</FUNCTION>
<FUNCTION>
<NAME>html_engine_print</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine           *e,GnomePrintContext    *print_context
</FUNCTION>
<FUNCTION>
<NAME>html_engine_print_with_header_footer</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine           *e,GnomePrintContext    *print_context,gdouble               header_height,gdouble               footer_height,GtkHTMLPrintCallback  header_print,GtkHTMLPrintCallback  footer_print,gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>html_engine_print_set_min_split_index</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine           *e,gdouble               idx
</FUNCTION>
<STRUCT>
<NAME>HTMLEngineSaveState</NAME>
struct HTMLEngineSaveState {
	HTMLEngine *engine;
	HTMLEngineSaveReceiverFn receiver;
	guint br_count;

	guint error : 1;

	guint last_level;

	gpointer user_data;
};
</STRUCT>
<FUNCTION>
<NAME>html_engine_save_encode</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngineSaveState       *state,const gchar               *buffer,guint                      length
</FUNCTION>
<FUNCTION>
<NAME>html_engine_save_encode_string</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngineSaveState       *state,const gchar               *s
</FUNCTION>
<FUNCTION>
<NAME>html_engine_save_output_string</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngineSaveState       *state,const gchar               *format,...
</FUNCTION>
<FUNCTION>
<NAME>html_engine_save</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine          *engine,HTMLEngineSaveReceiverFn   receiver,gpointer                   user_data
</FUNCTION>
<FUNCTION>
<NAME>html_engine_save_plain</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine          *engine,HTMLEngineSaveReceiverFn   receiver,gpointer                   user_data
</FUNCTION>
<FUNCTION>
<NAME>html_engine_save_buffer_free</NAME>
<RETURNS>void  </RETURNS>
HTMLEngineSaveState       *state
</FUNCTION>
<FUNCTION>
<NAME>html_engine_save_buffer_peek_text</NAME>
<RETURNS>guchar               *</RETURNS>
HTMLEngineSaveState       *state
</FUNCTION>
<FUNCTION>
<NAME>html_engine_save_buffer_new</NAME>
<RETURNS>HTMLEngineSaveState  *</RETURNS>
HTMLEngine                *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_save_get_sample_body</NAME>
<RETURNS>gchar                *</RETURNS>
HTMLEngine                *e,HTMLObject                *o
</FUNCTION>
<FUNCTION>
<NAME>html_engine_save_get_paragraph_align</NAME>
<RETURNS>const gchar          *</RETURNS>
GtkHTMLParagraphAlignment  align
</FUNCTION>
<FUNCTION>
<NAME>html_engine_save_get_paragraph_style</NAME>
<RETURNS>const gchar          *</RETURNS>
GtkHTMLParagraphStyle      style
</FUNCTION>
<FUNCTION>
<NAME>html_engine_search</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine *e,const gchar *text,gboolean case_sensitive,gboolean forward,gboolean regular
</FUNCTION>
<FUNCTION>
<NAME>html_engine_search_next</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_search_incremental</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine *e,const gchar *text,gboolean forward
</FUNCTION>
<MACRO>
<NAME>HTML_TYPE_ENGINE</NAME>
#define HTML_TYPE_ENGINE                 (html_engine_get_type ())
</MACRO>
<MACRO>
<NAME>HTML_ENGINE</NAME>
#define HTML_ENGINE(obj)                 (GTK_CHECK_CAST ((obj), HTML_TYPE_ENGINE, HTMLEngine))
</MACRO>
<MACRO>
<NAME>HTML_ENGINE_CLASS</NAME>
#define HTML_ENGINE_CLASS(klass)         (GTK_CHECK_CLASS_CAST ((klass), HTML_TYPE_ENGINE, HTMLEngineClass))
</MACRO>
<MACRO>
<NAME>HTML_IS_ENGINE</NAME>
#define HTML_IS_ENGINE(obj)              (GTK_CHECK_TYPE ((obj), HTML_TYPE_ENGINE))
</MACRO>
<MACRO>
<NAME>HTML_IS_ENGINE_CLASS</NAME>
#define HTML_IS_ENGINE_CLASS(klass)      (GTK_CHECK_CLASS_TYPE ((klass), HTML_TYPE_ENGINE))
</MACRO>
<MACRO>
<NAME>LEFT_BORDER</NAME>
#define LEFT_BORDER 10
</MACRO>
<MACRO>
<NAME>RIGHT_BORDER</NAME>
#define RIGHT_BORDER 10
</MACRO>
<MACRO>
<NAME>TOP_BORDER</NAME>
#define TOP_BORDER 10
</MACRO>
<MACRO>
<NAME>BOTTOM_BORDER</NAME>
#define BOTTOM_BORDER 10
</MACRO>
<STRUCT>
<NAME>HTMLEngine</NAME>
struct HTMLEngine {
	GtkObject parent;
	HTMLDrawQueue *draw_queue;

	HTMLPainter *painter;

	HTMLSettings *settings;
	HTMLSettings *defaultSettings;

	HTMLUndo *undo;

	GdkWindow *window;
	GdkGC *invert_gc;

	gboolean editable;

	HTMLObject *clipboard;
	guint       clipboard_len;
	GList      *clipboard_stack;

	/* Freeze counter.  When greater than zero, we never trigger relayouts
           nor repaints.  When going from nonzero to zero, we relayout and
           repaint everything.  */
	guint freeze_count;
	guint thaw_idle_id;

	gboolean parsing;
	HTMLTokenizer *ht;
	HTMLStringTokenizer *st;
	HTMLObject *clue;
	
	HTMLObject *flow;

	gint leftBorder;
	gint rightBorder;
	gint topBorder;
	gint bottomBorder;

	/* Current indentation level.  */
	guint indent_level;

	/* For the widget */
	gint width;
	gint height;

	HTMLHAlignType divAlign;

	/* Number of tokens parsed in the current time-slice */
	gint parseCount;
	gint granularity;

	/* Offsets */
	gint x_offset, y_offset;

	gboolean inTitle;
	gboolean inPre;
	gboolean inOption;
	gboolean inTextArea;
	gboolean eat_space;

	gboolean newPage;
 
	HTMLStack *font_style_stack; /* Font style stack, elements are GtkHTMLFontStyles.  */
	HTMLStack *font_face_stack;
	HTMLStack *color_stack;	/* Color stack, elements are GdkColors.  */
	HTMLStack *clueflow_style_stack; /* Clueflow style stack, elements are HTMLClueFlowStyles.  */

	gchar *url;
	gchar *target;

	HTMLBlockStackElement *blockStack;

	/* timer id to schedule paint events */
	guint updateTimer;

	/* timer id for parsing routine */
	guint timerId;

	/* FIXME: replace with a `gchar *'?  */
	GString *title;

	gboolean writing;

	/* The background pixmap, an HTMLImagePointer */
        gpointer bgPixmapPtr;
  
	/* Stack of lists currently active */
	HTMLStack *listStack;

	/* Stack of embedded "object"'s */
	HTMLStack *embeddedStack;

	/* The associated widget.  */
	GtkHTML *widget;

        gpointer image_factory;

	HTMLStack *glossaryStack; /* HTMLGlossaryEntry */

	/*
	 * This list holds strings which are displayed in the view,
	 * but are not actually contained in the HTML source.
	 * e.g. The numbers in an ordered list.
	 * FIXME?
	 */
	GList *tempStrings;

	HTMLForm *form;
	HTMLSelect *formSelect;
	HTMLTextArea *formTextArea;
	GList *formList;
	GString *formText;
	gboolean noWrap;

	/* This is TRUE if we cannot insert a paragraph break (which is just an
           extra empty line).  It's set to FALSE as soon as some element is
           added to a flow.  The purpose is to avoid having paragraph breaks to
           be inserted in sequence, or after elements that have some vspace of
           their own.  */
	gboolean avoid_para;

	/* This is TRUE if we want a paragraph break to be inserted before the
           next element.  */
	gboolean pending_para;

	/* Alignment for the pending paragraph we are going to insert.  */
	HTMLHAlignType pending_para_alignment;

	/* Whether we have the keyboard focus.  */
	guint have_focus : 1;

	HTMLInterval *selection;
	gboolean selected_in;

	/* --- */

	/* Editing stuff.  -- FIXME it should be in a separate object.  */

	/* The current position of the cursor.  */
	HTMLCursor *cursor;

	/* If no region is active, this is NULL.  Otherwise, this is
           one extreme of the selected region.  The other extreme is
           always the cursor.  */
	HTMLCursor *mark;

	/* Hide counter for the cursor.  When greater than zero, it
           means the cursor is invisible.  */
	gint cursor_hide_count;

	/* Timer ID for cursor blink.  */
	gint blinking_timer_id;

	/* Blinking status (visible/invisible).  */
	gboolean blinking_status;

	/* Font style for insertion.  If HTML_FONT_STYLE_DEFAULT, use that of
           the text we are in.  */
	GtkHTMLFontStyle  insertion_font_style;
	HTMLColor        *insertion_color;
	gchar            *insertion_url;
	gchar            *insertion_target;

	/* if we are doing shift selection - Shift + some event (arrows, mouse motion, ...) */
	gboolean shift_selection;

	/* This object is used to update the keyboard selection in the
           idle loop.  */
	HTMLEngineEditSelectionUpdater *selection_updater;

	/* keeps selection between operation, which are changing selection
	   and need restore it after done */
	GList *selection_stack;

	/* search & replace */
	HTMLSearch  *search_info;
	HTMLReplace *replace_info;

	/* id-to-object mapping */
	GHashTable *id_table;

	gdouble min_split_index;

	gboolean need_spell_check;
};
</STRUCT>
<FUNCTION>
<NAME>html_engine_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_engine_new</NAME>
<RETURNS>HTMLEngine  *</RETURNS>
GtkWidget *
</FUNCTION>
<FUNCTION>
<NAME>html_engine_realize</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine,GdkWindow  *window
</FUNCTION>
<FUNCTION>
<NAME>html_engine_unrealize</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_set_editable</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e,gboolean    editable
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_editable</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_set_focus</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine,gboolean    have_focus
</FUNCTION>
<FUNCTION>
<NAME>html_engine_begin</NAME>
<RETURNS>GtkHTMLStream  *</RETURNS>
HTMLEngine  *p,char        *content_type
</FUNCTION>
<FUNCTION>
<NAME>html_engine_parse</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *p
</FUNCTION>
<FUNCTION>
<NAME>html_engine_stop_parser</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_calc_size</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *p
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_doc_height</NAME>
<RETURNS>gint  </RETURNS>
HTMLEngine *p
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_doc_width</NAME>
<RETURNS>gint  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_draw</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e,gint        x,gint        y,gint        width,gint        height
</FUNCTION>
<FUNCTION>
<NAME>html_engine_draw_background</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e,gint        x,gint        y,gint        width,gint        height
</FUNCTION>
<FUNCTION>
<NAME>html_engine_schedule_update</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *p
</FUNCTION>
<FUNCTION>
<NAME>html_engine_make_cursor_visible</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_goto_anchor</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine  *e,const gchar *anchor
</FUNCTION>
<FUNCTION>
<NAME>html_engine_flush_draw_queue</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_queue_draw</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e,HTMLObject *o
</FUNCTION>
<FUNCTION>
<NAME>html_engine_queue_clear</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e,gint        x,gint        y,guint       width,guint       height
</FUNCTION>
<FUNCTION>
<NAME>html_engine_set_painter</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e,HTMLPainter *painter,gint max_width
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_object_at</NAME>
<RETURNS>HTMLObject   *</RETURNS>
HTMLEngine *e,gint        x,gint        y,guint      *offset_return,gboolean    for_cursor
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_point_at</NAME>
<RETURNS>HTMLPoint    *</RETURNS>
HTMLEngine *e,gint        x,gint        y,gboolean    for_cursor
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_link_at</NAME>
<RETURNS>const gchar  *</RETURNS>
HTMLEngine *e,gint        x,gint        y
</FUNCTION>
<FUNCTION>
<NAME>html_engine_form_submitted</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *engine,const gchar *method,const gchar *action,const gchar *encoding
</FUNCTION>
<FUNCTION>
<NAME>html_engine_canonicalize_url</NAME>
<RETURNS>gchar  *</RETURNS>
HTMLEngine *e,const char *in_url
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_cursor</NAME>
<RETURNS>HTMLCursor  *</RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_normalize_cursor</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_frozen</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_freeze</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_thaw</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_load_empty</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>html_engine_replace</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e,const gchar *text,const gchar *rep_text,gboolean case_sensitive,gboolean forward,gboolean regular,void (*ask)(HTMLEngine *, gpointer), gpointer ask_data
</FUNCTION>
<FUNCTION>
<NAME>html_engine_replace_do</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e, HTMLReplaceQueryAnswer answer
</FUNCTION>
<FUNCTION>
<NAME>html_engine_replaced</NAME>
<RETURNS>gint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_engine_init_magic_links</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_engine_spell_check</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_word</NAME>
<RETURNS>gchar     *</RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_word_is_valid</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_replace_word_with</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e,const gchar *word
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_view_width</NAME>
<RETURNS>gint  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_view_height</NAME>
<RETURNS>gint  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_add_object_with_id</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e,const gchar *id,HTMLObject  *obj
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_object_by_id</NAME>
<RETURNS>HTMLObject  *</RETURNS>
HTMLEngine  *e,const gchar *id
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_top_html_engine</NAME>
<RETURNS>HTMLEngine  *</RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_thaw_idle_reset</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e
</FUNCTION>
<MACRO>
<NAME>ENTITY_NBSP</NAME>
#define ENTITY_NBSP 160
</MACRO>
<FUNCTION>
<NAME>html_entity_parse</NAME>
<RETURNS>gulong  </RETURNS>
const gchar *s, guint len
</FUNCTION>
<FUNCTION>
<NAME>html_entity_prepare</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *s
</FUNCTION>
<ENUM>
<NAME>HTMLButtonType</NAME>
typedef enum {
	BUTTON_NORMAL,
	BUTTON_SUBMIT,
	BUTTON_RESET
} HTMLButtonType;
</ENUM>
<ENUM>
<NAME>HTMLChangeFlags</NAME>
typedef enum {
	HTML_CHANGE_NONE = 0,
	HTML_CHANGE_MIN_WIDTH = 1 << 0,
	HTML_CHANGE_PREF_WIDTH = 1 << 1,
	HTML_CHANGE_ALL = ((HTML_CHANGE_PREF_WIDTH << 1) - 1)
} HTMLChangeFlags;
</ENUM>
<ENUM>
<NAME>HTMLClearType</NAME>
typedef enum {
	HTML_CLEAR_NONE,
	HTML_CLEAR_LEFT,
	HTML_CLEAR_RIGHT,
	HTML_CLEAR_ALL
} HTMLClearType;
</ENUM>
<ENUM>
<NAME>HTMLClueFlowStyle</NAME>
typedef enum {
	HTML_CLUEFLOW_STYLE_NORMAL,
	HTML_CLUEFLOW_STYLE_H1,
	HTML_CLUEFLOW_STYLE_H2,
	HTML_CLUEFLOW_STYLE_H3,
	HTML_CLUEFLOW_STYLE_H4,
	HTML_CLUEFLOW_STYLE_H5,
	HTML_CLUEFLOW_STYLE_H6,
	HTML_CLUEFLOW_STYLE_ADDRESS,
	HTML_CLUEFLOW_STYLE_PRE,
	HTML_CLUEFLOW_STYLE_ITEMDOTTED,
	HTML_CLUEFLOW_STYLE_ITEMROMAN,
	HTML_CLUEFLOW_STYLE_ITEMDIGIT,
	HTML_CLUEFLOW_STYLE_NOWRAP,
	HTML_CLUEFLOW_NUMSTYLES
} HTMLClueFlowStyle;
</ENUM>
<ENUM>
<NAME>HTMLColorId</NAME>
typedef enum {
	HTMLBgColor = 0,
	HTMLTextColor,
	HTMLLinkColor,
	HTMLVLinkColor,
	HTMLALinkColor,
	HTMLHighlightColor,
	HTMLHighlightTextColor,
	HTMLSpellErrorColor,

	HTMLColors
} HTMLColorId;
</ENUM>
<ENUM>
<NAME>HTMLEngineCursorMovement</NAME>
typedef enum {
	HTML_ENGINE_CURSOR_UP,
	HTML_ENGINE_CURSOR_DOWN,
	HTML_ENGINE_CURSOR_RIGHT,
	HTML_ENGINE_CURSOR_LEFT,
	HTML_ENGINE_CURSOR_HOME,
	HTML_ENGINE_CURSOR_END,
	HTML_ENGINE_CURSOR_PGUP,
	HTML_ENGINE_CURSOR_PGDOWN
} HTMLEngineCursorMovement;
</ENUM>
<ENUM>
<NAME>HTMLEngineSetClueFlowStyleMask</NAME>
typedef enum {
	HTML_ENGINE_SET_CLUEFLOW_NONE = 0,
	HTML_ENGINE_SET_CLUEFLOW_STYLE = 1 << 0,
	HTML_ENGINE_SET_CLUEFLOW_ALIGNMENT = 1 << 1,
	HTML_ENGINE_SET_CLUEFLOW_INDENTATION = 1 << 2,
	HTML_ENGINE_SET_CLUEFLOW_INDENTATION_DELTA = 1 << 3
} HTMLEngineSetClueFlowStyleMask;
</ENUM>
<ENUM>
<NAME>HTMLFitType</NAME>
typedef enum {
	HTML_FIT_NONE,
	HTML_FIT_PARTIAL,
	HTML_FIT_COMPLETE
} HTMLFitType;
</ENUM>
<ENUM>
<NAME>HTMLGlossaryEntry</NAME>
typedef enum {
	HTML_GLOSSARY_DL = 1,
	HTML_GLOSSARY_DD = 2
} HTMLGlossaryEntry;
</ENUM>
<ENUM>
<NAME>HTMLHAlignType</NAME>
typedef enum {
	HTML_HALIGN_LEFT,
	HTML_HALIGN_CENTER,
	HTML_HALIGN_RIGHT,
	HTML_HALIGN_NONE
} HTMLHAlignType;
</ENUM>
<ENUM>
<NAME>HTMLListNumType</NAME>
typedef enum {
	HTML_LIST_NUM_TYPE_NUMERIC,
	HTML_LIST_NUM_TYPE_LOWALPHA,
	HTML_LIST_NUM_TYPE_UPALPHA,
	HTML_LIST_NUM_TYPE_LOWROMAN,
	HTML_LIST_NUM_TYPE_UPROMAN
} HTMLListNumType;
</ENUM>
<ENUM>
<NAME>HTMLListType</NAME>
typedef enum {
	HTML_LIST_TYPE_UNORDERED,
	HTML_LIST_TYPE_UNORDEREDPLAIN,
	HTML_LIST_TYPE_ORDERED,
	HTML_LIST_TYPE_MENU,
	HTML_LIST_TYPE_DIR
} HTMLListType;
</ENUM>
<ENUM>
<NAME>HTMLObjectFlags</NAME>
typedef enum {
	HTML_OBJECT_FLAG_NONE = 0,
	HTML_OBJECT_FLAG_SEPARATOR = 1 << 0,
	HTML_OBJECT_FLAG_NEWLINE = 1 << 1,
	HTML_OBJECT_FLAG_SELECTED = 1 << 2,
	HTML_OBJECT_FLAG_ALLSELECTED = 1 << 3,
	HTML_OBJECT_FLAG_FIXEDWIDTH = 1 << 4,
	HTML_OBJECT_FLAG_ALIGNED = 1 << 5,
	HTML_OBJECT_FLAG_PRINTED = 1 << 6,
	HTML_OBJECT_FLAG_HIDDEN = 1 << 7
} HTMLObjectFlags;
</ENUM>
<ENUM>
<NAME>HTMLReplaceQueryAnswer</NAME>
typedef enum {
	RQA_Replace,
	RQA_ReplaceAll,
	RQA_Next,
	RQA_Cancel
} HTMLReplaceQueryAnswer;
</ENUM>
<ENUM>
<NAME>HTMLType</NAME>
typedef enum {
	HTML_TYPE_NONE,
	HTML_TYPE_ANCHOR,
	HTML_TYPE_BULLET,
	HTML_TYPE_BUTTON,
	HTML_TYPE_CHECKBOX,
	HTML_TYPE_CLUE,
	HTML_TYPE_CLUEALIGNED,
	HTML_TYPE_CLUEFLOW,
	HTML_TYPE_CLUEH,
	HTML_TYPE_CLUEV,
	HTML_TYPE_EMBEDDED,
	HTML_TYPE_HIDDEN,
	HTML_TYPE_HSPACE,
	HTML_TYPE_IMAGE,
	HTML_TYPE_IMAGEINPUT,
	HTML_TYPE_LINKTEXT,
	HTML_TYPE_OBJECT,
	HTML_TYPE_RADIO,
	HTML_TYPE_RULE,
	HTML_TYPE_SELECT,
	HTML_TYPE_TABLE,
	HTML_TYPE_TABLECELL,
	HTML_TYPE_TEXT,
	HTML_TYPE_TEXTAREA,
	HTML_TYPE_TEXTINPUT,
	HTML_TYPE_TEXTSLAVE,
	HTML_TYPE_VSPACE,
	HTML_TYPE_IFRAME,
	HTML_NUM_TYPES
} HTMLType;
</ENUM>
<ENUM>
<NAME>HTMLUndoDirection</NAME>
typedef enum {
	HTML_UNDO_UNDO,
	HTML_UNDO_REDO
} HTMLUndoDirection;
</ENUM>
<ENUM>
<NAME>HTMLURLDupFlags</NAME>
typedef enum {
	HTML_URL_DUP_ALL = 0,
	HTML_URL_DUP_NOPROTOCOL = 1 << 0,
	HTML_URL_DUP_NOUSERNAME = 1 << 1,
	HTML_URL_DUP_NOPASSWORD = 1 << 2,
	HTML_URL_DUP_NOHOSTNAME = 1 << 3,
	HTML_URL_DUP_NOPORT = 1 << 4,
	HTML_URL_DUP_NOPATH = 1 << 5,
	HTML_URL_DUP_NOREFERENCE = 1 << 6,
	HTML_URL_DUP_NOCGIARGS = 1 << 7
} HTMLURLDupFlags;
</ENUM>
<ENUM>
<NAME>HTMLVAlignType</NAME>
typedef enum {
	HTML_VALIGN_TOP,
	HTML_VALIGN_CENTER,
	HTML_VALIGN_BOTTOM,
	HTML_VALIGN_NONE
} HTMLVAlignType;
</ENUM>
<FUNCTION>
<NAME>html_valign_name</NAME>
<RETURNS>const gchar  *</RETURNS>
HTMLVAlignType valign
</FUNCTION>
<FUNCTION>
<NAME>html_halign_name</NAME>
<RETURNS>const gchar  *</RETURNS>
HTMLHAlignType halign
</FUNCTION>
<MACRO>
<NAME>GTK_HTML_GCONF_DIR</NAME>
#define GTK_HTML_GCONF_DIR "/GNOME/Documents/HTML_Editor"
</MACRO>
<MACRO>
<NAME>GTK_HTML_GNOME_CONFIG_PREFIX</NAME>
#define GTK_HTML_GNOME_CONFIG_PREFIX "/gtkhtml/Settings/"
</MACRO>
<MACRO>
<NAME>GTK_HTML_PROPERTY</NAME>
#define GTK_HTML_PROPERTY(w,p)         (GTK_HTML_CLASS (GTK_OBJECT (w)->klass)->properties-> ## p)
</MACRO>
<FUNCTION>
<NAME>gtk_html_class_properties_new</NAME>
<RETURNS>GtkHTMLClassProperties  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_class_properties_destroy</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLClassProperties *p
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_class_properties_copy</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLClassProperties *p1,GtkHTMLClassProperties *p2
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_class_properties_load</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLClassProperties *p,GConfClient *client
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_class_properties_update</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLClassProperties *p,GConfClient *client,GtkHTMLClassProperties *old
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_class_properties_load</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLClassProperties *p
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_class_properties_save</NAME>
<RETURNS>void  </RETURNS>
GtkHTMLClassProperties *p
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_HTML_CURSOR_SKIP</NAME>
#define GTK_TYPE_HTML_CURSOR_SKIP     (gtk_html_cursor_skip_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_TYPE_HTML_COMMAND</NAME>
#define GTK_TYPE_HTML_COMMAND         (gtk_html_command_get_type ())
</MACRO>
<FUNCTION>
<NAME>gtk_html_cursor_skip_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_html_command_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>HTML_FONT_MANAGER</NAME>
#define HTML_FONT_MANAGER(x) ((HTMLFontManager *)x)
</MACRO>
<STRUCT>
<NAME>HTMLFont</NAME>
struct HTMLFont {
	gpointer data;
	guint    space_width;
	gint     ref_count;
};
</STRUCT>
<STRUCT>
<NAME>HTMLFontSet</NAME>
struct HTMLFontSet {
	HTMLFont *font [GTK_HTML_FONT_STYLE_MAX_FONT];
	gint      ref_count;
	gchar    *face;
};
</STRUCT>
<STRUCT>
<NAME>HTMLFontManager</NAME>
struct HTMLFontManager {
	HTMLPainter *painter;

	GHashTable *font_sets;
	HTMLFontSet variable;
	HTMLFontSet fixed;

	gint var_size;
	gint fix_size;
};
</STRUCT>
<FUNCTION>
<NAME>html_font_manager_init</NAME>
<RETURNS>void  </RETURNS>
HTMLFontManager *manager,HTMLPainter *painter
</FUNCTION>
<FUNCTION>
<NAME>html_font_manager_finalize</NAME>
<RETURNS>void  </RETURNS>
HTMLFontManager *manager
</FUNCTION>
<FUNCTION>
<NAME>html_font_manager_set_default</NAME>
<RETURNS>void  </RETURNS>
HTMLFontManager *manager,gchar *variable,gchar *fixed,gint var_size,gint fix_size
</FUNCTION>
<FUNCTION>
<NAME>html_font_manager_get_font</NAME>
<RETURNS>HTMLFont            *</RETURNS>
HTMLFontManager *manager,gchar *face,GtkHTMLFontStyle style
</FUNCTION>
<FUNCTION>
<NAME>html_font_new</NAME>
<RETURNS>HTMLFont  *</RETURNS>
gpointer     data,guint        space_width
</FUNCTION>
<FUNCTION>
<NAME>html_font_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLFont    *font
</FUNCTION>
<FUNCTION>
<NAME>html_font_ref</NAME>
<RETURNS>void  </RETURNS>
HTMLFont    *font,HTMLPainter *painter
</FUNCTION>
<FUNCTION>
<NAME>html_font_unref</NAME>
<RETURNS>void  </RETURNS>
HTMLFont    *font,HTMLPainter *painter
</FUNCTION>
<MACRO>
<NAME>HTML_FORM</NAME>
#define HTML_FORM(x) ((HTMLForm *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLForm</NAME>
struct HTMLForm {

	gchar *action;
	gchar *method;
	GList *elements;
	GList *hidden;

	/* Used by radio buttons */
	GSList *radio_group;

	HTMLEngine *engine;
};
</STRUCT>
<FUNCTION>
<NAME>html_form_new</NAME>
<RETURNS>HTMLForm  *</RETURNS>
HTMLEngine *engine, gchar *_action, gchar *_method
</FUNCTION>
<FUNCTION>
<NAME>html_form_add_element</NAME>
<RETURNS>void  </RETURNS>
HTMLForm *form, HTMLEmbedded *e
</FUNCTION>
<FUNCTION>
<NAME>html_form_add_hidden</NAME>
<RETURNS>void  </RETURNS>
HTMLForm *form, HTMLHidden *h
</FUNCTION>
<FUNCTION>
<NAME>html_form_remove_element</NAME>
<RETURNS>void  </RETURNS>
HTMLForm *form, HTMLEmbedded *e
</FUNCTION>
<FUNCTION>
<NAME>html_form_submit</NAME>
<RETURNS>void  </RETURNS>
HTMLForm *form
</FUNCTION>
<FUNCTION>
<NAME>html_form_reset</NAME>
<RETURNS>void  </RETURNS>
HTMLForm *form
</FUNCTION>
<FUNCTION>
<NAME>html_form_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLForm *form
</FUNCTION>
<MACRO>
<NAME>HTML_TYPE_GDK_PAINTER</NAME>
#define HTML_TYPE_GDK_PAINTER                 (html_gdk_painter_get_type ())
</MACRO>
<MACRO>
<NAME>HTML_GDK_PAINTER</NAME>
#define HTML_GDK_PAINTER(obj)                 (GTK_CHECK_CAST ((obj), HTML_TYPE_GDK_PAINTER, HTMLGdkPainter))
</MACRO>
<MACRO>
<NAME>HTML_GDK_PAINTER_CLASS</NAME>
#define HTML_GDK_PAINTER_CLASS(klass)         (GTK_CHECK_CLASS_CAST ((klass), HTML_TYPE_GDK_PAINTER, HTMLGdkPainterClass))
</MACRO>
<MACRO>
<NAME>HTML_IS_GDK_PAINTER</NAME>
#define HTML_IS_GDK_PAINTER(obj)              (GTK_CHECK_TYPE ((obj), HTML_TYPE_GDK_PAINTER))
</MACRO>
<MACRO>
<NAME>HTML_IS_GDK_PAINTER_CLASS</NAME>
#define HTML_IS_GDK_PAINTER_CLASS(klass)      (GTK_CHECK_CLASS_TYPE ((klass), HTML_TYPE_GDK_PAINTER))
</MACRO>
<STRUCT>
<NAME>HTMLGdkPainter</NAME>
struct HTMLGdkPainter {
	HTMLPainter base;

	/* GdkWindow to draw on */
	GdkWindow *window;

	/* The current GC used.  */
	GdkGC *gc;

	/* For the double-buffering system.  */
	gboolean double_buffer;
	GdkPixmap *pixmap;
	gint x1, y1, x2, y2;
	GdkColor background;
	gboolean set_background;
	gboolean do_clear;
	gboolean alpha;

	/* Colors used for shading.  */
	GdkColor dark;
	GdkColor light;
	GdkColor black;
};
</STRUCT>
<FUNCTION>
<NAME>html_gdk_painter_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_gdk_painter_new</NAME>
<RETURNS>HTMLPainter  *</RETURNS>
gboolean        double_buffer
</FUNCTION>
<FUNCTION>
<NAME>html_gdk_painter_realize</NAME>
<RETURNS>void  </RETURNS>
HTMLGdkPainter *painter,GdkWindow      *window
</FUNCTION>
<FUNCTION>
<NAME>html_gdk_painter_unrealize</NAME>
<RETURNS>void  </RETURNS>
HTMLGdkPainter *painter
</FUNCTION>
<FUNCTION>
<NAME>html_gdk_painter_realized</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLGdkPainter *painter
</FUNCTION>
<MACRO>
<NAME>HTML_HIDDEN</NAME>
#define HTML_HIDDEN(x) ((HTMLHidden *) (x))
</MACRO>
<MACRO>
<NAME>HTML_HIDDEN_CLASS</NAME>
#define HTML_HIDDEN_CLASS(x) ((HTMLHiddenClass *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLHidden</NAME>
struct HTMLHidden {
	HTMLEmbedded element;
};
</STRUCT>
<VARIABLE>
<NAME>html_hidden_class</NAME>
extern HTMLHiddenClass html_hidden_class;
</VARIABLE>
<FUNCTION>
<NAME>html_hidden_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_hidden_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLHiddenClass *klass,HTMLType         type,guint            object_size
</FUNCTION>
<FUNCTION>
<NAME>html_hidden_init</NAME>
<RETURNS>void  </RETURNS>
HTMLHidden      *hidden,HTMLHiddenClass *klass,gchar           *name,gchar           *value
</FUNCTION>
<FUNCTION>
<NAME>html_hidden_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
gchar           *name,gchar           *value
</FUNCTION>
<MACRO>
<NAME>HTML_HSPACE</NAME>
#define HTML_HSPACE(x) ((HTMLHSpace *)(x))
</MACRO>
<MACRO>
<NAME>HTML_HSPACE_CLASS</NAME>
#define HTML_HSPACE_CLASS(x) ((HTMLHSpaceClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLHSpace</NAME>
struct HTMLHSpace {
	HTMLObject object;

	/* FIXME!!!  WHY!?!?!?  Shouldn't we use the one from HTMLObject???  */
	HTMLFont *font;
};
</STRUCT>
<VARIABLE>
<NAME>html_hspace_class</NAME>
extern HTMLHSpaceClass html_hspace_class;
</VARIABLE>
<FUNCTION>
<NAME>html_hspace_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_hspace_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLHSpaceClass *klass,HTMLType         type,guint            object_size
</FUNCTION>
<FUNCTION>
<NAME>html_hspace_init</NAME>
<RETURNS>void  </RETURNS>
HTMLHSpace      *hspace,HTMLHSpaceClass *klass,HTMLFont        *font,gboolean         hidden
</FUNCTION>
<FUNCTION>
<NAME>html_hspace_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
HTMLFont        *font,gboolean         hidden
</FUNCTION>
<MACRO>
<NAME>HTML_IFRAME</NAME>
#define HTML_IFRAME(x) ((HTMLIFrame *)(x))
</MACRO>
<MACRO>
<NAME>HTML_IFRAME_CLASS</NAME>
#define HTML_IFRAME_CLASS(x) ((HTMLIFrameClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLIFrame</NAME>
struct HTMLIFrame {
	HTMLEmbedded embedded;
	
	char *url;
	GtkWidget *scroll;
	GtkWidget *html;
	HTMLPainter *gdk_painter;
	gint width;
	gint height;
	gboolean frameborder;
};
</STRUCT>
<FUNCTION>
<NAME>html_iframe_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_iframe_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLIFrameClass *klass,HTMLType           type,guint              object_size
</FUNCTION>
<FUNCTION>
<NAME>html_iframe_init</NAME>
<RETURNS>void  </RETURNS>
HTMLIFrame        *iframe,HTMLIFrameClass   *klass,GtkWidget         *parent,char              *url,gint               width,gint               height,gboolean           border
</FUNCTION>
<FUNCTION>
<NAME>html_iframe_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
GtkWidget *parent,char *src,gint width,gint height,gboolean border
</FUNCTION>
<STRUCT>
<NAME>HTMLImagePointer</NAME>
struct HTMLImagePointer {
	gint refcount;
	gchar *url;
	GdkPixbufLoader *loader;
	GdkPixbuf *pixbuf;
	GdkPixbufAnimation *animation;
	GSList *interests; /* A list of HTMLImage's, or a NULL pointer for the background pixmap */
	HTMLImageFactory *factory;
	gint stall;
	guint stall_timeout;
};
</STRUCT>
<STRUCT>
<NAME>HTMLImageAnimation</NAME>
struct HTMLImageAnimation {
	/* stuff for animated image */
	/* draw coordination */
	gint x;
	gint y;

	/* remember engine offset */
	gint ex, ey;

	/* current frame */
	GList *cur_frame;
	gint cur_n;

	/* animation timeout function */
	gint timeout;

	/* helper buffer */
	GdkPixbuf *pixbuf;

	/* active draw flag */
	gint active;
};
</STRUCT>
<MACRO>
<NAME>HTML_IMAGE</NAME>
#define HTML_IMAGE(x) ((HTMLImage *)(x))
</MACRO>
<MACRO>
<NAME>HTML_IMAGE_POINTER</NAME>
#define HTML_IMAGE_POINTER(x) ((HTMLImagePointer *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLImage</NAME>
struct HTMLImage {
	HTMLObject object;
        HTMLImagePointer *image_ptr;
	HTMLImageAnimation *animation;

	HTMLColor *color;

	guint have_color: 1;

	gint8 border;

	gint16 specified_width;
	gint16 specified_height;
	gboolean percent_width;
	gboolean percent_height;

	gint8 hspace;
	gint8 vspace;

	HTMLVAlignType valign;

	gchar *url;
	gchar *target;
	gchar *alt;	
};
</STRUCT>
<VARIABLE>
<NAME>image_class</NAME>
extern HTMLImageClass image_class;
</VARIABLE>
<FUNCTION>
<NAME>html_image_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_image_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLImageClass   *klass,HTMLType          type,guint             object_size
</FUNCTION>
<FUNCTION>
<NAME>html_image_init</NAME>
<RETURNS>void  </RETURNS>
HTMLImage        *image,HTMLImageClass   *klass,HTMLImageFactory *imf,const gchar      *filename,const gchar      *url,const gchar      *target,gint16            width,gint16            height,gboolean          percent_width,gboolean          percent_height,gint8             border,HTMLColor        *border_color,HTMLVAlignType    valign
</FUNCTION>
<FUNCTION>
<NAME>html_image_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
HTMLImageFactory *imf,const gchar      *filename,const gchar      *url,const gchar      *target,gint16            width,gint16            height,gboolean          percent_width,gboolean          percent_height,gint8             border,HTMLColor        *border_color,HTMLVAlignType    valign
</FUNCTION>
<FUNCTION>
<NAME>html_image_set_size</NAME>
<RETURNS>void  </RETURNS>
HTMLImage        *image,gint              w,gint              h,gboolean          pw,gboolean          ph
</FUNCTION>
<FUNCTION>
<NAME>html_image_set_spacing</NAME>
<RETURNS>void  </RETURNS>
HTMLImage        *image,gint              hspace,gint              vspace
</FUNCTION>
<FUNCTION>
<NAME>html_image_set_url</NAME>
<RETURNS>void  </RETURNS>
HTMLImage        *image,const gchar      *url
</FUNCTION>
<FUNCTION>
<NAME>html_image_set_valign</NAME>
<RETURNS>void  </RETURNS>
HTMLImage        *image,HTMLVAlignType    valign
</FUNCTION>
<FUNCTION>
<NAME>html_image_set_border</NAME>
<RETURNS>void  </RETURNS>
HTMLImage        *image,gint              border
</FUNCTION>
<FUNCTION>
<NAME>html_image_set_alt</NAME>
<RETURNS>void  </RETURNS>
HTMLImage        *image,gchar            *alt
</FUNCTION>
<FUNCTION>
<NAME>html_image_resolve_image_url</NAME>
<RETURNS>gchar       *</RETURNS>
GtkHTML          *html,gchar            *image_url
</FUNCTION>
<FUNCTION>
<NAME>html_image_factory_new</NAME>
<RETURNS>HTMLImageFactory  *</RETURNS>
HTMLEngine       *e
</FUNCTION>
<FUNCTION>
<NAME>html_image_factory_free</NAME>
<RETURNS>void  </RETURNS>
HTMLImageFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>html_image_factory_cleanup</NAME>
<RETURNS>void  </RETURNS>
HTMLImageFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>html_image_factory_stop_animations</NAME>
<RETURNS>void  </RETURNS>
HTMLImageFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>html_image_factory_deactivate_animations</NAME>
<RETURNS>void  </RETURNS>
HTMLImageFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>html_image_factory_register</NAME>
<RETURNS>HTMLImagePointer  *</RETURNS>
HTMLImageFactory *factory,HTMLImage        *i,const char       *filename
</FUNCTION>
<FUNCTION>
<NAME>html_image_factory_unregister</NAME>
<RETURNS>void  </RETURNS>
HTMLImageFactory *factory,HTMLImagePointer *pointer,HTMLImage        *i
</FUNCTION>
<MACRO>
<NAME>HTML_IMAGEINPUT</NAME>
#define HTML_IMAGEINPUT(x) ((HTMLImageInput *) (x))
</MACRO>
<MACRO>
<NAME>HTML_IMAGEINPUT_CLASS</NAME>
#define HTML_IMAGEINPUT_CLASS(x) ((HTMLImageInputClass *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLImageInput</NAME>
struct HTMLImageInput {
	HTMLEmbedded element;

        HTMLImage *image;
	gint m_x, m_y;
};
</STRUCT>
<VARIABLE>
<NAME>html_imageinput_class</NAME>
extern HTMLImageInputClass html_imageinput_class;
</VARIABLE>
<FUNCTION>
<NAME>html_imageinput_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_imageinput_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLImageInputClass *klass,HTMLType             type,guint                object_size
</FUNCTION>
<FUNCTION>
<NAME>html_imageinput_init</NAME>
<RETURNS>void  </RETURNS>
HTMLImageInput      *img,HTMLImageInputClass *klass,HTMLImageFactory    *imf,gchar               *name,gchar               *url
</FUNCTION>
<FUNCTION>
<NAME>html_imageinput_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
HTMLImageFactory    *imf,gchar               *name,gchar               *url
</FUNCTION>
<STRUCT>
<NAME>HTMLPoint</NAME>
struct HTMLPoint {
	HTMLObject *object;
	guint       offset;
};
</STRUCT>
<FUNCTION>
<NAME>html_point_new</NAME>
<RETURNS>HTMLPoint  *</RETURNS>
HTMLObject      *o,guint            off
</FUNCTION>
<FUNCTION>
<NAME>html_point_construct</NAME>
<RETURNS>void  </RETURNS>
HTMLPoint       *p,HTMLObject      *o,guint            off
</FUNCTION>
<FUNCTION>
<NAME>html_point_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLPoint       *p
</FUNCTION>
<FUNCTION>
<NAME>html_point_max</NAME>
<RETURNS>HTMLPoint  *</RETURNS>
HTMLPoint       *a,HTMLPoint       *b
</FUNCTION>
<FUNCTION>
<NAME>html_point_min</NAME>
<RETURNS>HTMLPoint  *</RETURNS>
HTMLPoint       *a,HTMLPoint       *b
</FUNCTION>
<FUNCTION>
<NAME>html_point_eq</NAME>
<RETURNS>gboolean  </RETURNS>
const HTMLPoint *a,const HTMLPoint *b
</FUNCTION>
<STRUCT>
<NAME>HTMLInterval</NAME>
struct HTMLInterval {
	HTMLPoint from;
	HTMLPoint to;
};
</STRUCT>
<FUNCTION>
<NAME>html_interval_new</NAME>
<RETURNS>HTMLInterval  *</RETURNS>
HTMLObject            *from,HTMLObject            *to,guint                  from_offset,guint                  to_offset
</FUNCTION>
<FUNCTION>
<NAME>html_interval_new_from_cursor</NAME>
<RETURNS>HTMLInterval  *</RETURNS>
HTMLCursor            *a,HTMLCursor            *b
</FUNCTION>
<FUNCTION>
<NAME>html_interval_new_from_points</NAME>
<RETURNS>HTMLInterval  *</RETURNS>
HTMLPoint             *from,HTMLPoint             *to
</FUNCTION>
<FUNCTION>
<NAME>html_interval_validate</NAME>
<RETURNS>void  </RETURNS>
HTMLInterval          *i
</FUNCTION>
<FUNCTION>
<NAME>html_interval_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLInterval          *i
</FUNCTION>
<FUNCTION>
<NAME>html_interval_get_length</NAME>
<RETURNS>guint  </RETURNS>
HTMLInterval          *i,HTMLObject            *obj
</FUNCTION>
<FUNCTION>
<NAME>html_interval_get_bytes</NAME>
<RETURNS>guint  </RETURNS>
HTMLInterval          *i,HTMLObject            *obj
</FUNCTION>
<FUNCTION>
<NAME>html_interval_get_start</NAME>
<RETURNS>guint  </RETURNS>
HTMLInterval          *i,HTMLObject            *obj
</FUNCTION>
<FUNCTION>
<NAME>html_interval_get_start_index</NAME>
<RETURNS>guint  </RETURNS>
HTMLInterval          *i,HTMLObject            *obj
</FUNCTION>
<FUNCTION>
<NAME>html_interval_get_head</NAME>
<RETURNS>HTMLObject  *</RETURNS>
HTMLInterval          *i,HTMLObject            *o
</FUNCTION>
<FUNCTION>
<NAME>html_interval_select</NAME>
<RETURNS>void  </RETURNS>
HTMLInterval          *i,HTMLEngine            *e
</FUNCTION>
<FUNCTION>
<NAME>html_interval_unselect</NAME>
<RETURNS>void  </RETURNS>
HTMLInterval          *i,HTMLEngine            *e
</FUNCTION>
<FUNCTION>
<NAME>html_interval_get_from_index</NAME>
<RETURNS>gint  </RETURNS>
HTMLInterval          *i
</FUNCTION>
<FUNCTION>
<NAME>html_interval_get_to_index</NAME>
<RETURNS>gint  </RETURNS>
HTMLInterval          *i
</FUNCTION>
<FUNCTION>
<NAME>html_interval_forall</NAME>
<RETURNS>void  </RETURNS>
HTMLInterval          *i,HTMLEngine            *e,HTMLObjectForallFunc   f,gpointer               data
</FUNCTION>
<FUNCTION>
<NAME>html_interval_eq</NAME>
<RETURNS>gboolean  </RETURNS>
const HTMLInterval    *a,const HTMLInterval    *b
</FUNCTION>
<FUNCTION>
<NAME>html_interval_intersection</NAME>
<RETURNS>HTMLInterval  *</RETURNS>
HTMLInterval          *a,HTMLInterval          *b
</FUNCTION>
<FUNCTION>
<NAME>html_interval_substract</NAME>
<RETURNS>void          *</RETURNS>
HTMLInterval          *a,HTMLInterval          *b,HTMLInterval         **s1,HTMLInterval         **s2
</FUNCTION>
<MACRO>
<NAME>HTML_LINK_TEXT</NAME>
#define HTML_LINK_TEXT(x) ((HTMLLinkText *)(x))
</MACRO>
<MACRO>
<NAME>HTML_LINK_TEXT_CLASS</NAME>
#define HTML_LINK_TEXT_CLASS(x) ((HTMLLinkTextClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLLinkText</NAME>
struct HTMLLinkText {
	HTMLText text;

	gchar *url;
	gchar *target;
};
</STRUCT>
<VARIABLE>
<NAME>html_link_text_class</NAME>
extern HTMLLinkTextClass html_link_text_class;
</VARIABLE>
<FUNCTION>
<NAME>html_link_text_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_link_text_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLLinkTextClass *klass,HTMLType           type,guint              object_size
</FUNCTION>
<FUNCTION>
<NAME>html_link_text_init</NAME>
<RETURNS>void  </RETURNS>
HTMLLinkText      *link_text_,HTMLLinkTextClass *klass,const gchar       *text,gint               len,GtkHTMLFontStyle   font_style,HTMLColor         *color,const gchar       *url,const gchar       *target
</FUNCTION>
<FUNCTION>
<NAME>html_link_text_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
const gchar       *text,GtkHTMLFontStyle   font_style,HTMLColor         *color,const gchar       *url,const gchar       *target
</FUNCTION>
<FUNCTION>
<NAME>html_link_text_new_with_len</NAME>
<RETURNS>HTMLObject  *</RETURNS>
const gchar       *text,gint               len,GtkHTMLFontStyle   font_style,HTMLColor         *color,const gchar       *url,const gchar       *target
</FUNCTION>
<FUNCTION>
<NAME>html_link_text_set_url</NAME>
<RETURNS>void  </RETURNS>
HTMLLinkText      *link,const gchar       *url
</FUNCTION>
<FUNCTION>
<NAME>html_link_text_to_text</NAME>
<RETURNS>void  </RETURNS>
HTMLLinkText      *link,HTMLEngine        *e
</FUNCTION>
<STRUCT>
<NAME>HTMLList</NAME>
struct HTMLList {
	HTMLListType type;
	HTMLListNumType numType;
	gint itemNumber;
};
</STRUCT>
<FUNCTION>
<NAME>html_list_new</NAME>
<RETURNS>HTMLList  *</RETURNS>
HTMLListType t, HTMLListNumType nt
</FUNCTION>
<FUNCTION>
<NAME>html_list_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLList *list
</FUNCTION>
<MACRO>
<NAME>HTML_OBJECT</NAME>
#define HTML_OBJECT(x)		((HTMLObject *) (x))
</MACRO>
<MACRO>
<NAME>HTML_OBJECT_CLASS</NAME>
#define HTML_OBJECT_CLASS(x)	((HTMLObjectClass *) (x))
</MACRO>
<MACRO>
<NAME>HTML_OBJECT_TYPE</NAME>
#define HTML_OBJECT_TYPE(x)     (HTML_OBJECT (x)->klass->type)
</MACRO>
<STRUCT>
<NAME>HTMLObject</NAME>
struct HTMLObject {
	HTMLObjectClass *klass;

	/* Pointer to the parent object.  */
	HTMLObject *parent;

	HTMLObject *prev;
	HTMLObject *next;

	HTMLChangeFlags change;

	gint x, y;

	gint ascent, descent;

	gint min_width;
	gint width;
	gint pref_width;
	gint max_width;

	gint percent;

	guchar flags;

	/* FIXME maybe unify with `flags'?  */
	guint redraw_pending : 1;
	guint selected : 1;

	/* If an object has a redraw pending and is being destroyed, this flag
           is set to TRUE instead of g_free()ing the object.  When the draw
           queue is flushed, the g_free() is performed.  */
	guint free_pending : 1;

	GData *object_data;
};
</STRUCT>
<VARIABLE>
<NAME>html_object_class</NAME>
extern HTMLObjectClass html_object_class;
</VARIABLE>
<FUNCTION>
<NAME>html_object_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_object_init</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *self,HTMLObjectClass       *klass
</FUNCTION>
<FUNCTION>
<NAME>html_object_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLObjectClass       *klass,HTMLType               type,guint                  object_size
</FUNCTION>
<FUNCTION>
<NAME>html_object_new</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *parent
</FUNCTION>
<FUNCTION>
<NAME>html_object_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_copy</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *self,HTMLObject            *dest
</FUNCTION>
<FUNCTION>
<NAME>html_object_dup</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_op_copy</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLEngine            *e,GList                 *from,GList                 *to,guint                 *len
</FUNCTION>
<FUNCTION>
<NAME>html_object_op_cut</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLEngine            *e,GList                 *from,GList                 *to,GList                 *left,GList                 *right,guint                 *len
</FUNCTION>
<FUNCTION>
<NAME>html_object_merge</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *self,HTMLObject            *with,HTMLEngine            *e
</FUNCTION>
<FUNCTION>
<NAME>html_object_remove_child</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *self,HTMLObject            *child
</FUNCTION>
<FUNCTION>
<NAME>html_object_split</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *self,HTMLEngine            *e,HTMLObject            *child,gint                   offset,gint                   level,GList                **left,GList                **right
</FUNCTION>
<FUNCTION>
<NAME>html_object_set_parent</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *self,HTMLObject            *parent
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_left_margin</NAME>
<RETURNS>gint  </RETURNS>
HTMLObject            *self,gint                   y
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_right_margin</NAME>
<RETURNS>gint  </RETURNS>
HTMLObject            *self,gint                   y
</FUNCTION>
<FUNCTION>
<NAME>html_object_set_painter</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o,HTMLPainter           *p,gint                   max_width
</FUNCTION>
<FUNCTION>
<NAME>html_object_clear_word_width</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o
</FUNCTION>
<FUNCTION>
<NAME>html_object_reset</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o
</FUNCTION>
<FUNCTION>
<NAME>html_object_is_text</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *object
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_engine</NAME>
<RETURNS>HTMLEngine      *</RETURNS>
HTMLObject            *self,HTMLEngine            *e
</FUNCTION>
<FUNCTION>
<NAME>html_object_forall</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *self,HTMLEngine            *e,HTMLObjectForallFunc   func,gpointer               data
</FUNCTION>
<FUNCTION>
<NAME>html_object_is_container</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_next_not_type</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLType               t
</FUNCTION>
<FUNCTION>
<NAME>html_object_prev_not_type</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLType               t
</FUNCTION>
<FUNCTION>
<NAME>html_object_next_not_slave</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_prev_not_slave</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_next_by_type</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLType               t
</FUNCTION>
<FUNCTION>
<NAME>html_object_prev_by_type</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLType               t
</FUNCTION>
<FUNCTION>
<NAME>html_object_search</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *self,HTMLSearch            *info
</FUNCTION>
<FUNCTION>
<NAME>html_object_search_next</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *self,HTMLSearch            *info
</FUNCTION>
<FUNCTION>
<NAME>html_object_draw</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o,HTMLPainter           *p,gint                   x,gint                   y,gint                   width,gint                   height,gint                   tx,gint                   ty
</FUNCTION>
<FUNCTION>
<NAME>html_object_draw_background</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o,HTMLPainter           *p,gint                   x,gint                   y,gint                   width,gint                   height,gint                   tx,gint                   ty
</FUNCTION>
<FUNCTION>
<NAME>html_object_set_bg_color</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o,GdkColor              *color
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_bg_color</NAME>
<RETURNS>GdkColor        *</RETURNS>
HTMLObject            *o,HTMLPainter           *p
</FUNCTION>
<FUNCTION>
<NAME>html_object_is_transparent</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_fit_line</NAME>
<RETURNS>HTMLFitType  </RETURNS>
HTMLObject            *o,HTMLPainter           *painter,gboolean               start_of_line,gboolean               first_run,gint                   width_left
</FUNCTION>
<FUNCTION>
<NAME>html_object_calc_size</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *o,HTMLPainter           *painter
</FUNCTION>
<FUNCTION>
<NAME>html_object_set_max_ascent</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o,HTMLPainter           *painter,gint                   a
</FUNCTION>
<FUNCTION>
<NAME>html_object_set_max_descent</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o,HTMLPainter           *painter,gint                   d
</FUNCTION>
<FUNCTION>
<NAME>html_object_set_max_width</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o,HTMLPainter           *painter,gint                   max_width
</FUNCTION>
<FUNCTION>
<NAME>html_object_calc_min_width</NAME>
<RETURNS>gint  </RETURNS>
HTMLObject            *o,HTMLPainter           *painter
</FUNCTION>
<FUNCTION>
<NAME>html_object_calc_preferred_width</NAME>
<RETURNS>gint  </RETURNS>
HTMLObject            *o,HTMLPainter           *painter
</FUNCTION>
<FUNCTION>
<NAME>html_object_calc_abs_position</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o,gint                  *x_return,gint                  *y_return
</FUNCTION>
<FUNCTION>
<NAME>html_object_calc_intersection</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *o,ArtIRect              *intersection,gint                   x,gint                   y,gint                   width,gint                   height
</FUNCTION>
<FUNCTION>
<NAME>html_object_relayout</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *obj,HTMLEngine            *engine,HTMLObject            *child
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_valign</NAME>
<RETURNS>HTMLVAlignType  </RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_url</NAME>
<RETURNS>const gchar     *</RETURNS>
HTMLObject            *o
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_target</NAME>
<RETURNS>const gchar     *</RETURNS>
HTMLObject            *o
</FUNCTION>
<FUNCTION>
<NAME>html_object_find_anchor</NAME>
<RETURNS>HTMLAnchor      *</RETURNS>
HTMLObject            *o,const gchar           *name,gint                  *x,gint                  *y
</FUNCTION>
<FUNCTION>
<NAME>html_object_set_link</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLColor             *color,const gchar           *url,const gchar           *target
</FUNCTION>
<FUNCTION>
<NAME>html_object_remove_link</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLColor             *color
</FUNCTION>
<FUNCTION>
<NAME>html_object_accepts_cursor</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *obj
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_cursor</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *obj,HTMLPainter           *painter,guint                  offset,gint                  *x1,gint                  *y1,gint                  *x2,gint                  *y2
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_cursor_base</NAME>
<RETURNS>void  </RETURNS>
HTMLObject            *obj,HTMLPainter           *painter,guint                  offset,gint                  *x,gint                  *y
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_length</NAME>
<RETURNS>guint  </RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_bytes</NAME>
<RETURNS>guint  </RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_index</NAME>
<RETURNS>guint  </RETURNS>
HTMLObject            *self,guint                  offset
</FUNCTION>
<FUNCTION>
<NAME>html_object_check_point</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *clue,HTMLPainter           *painter,gint                   x,gint                   y,guint                 *offset_return,gboolean               for_cursor
</FUNCTION>
<FUNCTION>
<NAME>html_object_cursor_forward</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *self,HTMLCursor            *cursor
</FUNCTION>
<FUNCTION>
<NAME>html_object_cursor_backward</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject            *self,HTMLCursor            *cursor
</FUNCTION>
<FUNCTION>
<NAME>html_object_next</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLObject            *child
</FUNCTION>
<FUNCTION>
<NAME>html_object_prev</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLObject            *child
</FUNCTION>
<FUNCTION>
<NAME>html_object_head</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_tail</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_tail_not_slave</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_next_leaf</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_prev_leaf</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self
</FUNCTION>
<FUNCTION>
<NAME>html_object_next_leaf_not_type</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLType               t
</FUNCTION>
<FUNCTION>
<NAME>html_object_prev_leaf_not_type</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *self,HTMLType               t
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_head_leaf</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *o
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_tail_leaf</NAME>
<RETURNS>HTMLObject      *</RETURNS>
HTMLObject            *o
</FUNCTION>
<FUNCTION>
<NAME>html_object_check_page_split</NAME>
<RETURNS>gint  </RETURNS>
HTMLObject *self,gint        y
</FUNCTION>
<FUNCTION>
<NAME>html_object_select_range</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject *self,HTMLEngine *engine,guint       start,gint        length,gboolean    queue_draw
</FUNCTION>
<FUNCTION>
<NAME>html_object_append_selection_string</NAME>
<RETURNS>void  </RETURNS>
HTMLObject *self,GString    *buffer
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_selection_string</NAME>
<RETURNS>gchar       *</RETURNS>
HTMLObject *o
</FUNCTION>
<FUNCTION>
<NAME>html_object_save</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject          *self,HTMLEngineSaveState *state
</FUNCTION>
<FUNCTION>
<NAME>html_object_save_plain</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject          *self,HTMLEngineSaveState *state,gint requested_width
</FUNCTION>
<FUNCTION>
<NAME>html_object_change_set</NAME>
<RETURNS>void  </RETURNS>
HTMLObject      *self,HTMLChangeFlags  f
</FUNCTION>
<FUNCTION>
<NAME>html_object_change_set_down</NAME>
<RETURNS>void  </RETURNS>
HTMLObject      *self,HTMLChangeFlags  f
</FUNCTION>
<FUNCTION>
<NAME>html_object_set_data</NAME>
<RETURNS>void  </RETURNS>
HTMLObject  *object,const gchar *key,gpointer     data
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_data</NAME>
<RETURNS>gpointer  </RETURNS>
HTMLObject  *object,const gchar *key
</FUNCTION>
<FUNCTION>
<NAME>html_object_copy_data_from_object</NAME>
<RETURNS>void  </RETURNS>
HTMLObject  *dst,HTMLObject  *src
</FUNCTION>
<FUNCTION>
<NAME>html_object_get_bound_list</NAME>
<RETURNS>GList     *</RETURNS>
HTMLObject *obj,GList      *list
</FUNCTION>
<FUNCTION>
<NAME>html_object_move_cursor_before_remove</NAME>
<RETURNS>void  </RETURNS>
HTMLObject *o,HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_object_could_remove_whole</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLObject *o,GList      *from,GList      *to,GList      *left,GList      *right
</FUNCTION>
<FUNCTION>
<NAME>html_object_check_cut_lists</NAME>
<RETURNS>void  </RETURNS>
HTMLObject *self,HTMLObject *replacement,GList      *left,GList      *right
</FUNCTION>
<MACRO>
<NAME>HTML_TYPE_PAINTER</NAME>
#define HTML_TYPE_PAINTER                 (html_painter_get_type ())
</MACRO>
<MACRO>
<NAME>HTML_PAINTER</NAME>
#define HTML_PAINTER(obj)                 (GTK_CHECK_CAST ((obj), HTML_TYPE_PAINTER, HTMLPainter))
</MACRO>
<MACRO>
<NAME>HTML_PAINTER_CLASS</NAME>
#define HTML_PAINTER_CLASS(klass)         (GTK_CHECK_CLASS_CAST ((klass), HTML_TYPE_PAINTER, HTMLPainterClass))
</MACRO>
<MACRO>
<NAME>HTML_IS_PAINTER</NAME>
#define HTML_IS_PAINTER(obj)              (GTK_CHECK_TYPE ((obj), HTML_TYPE_PAINTER))
</MACRO>
<MACRO>
<NAME>HTML_IS_PAINTER_CLASS</NAME>
#define HTML_IS_PAINTER_CLASS(klass)      (GTK_CHECK_CLASS_TYPE ((klass), HTML_TYPE_PAINTER))
</MACRO>
<STRUCT>
<NAME>HTMLPainter</NAME>
struct HTMLPainter {
	GtkObject base;

	HTMLFontManager     font_manager;
	HTMLColorSet       *color_set;
	HTMLFontFace       *font_face;
	GtkHTMLFontStyle    font_style;
};
</STRUCT>
<FUNCTION>
<NAME>html_painter_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_painter_new</NAME>
<RETURNS>HTMLPainter       *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_painter_begin</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,int                x1,int                y1,int                x2,int                y2
</FUNCTION>
<FUNCTION>
<NAME>html_painter_end</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter
</FUNCTION>
<FUNCTION>
<NAME>html_painter_alloc_color</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,GdkColor          *color
</FUNCTION>
<FUNCTION>
<NAME>html_painter_free_color</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,GdkColor          *color
</FUNCTION>
<FUNCTION>
<NAME>html_painter_set_color_set</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,HTMLColorSet      *color_set
</FUNCTION>
<FUNCTION>
<NAME>html_painter_get_default_background_color</NAME>
<RETURNS>const GdkColor    *</RETURNS>
HTMLPainter       *painter
</FUNCTION>
<FUNCTION>
<NAME>html_painter_get_default_foreground_color</NAME>
<RETURNS>const GdkColor    *</RETURNS>
HTMLPainter       *painter
</FUNCTION>
<FUNCTION>
<NAME>html_painter_get_default_link_color</NAME>
<RETURNS>const GdkColor    *</RETURNS>
HTMLPainter       *painter
</FUNCTION>
<FUNCTION>
<NAME>html_painter_get_default_highlight_color</NAME>
<RETURNS>const GdkColor    *</RETURNS>
HTMLPainter       *painter
</FUNCTION>
<FUNCTION>
<NAME>html_painter_get_default_highlight_foreground_color</NAME>
<RETURNS>const GdkColor    *</RETURNS>
HTMLPainter       *painter
</FUNCTION>
<FUNCTION>
<NAME>html_painter_get_black</NAME>
<RETURNS>const GdkColor    *</RETURNS>
const HTMLPainter *painter
</FUNCTION>
<FUNCTION>
<NAME>html_painter_find_font_face</NAME>
<RETURNS>HTMLFontFace      *</RETURNS>
HTMLPainter       *p,const gchar       *families
</FUNCTION>
<FUNCTION>
<NAME>html_painter_set_font_style</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *p,GtkHTMLFontStyle   f
</FUNCTION>
<FUNCTION>
<NAME>html_painter_get_font_style</NAME>
<RETURNS>GtkHTMLFontStyle  </RETURNS>
HTMLPainter       *p
</FUNCTION>
<FUNCTION>
<NAME>html_painter_set_font_face</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *p,HTMLFontFace      *f
</FUNCTION>
<FUNCTION>
<NAME>html_painter_get_font</NAME>
<RETURNS>gpointer  </RETURNS>
HTMLPainter       *painter,HTMLFontFace      *face,GtkHTMLFontStyle   style
</FUNCTION>
<FUNCTION>
<NAME>html_painter_calc_ascent</NAME>
<RETURNS>guint  </RETURNS>
HTMLPainter       *p,GtkHTMLFontStyle   f,HTMLFontFace      *face
</FUNCTION>
<FUNCTION>
<NAME>html_painter_calc_descent</NAME>
<RETURNS>guint  </RETURNS>
HTMLPainter       *p,GtkHTMLFontStyle   f,HTMLFontFace      *face
</FUNCTION>
<FUNCTION>
<NAME>html_painter_calc_text_width</NAME>
<RETURNS>guint  </RETURNS>
HTMLPainter       *p,const gchar       *text,guint              len,GtkHTMLFontStyle   font_style,HTMLFontFace      *face
</FUNCTION>
<FUNCTION>
<NAME>html_painter_set_pen</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,const GdkColor    *color
</FUNCTION>
<FUNCTION>
<NAME>html_painter_draw_line</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,gint               x1,gint               y1,gint               x2,gint               y2
</FUNCTION>
<FUNCTION>
<NAME>html_painter_draw_rect</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,gint               x,gint               y,gint               width,gint               height
</FUNCTION>
<FUNCTION>
<NAME>html_painter_draw_text</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,gint               x,gint               y,const gchar       *text,gint               len
</FUNCTION>
<FUNCTION>
<NAME>html_painter_fill_rect</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,gint               x,gint               y,gint               width,gint               height
</FUNCTION>
<FUNCTION>
<NAME>html_painter_draw_pixmap</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,GdkPixbuf         *pixbuf,gint               x,gint               y,gint               scale_width,gint               scale_height,const GdkColor    *color
</FUNCTION>
<FUNCTION>
<NAME>html_painter_draw_ellipse</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,gint               x,gint               y,gint               width,gint               height
</FUNCTION>
<FUNCTION>
<NAME>html_painter_clear</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter
</FUNCTION>
<FUNCTION>
<NAME>html_painter_set_background_color</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,const GdkColor    *color
</FUNCTION>
<FUNCTION>
<NAME>html_painter_draw_shade_line</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *p,gint               x,gint               y,gint               width
</FUNCTION>
<FUNCTION>
<NAME>html_painter_draw_panel</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,GdkColor          *bg,gint               x,gint               y,gint               width,gint               height,GtkHTMLEtchStyle   inset,gint               bordersize
</FUNCTION>
<FUNCTION>
<NAME>html_painter_set_clip_rectangle</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,gint               x,gint               y,gint               width,gint               height
</FUNCTION>
<FUNCTION>
<NAME>html_painter_draw_background</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,GdkColor          *color,GdkPixbuf         *pixbuf,gint               x,gint               y,gint               width,gint               height,gint               tile_x,gint               tile_y
</FUNCTION>
<FUNCTION>
<NAME>html_painter_get_pixel_size</NAME>
<RETURNS>guint  </RETURNS>
HTMLPainter       *painter
</FUNCTION>
<FUNCTION>
<NAME>html_painter_draw_spell_error</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,gint               x,gint               y,const gchar       *text,guint              off,gint               len
</FUNCTION>
<FUNCTION>
<NAME>html_painter_alloc_font</NAME>
<RETURNS>HTMLFont          *</RETURNS>
HTMLPainter       *painter,gchar             *face_name,gdouble            size,GtkHTMLFontStyle   style
</FUNCTION>
<FUNCTION>
<NAME>html_painter_ref_font</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,HTMLFont          *font
</FUNCTION>
<FUNCTION>
<NAME>html_painter_unref_font</NAME>
<RETURNS>void  </RETURNS>
HTMLPainter       *painter,HTMLFont          *font
</FUNCTION>
<FUNCTION>
<NAME>html_painter_get_space_width</NAME>
<RETURNS>guint  </RETURNS>
HTMLPainter       *painter,GtkHTMLFontStyle   font_style,HTMLFontFace      *face
</FUNCTION>
<MACRO>
<NAME>HTML_TYPE_PRINTER</NAME>
#define HTML_TYPE_PRINTER                 (html_printer_get_type ())
</MACRO>
<MACRO>
<NAME>HTML_PRINTER</NAME>
#define HTML_PRINTER(obj)                 (GTK_CHECK_CAST ((obj), HTML_TYPE_PRINTER, HTMLPrinter))
</MACRO>
<MACRO>
<NAME>HTML_PRINTER_CLASS</NAME>
#define HTML_PRINTER_CLASS(klass)         (GTK_CHECK_CLASS_CAST ((klass), HTML_TYPE_PRINTER, HTMLPrinterClass))
</MACRO>
<MACRO>
<NAME>HTML_IS_PRINTER</NAME>
#define HTML_IS_PRINTER(obj)              (GTK_CHECK_TYPE ((obj), HTML_TYPE_PRINTER))
</MACRO>
<MACRO>
<NAME>HTML_IS_PRINTER_CLASS</NAME>
#define HTML_IS_PRINTER_CLASS(klass)      (GTK_CHECK_CLASS_TYPE ((klass), HTML_TYPE_PRINTER))
</MACRO>
<STRUCT>
<NAME>HTMLPrinter</NAME>
struct HTMLPrinter {
	HTMLPainter base;

	GnomePrintContext *print_context;
};
</STRUCT>
<FUNCTION>
<NAME>html_printer_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_printer_new</NAME>
<RETURNS>HTMLPainter  *</RETURNS>
GnomePrintContext *print_context
</FUNCTION>
<FUNCTION>
<NAME>html_printer_get_page_width</NAME>
<RETURNS>guint  </RETURNS>
HTMLPrinter       *printer
</FUNCTION>
<FUNCTION>
<NAME>html_printer_get_page_height</NAME>
<RETURNS>guint  </RETURNS>
HTMLPrinter       *printer
</FUNCTION>
<FUNCTION>
<NAME>html_printer_scale_to_gnome_print</NAME>
<RETURNS>gdouble  </RETURNS>
gint               x
</FUNCTION>
<FUNCTION>
<NAME>html_printer_coordinates_to_gnome_print</NAME>
<RETURNS>void  </RETURNS>
HTMLPrinter       *printer,gint               engine_x,gint               engine_y,gdouble           *print_x_return,gdouble           *print_y_return
</FUNCTION>
<MACRO>
<NAME>HTML_RADIO</NAME>
#define HTML_RADIO(x) ((HTMLRadio *) (x))
</MACRO>
<MACRO>
<NAME>HTML_RADIO_CLASS</NAME>
#define HTML_RADIO_CLASS(x) ((HTMLRadioClass *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLRadio</NAME>
struct HTMLRadio {
	HTMLEmbedded element;
	gint default_checked;
};
</STRUCT>
<VARIABLE>
<NAME>html_radio_class</NAME>
extern HTMLRadioClass html_radio_class;
</VARIABLE>
<FUNCTION>
<NAME>html_radio_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_radio_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLRadioClass *klass,HTMLType        type,guint           object_size
</FUNCTION>
<FUNCTION>
<NAME>html_radio_init</NAME>
<RETURNS>void  </RETURNS>
HTMLRadio      *radio,HTMLRadioClass *klass,GtkWidget      *parent,gchar          *name,gchar          *value,gboolean        checked,GSList        **radio_group
</FUNCTION>
<FUNCTION>
<NAME>html_radio_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
GtkWidget      *parent,gchar          *name,gchar          *value,gboolean        checked,GSList        **radio_group
</FUNCTION>
<STRUCT>
<NAME>HTMLReplace</NAME>
struct HTMLReplace {
	gchar *text;
	gint   replaced;
	void (*ask) (HTMLEngine *, gpointer);
	gpointer ask_data;
};
</STRUCT>
<FUNCTION>
<NAME>html_replace_new</NAME>
<RETURNS>HTMLReplace      *</RETURNS>
const gchar *text, void (*ask) (HTMLEngine *, gpointer), gpointer ask_data
</FUNCTION>
<FUNCTION>
<NAME>html_replace_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLReplace *replace
</FUNCTION>
<MACRO>
<NAME>HTML_RULE</NAME>
#define HTML_RULE(x) ((HTMLRule *) (x))
</MACRO>
<MACRO>
<NAME>HTML_RULE_CLASS</NAME>
#define HTML_RULE_CLASS(x) ((HTMLRuleClass *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLRule</NAME>
struct HTMLRule {
	HTMLObject object;

	guint length;
	gchar size;
	gboolean shade;
	HTMLHAlignType halign;
};
</STRUCT>
<VARIABLE>
<NAME>html_rule_class</NAME>
extern HTMLRuleClass html_rule_class;
</VARIABLE>
<FUNCTION>
<NAME>html_rule_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_rule_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLRuleClass  *klass,HTMLType        type,guint           object_size
</FUNCTION>
<FUNCTION>
<NAME>html_rule_init</NAME>
<RETURNS>void  </RETURNS>
HTMLRule       *rule,HTMLRuleClass  *klass,gint            length,gint            percent,gint            size,gboolean        shade,HTMLHAlignType  halign
</FUNCTION>
<FUNCTION>
<NAME>html_rule_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
gint            length,gint            percent,gint            size,gboolean        shade,HTMLHAlignType  halign
</FUNCTION>
<STRUCT>
<NAME>HTMLSearch</NAME>
struct HTMLSearch {
	HTMLEngine *engine;
	gchar *trans;
	gchar *text;
	guint  text_len;
	guint  found_len;

	gboolean case_sensitive;
	gboolean forward;
	gboolean regular;

	GSList      *stack;
	GList       *found;
	HTMLObject *last;

	guint start_pos;
	guint stop_pos;

	regex_t *reb;        /* regex buffer */
};
</STRUCT>
<FUNCTION>
<NAME>html_search_new</NAME>
<RETURNS>HTMLSearch       *</RETURNS>
HTMLEngine *e,const gchar *text,gboolean case_sensitive,gboolean forward,gboolean regular
</FUNCTION>
<FUNCTION>
<NAME>html_search_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLSearch *search
</FUNCTION>
<FUNCTION>
<NAME>html_search_push</NAME>
<RETURNS>void  </RETURNS>
HTMLSearch *search, HTMLObject *obj
</FUNCTION>
<FUNCTION>
<NAME>html_search_pop</NAME>
<RETURNS>HTMLObject       *</RETURNS>
HTMLSearch *search
</FUNCTION>
<FUNCTION>
<NAME>html_search_child_on_stack</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLSearch *search, HTMLObject *obj
</FUNCTION>
<FUNCTION>
<NAME>html_search_next_parent</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLSearch *search
</FUNCTION>
<FUNCTION>
<NAME>html_search_set_text</NAME>
<RETURNS>void  </RETURNS>
HTMLSearch *search,const gchar *text
</FUNCTION>
<FUNCTION>
<NAME>html_search_set_forward</NAME>
<RETURNS>void  </RETURNS>
HTMLSearch *search,gboolean    forward
</FUNCTION>
<MACRO>
<NAME>HTML_SELECT</NAME>
#define HTML_SELECT(x) ((HTMLSelect *) (x))
</MACRO>
<MACRO>
<NAME>HTML_SELECT_CLASS</NAME>
#define HTML_SELECT_CLASS(x) ((HTMLSelectClass *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLSelect</NAME>
struct HTMLSelect {
	HTMLEmbedded element;
	gint size;
	gboolean multi;

	gint default_selected;

	GList *values;
	GList *strings;
	GList *default_selection;

	GtkWidget *clist;
};
</STRUCT>
<VARIABLE>
<NAME>html_select_class</NAME>
extern HTMLSelectClass html_select_class;
</VARIABLE>
<FUNCTION>
<NAME>html_select_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_select_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLSelectClass *klass,HTMLType         type,guint            object_size
</FUNCTION>
<FUNCTION>
<NAME>html_select_init</NAME>
<RETURNS>void  </RETURNS>
HTMLSelect      *ti,HTMLSelectClass *klass,GtkWidget       *parent,gchar           *name,gint             size,gboolean         multi
</FUNCTION>
<FUNCTION>
<NAME>html_select_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
GtkWidget       *parent,gchar           *name,gint             size,gboolean         multi
</FUNCTION>
<FUNCTION>
<NAME>html_select_add_option</NAME>
<RETURNS>void  </RETURNS>
HTMLSelect      *select,gchar           *value,gboolean         selected
</FUNCTION>
<FUNCTION>
<NAME>html_select_set_text</NAME>
<RETURNS>void  </RETURNS>
HTMLSelect      *select,gchar           *text
</FUNCTION>
<FUNCTION>
<NAME>html_engine_select_interval</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e,HTMLInterval *i
</FUNCTION>
<FUNCTION>
<NAME>html_engine_select_region</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e,gint        x1,gint        y1,gint        x2,gint        y2
</FUNCTION>
<FUNCTION>
<NAME>html_engine_select_word</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_select_line</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_unselect_all</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_clear_selection</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_deactivate_selection</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_disable_selection</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_get_selection_string</NAME>
<RETURNS>gchar     *</RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_is_selection_active</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLEngine *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_activate_selection</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine *e,guint32     time
</FUNCTION>
<MACRO>
<NAME>HTML_NUM_FONT_SIZES</NAME>
#define HTML_NUM_FONT_SIZES 7
</MACRO>
<STRUCT>
<NAME>HTMLSettings</NAME>
struct HTMLSettings {
	gint fontSizes [HTML_NUM_FONT_SIZES];
	gint fontBaseSize;

	gchar *fontBaseFace;
	gchar *fixedFontFace;

	guint underlineLinks : 1;
	guint forceDefault : 1;

	HTMLColorSet *color_set;
};
</STRUCT>
<FUNCTION>
<NAME>html_settings_new</NAME>
<RETURNS>HTMLSettings  *</RETURNS>
GtkWidget *w
</FUNCTION>
<FUNCTION>
<NAME>html_settings_reset</NAME>
<RETURNS>void  </RETURNS>
HTMLSettings *settings,HTMLSettings *orig,HTMLPainter  *painter
</FUNCTION>
<FUNCTION>
<NAME>html_settings_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLSettings *settings
</FUNCTION>
<FUNCTION>
<NAME>html_settings_set_font_sizes</NAME>
<RETURNS>void  </RETURNS>
HTMLSettings *settings,const gint *newFontSizes
</FUNCTION>
<FUNCTION>
<NAME>html_settings_get_font_sizes</NAME>
<RETURNS>void  </RETURNS>
HTMLSettings *settings,gint *fontSizes
</FUNCTION>
<FUNCTION>
<NAME>html_settings_reset_font_sizes</NAME>
<RETURNS>void  </RETURNS>
HTMLSettings *settings
</FUNCTION>
<FUNCTION>
<NAME>html_settings_copy</NAME>
<RETURNS>void  </RETURNS>
HTMLSettings *dest, HTMLSettings *src
</FUNCTION>
<FUNCTION>
<NAME>html_settings_set_font_base_face</NAME>
<RETURNS>void  </RETURNS>
HTMLSettings *settings, const gchar *face
</FUNCTION>
<FUNCTION>
<NAME>html_settings_set_fixed_font_face</NAME>
<RETURNS>void  </RETURNS>
HTMLSettings *settings, const gchar *face
</FUNCTION>
<STRUCT>
<NAME>HTMLStack</NAME>
struct HTMLStack {
	HTMLStackFreeFunc free_func;

	GList *list;
};
</STRUCT>
<FUNCTION>
<NAME>html_stack_new</NAME>
<RETURNS>HTMLStack  *</RETURNS>
HTMLStackFreeFunc free_func
</FUNCTION>
<FUNCTION>
<NAME>html_stack_clear</NAME>
<RETURNS>void  </RETURNS>
HTMLStack *stack
</FUNCTION>
<FUNCTION>
<NAME>html_stack_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLStack *stack
</FUNCTION>
<FUNCTION>
<NAME>html_stack_pop</NAME>
<RETURNS>gpointer  </RETURNS>
HTMLStack *stack
</FUNCTION>
<FUNCTION>
<NAME>html_stack_top</NAME>
<RETURNS>gpointer  </RETURNS>
HTMLStack *stack
</FUNCTION>
<FUNCTION>
<NAME>html_stack_push</NAME>
<RETURNS>void  </RETURNS>
HTMLStack *stack, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>html_stack_is_empty</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLStack *stack
</FUNCTION>
<FUNCTION>
<NAME>html_stack_count</NAME>
<RETURNS>guint  </RETURNS>
HTMLStack *stack
</FUNCTION>
<STRUCT>
<NAME>HTMLStringTokenizer</NAME>
struct HTMLStringTokenizer {
	gchar *buffer;
	gint buffer_length;

	gchar *pos;
	gchar *end;
};
</STRUCT>
<FUNCTION>
<NAME>html_string_tokenizer_new</NAME>
<RETURNS>HTMLStringTokenizer  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_string_tokenizer_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLStringTokenizer *st
</FUNCTION>
<FUNCTION>
<NAME>html_string_tokenizer_tokenize</NAME>
<RETURNS>void  </RETURNS>
HTMLStringTokenizer *t,const gchar         *str,gchar               *separators
</FUNCTION>
<FUNCTION>
<NAME>html_string_tokenizer_has_more_tokens</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLStringTokenizer *t
</FUNCTION>
<FUNCTION>
<NAME>html_string_tokenizer_next_token</NAME>
<RETURNS>gchar                *</RETURNS>
HTMLStringTokenizer *t
</FUNCTION>
<MACRO>
<NAME>HTML_TABLE</NAME>
#define HTML_TABLE(x) ((HTMLTable *)(x))
</MACRO>
<MACRO>
<NAME>HTML_TABLE_CLASS</NAME>
#define HTML_TABLE_CLASS(x) ((HTMLTableClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLTable</NAME>
struct HTMLTable {
	HTMLObject object;

	gint specified_width;

	HTMLTableCell ***cells;
	gint col, totalCols;
	gint row, totalRows, allocRows;
	gint spacing;
	gint padding;
	gint border;
	HTMLClueV *caption;
	HTMLVAlignType capAlign;
	
	GArray *columnMin;
	GArray *columnPref;
	GArray *columnFixed;
	GArray *columnOpt;
	GArray *rowHeights;

	GdkColor *bgColor;
	HTMLImagePointer *bgPixmap;
};
</STRUCT>
<FUNCTION>
<NAME>html_table_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_table_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTableClass *klass,HTMLType        type,guint           object_size
</FUNCTION>
<FUNCTION>
<NAME>html_table_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTable      *table,HTMLTableClass *klass,gint            width,gint            percent,gint            padding,gint            spacing,gint            border
</FUNCTION>
<FUNCTION>
<NAME>html_table_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
gint            width,gint            percent,gint            padding,gint            spacing,gint            border
</FUNCTION>
<FUNCTION>
<NAME>html_table_end_row</NAME>
<RETURNS>void  </RETURNS>
HTMLTable     *table
</FUNCTION>
<FUNCTION>
<NAME>html_table_start_row</NAME>
<RETURNS>void  </RETURNS>
HTMLTable     *table
</FUNCTION>
<FUNCTION>
<NAME>html_table_add_cell</NAME>
<RETURNS>void  </RETURNS>
HTMLTable     *table,HTMLTableCell *cell
</FUNCTION>
<FUNCTION>
<NAME>html_table_end_table</NAME>
<RETURNS>void  </RETURNS>
HTMLTable     *table
</FUNCTION>
<MACRO>
<NAME>HTML_TABLE_CELL</NAME>
#define HTML_TABLE_CELL(x) ((HTMLTableCell *)(x))
</MACRO>
<MACRO>
<NAME>HTML_TABLE_CELL_CLASS</NAME>
#define HTML_TABLE_CELL_CLASS(x) ((HTMLTableCellClass *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLTableCell</NAME>
struct HTMLTableCell {
	HTMLClueV cluev;

	gint fixed_width;
	gint fixed_height;

	gint rspan;
	gint cspan;
	gint padding;
	gint refcount;
	gint row;
	gint col;

	GdkColor bg;
	guint have_bg : 1;
	guint bg_allocated : 1;

	HTMLImagePointer *bgPixmap;
	gboolean have_bgPixmap;
};
</STRUCT>
<VARIABLE>
<NAME>html_table_cell_class</NAME>
extern HTMLTableCellClass html_table_cell_class;
</VARIABLE>
<FUNCTION>
<NAME>html_table_cell_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_table_cell_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTableCellClass *klass,HTMLType            type,guint               object_size
</FUNCTION>
<FUNCTION>
<NAME>html_table_cell_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTableCell      *cell,HTMLTableCellClass *klass,gint                percent,gint                rs,gint                cs,gint                pad
</FUNCTION>
<FUNCTION>
<NAME>html_table_cell_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
gint                percent,gint                rs,gint                cs,gint                pad
</FUNCTION>
<FUNCTION>
<NAME>html_table_cell_link</NAME>
<RETURNS>void  </RETURNS>
HTMLTableCell      *cell
</FUNCTION>
<FUNCTION>
<NAME>html_table_cell_unlink</NAME>
<RETURNS>void  </RETURNS>
HTMLTableCell      *cell
</FUNCTION>
<FUNCTION>
<NAME>html_table_cell_set_fixed_width</NAME>
<RETURNS>void  </RETURNS>
HTMLTableCell      *cell,gint                width
</FUNCTION>
<FUNCTION>
<NAME>html_table_cell_set_fixed_height</NAME>
<RETURNS>void  </RETURNS>
HTMLTableCell      *cell,gint                height
</FUNCTION>
<FUNCTION>
<NAME>html_table_cell_set_bg_pixmap</NAME>
<RETURNS>void  </RETURNS>
HTMLTableCell      *cell,HTMLImagePointer   *imagePtr
</FUNCTION>
<FUNCTION>
<NAME>html_table_cell_set_position</NAME>
<RETURNS>void  </RETURNS>
HTMLTableCell      *cell,gint                row,gint                col
</FUNCTION>
<FUNCTION>
<NAME>html_table_cell_get_fixed_width</NAME>
<RETURNS>gint  </RETURNS>
HTMLTableCell      *cell,HTMLPainter        *painter
</FUNCTION>
<MACRO>
<NAME>HTML_TEXT</NAME>
#define HTML_TEXT(x) ((HTMLText *)(x))
</MACRO>
<MACRO>
<NAME>HTML_TEXT_CLASS</NAME>
#define HTML_TEXT_CLASS(x) ((HTMLTextClass *)(x))
</MACRO>
<STRUCT>
<NAME>SpellError</NAME>
struct SpellError {
	guint off;
	guint len;
};
</STRUCT>
<STRUCT>
<NAME>HTMLText</NAME>
struct HTMLText {
	HTMLObject object;
	
	gchar   *text;
	guint    text_len;
	guint   *word_width;
	guint    words;

	GtkHTMLFontStyle  font_style;
	HTMLFontFace     *face;
	HTMLColor        *color;

	guint select_start;
	guint select_length;

	GList *spell_errors;
};
</STRUCT>
<VARIABLE>
<NAME>html_text_class</NAME>
extern HTMLTextClass html_text_class;
</VARIABLE>
<FUNCTION>
<NAME>html_text_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_text_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTextClass      *klass,HTMLType            type,guint               object_size
</FUNCTION>
<FUNCTION>
<NAME>html_text_init</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text_object,HTMLTextClass      *klass,const gchar        *text,gint                len,GtkHTMLFontStyle    font_style,HTMLColor          *color
</FUNCTION>
<FUNCTION>
<NAME>html_text_new</NAME>
<RETURNS>HTMLObject        *</RETURNS>
const gchar        *text,GtkHTMLFontStyle    font_style,HTMLColor          *color
</FUNCTION>
<FUNCTION>
<NAME>html_text_new_with_len</NAME>
<RETURNS>HTMLObject        *</RETURNS>
const gchar        *text,gint                len,GtkHTMLFontStyle    font_style,HTMLColor          *color
</FUNCTION>
<FUNCTION>
<NAME>html_text_queue_draw</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text,HTMLEngine         *engine,guint               offset,guint               len
</FUNCTION>
<FUNCTION>
<NAME>html_text_get_font_style</NAME>
<RETURNS>GtkHTMLFontStyle  </RETURNS>
const HTMLText     *text
</FUNCTION>
<FUNCTION>
<NAME>html_text_get_color</NAME>
<RETURNS>HTMLColor         *</RETURNS>
HTMLText           *text,HTMLPainter        *painter
</FUNCTION>
<FUNCTION>
<NAME>html_text_set_font_style</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text,HTMLEngine         *engine,GtkHTMLFontStyle    style
</FUNCTION>
<FUNCTION>
<NAME>html_text_set_color</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text,HTMLEngine         *engine,HTMLColor          *color
</FUNCTION>
<FUNCTION>
<NAME>html_text_append</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text,const gchar        *str,gint                len
</FUNCTION>
<FUNCTION>
<NAME>html_text_set_text</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text,const gchar        *new_text
</FUNCTION>
<FUNCTION>
<NAME>html_text_set_font_face</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text,HTMLFontFace       *face
</FUNCTION>
<FUNCTION>
<NAME>html_text_get_nb_width</NAME>
<RETURNS>gint  </RETURNS>
HTMLText           *text,HTMLPainter        *painter,gboolean            begin
</FUNCTION>
<FUNCTION>
<NAME>html_text_get_bytes</NAME>
<RETURNS>guint  </RETURNS>
HTMLText           *text
</FUNCTION>
<FUNCTION>
<NAME>html_text_get_index</NAME>
<RETURNS>guint  </RETURNS>
HTMLText           *text,guint               offset
</FUNCTION>
<FUNCTION>
<NAME>html_text_get_char</NAME>
<RETURNS>unicode_char_t  </RETURNS>
HTMLText           *text,guint               offset
</FUNCTION>
<FUNCTION>
<NAME>html_text_get_text</NAME>
<RETURNS>gchar             *</RETURNS>
HTMLText           *text,guint               offset
</FUNCTION>
<FUNCTION>
<NAME>html_text_spell_errors_clear</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text
</FUNCTION>
<FUNCTION>
<NAME>html_text_spell_errors_clear_interval</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text,HTMLInterval       *i
</FUNCTION>
<FUNCTION>
<NAME>html_text_spell_errors_add</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text,guint               off,guint               len
</FUNCTION>
<FUNCTION>
<NAME>html_text_magic_link</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLText           *text,HTMLEngine         *engine,guint               offset
</FUNCTION>
<FUNCTION>
<NAME>html_text_trail_space_width</NAME>
<RETURNS>gint  </RETURNS>
HTMLText           *text,HTMLPainter        *painter
</FUNCTION>
<FUNCTION>
<NAME>html_text_request_word_width</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text,HTMLPainter        *painter
</FUNCTION>
<FUNCTION>
<NAME>html_text_convert_nbsp</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLText           *text,gboolean           free_text
</FUNCTION>
<USER_FUNCTION>
<NAME>HTMLTextHelperFunc</NAME>
<RETURNS>HTMLObject *</RETURNS>
HTMLText *, gint begin, gint end
</USER_FUNCTION>
<FUNCTION>
<NAME>html_text_op_copy_helper</NAME>
<RETURNS>HTMLObject        *</RETURNS>
HTMLText           *text,GList              *from,GList              *to,guint              *len,HTMLTextHelperFunc  f
</FUNCTION>
<FUNCTION>
<NAME>html_text_op_cut_helper</NAME>
<RETURNS>HTMLObject        *</RETURNS>
HTMLText           *text,HTMLEngine         *e,GList              *from,GList              *to,GList              *left,GList              *right,guint              *len,HTMLTextHelperFunc  f
</FUNCTION>
<FUNCTION>
<NAME>html_text_clear_word_width</NAME>
<RETURNS>void  </RETURNS>
HTMLText           *text
</FUNCTION>
<MACRO>
<NAME>HTML_TEXTAREA</NAME>
#define HTML_TEXTAREA(x) ((HTMLTextArea *) (x))
</MACRO>
<MACRO>
<NAME>HTML_TEXTAREA_CLASS</NAME>
#define HTML_TEXTAREA_CLASS(x) ((HTMLTextAreaClass *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLTextArea</NAME>
struct HTMLTextArea {
	HTMLEmbedded element;

	GtkWidget *text;

	gchar *default_text;
};
</STRUCT>
<VARIABLE>
<NAME>html_textarea_class</NAME>
extern HTMLTextAreaClass html_textarea_class;
</VARIABLE>
<FUNCTION>
<NAME>html_textarea_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_textarea_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTextAreaClass *klass,HTMLType           type,guint              object_size
</FUNCTION>
<FUNCTION>
<NAME>html_textarea_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTextArea      *ti,HTMLTextAreaClass *klass,GtkWidget         *parent,gchar             *name,gint               r,gint               c
</FUNCTION>
<FUNCTION>
<NAME>html_textarea_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
GtkWidget         *parent,gchar             *name,gint               r,gint               c
</FUNCTION>
<FUNCTION>
<NAME>html_textarea_set_text</NAME>
<RETURNS>void  </RETURNS>
HTMLTextArea      *textarea,gchar             *text
</FUNCTION>
<MACRO>
<NAME>HTML_TEXTINPUT</NAME>
#define HTML_TEXTINPUT(x) ((HTMLTextInput *) (x))
</MACRO>
<MACRO>
<NAME>HTML_TEXTINPUT_CLASS</NAME>
#define HTML_TEXTINPUT_CLASS(x) ((HTMLTextInputClass *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLTextInput</NAME>
struct HTMLTextInput {
	HTMLEmbedded element;
	gint size, maxlen;
	gboolean password;

	gchar *default_text;
};
</STRUCT>
<VARIABLE>
<NAME>html_text_input_class</NAME>
extern HTMLTextInputClass html_text_input_class;
</VARIABLE>
<FUNCTION>
<NAME>html_text_input_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_text_input_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTextInputClass *klass,HTMLType            type,guint               object_size
</FUNCTION>
<FUNCTION>
<NAME>html_text_input_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTextInput      *ti,HTMLTextInputClass *klass,GtkWidget          *parent,gchar              *name,gchar              *value,gint                size,gint                maxlen,gboolean            password
</FUNCTION>
<FUNCTION>
<NAME>html_text_input_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
GtkWidget          *parent,gchar              *name,gchar              *value,gint                size,gint                maxlen,gboolean            password
</FUNCTION>
<MACRO>
<NAME>HTML_TEXT_SLAVE</NAME>
#define HTML_TEXT_SLAVE(x) ((HTMLTextSlave *) (x))
</MACRO>
<MACRO>
<NAME>HTML_TEXT_SLAVE_CLASS</NAME>
#define HTML_TEXT_SLAVE_CLASS(x) ((HTMLTextSlaveClass *) (x))
</MACRO>
<STRUCT>
<NAME>HTMLTextSlave</NAME>
struct HTMLTextSlave {
	HTMLObject object;

	HTMLText *owner;
	guint posStart;
	guint posLen;
	guint start_word;
};
</STRUCT>
<FUNCTION>
<NAME>html_text_slave_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_text_slave_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTextSlaveClass *klass,HTMLType            type,guint               object_size
</FUNCTION>
<FUNCTION>
<NAME>html_text_slave_init</NAME>
<RETURNS>void  </RETURNS>
HTMLTextSlave      *slave,HTMLTextSlaveClass *klass,HTMLText           *owner,guint               posStart,guint               posLen,guint               start_word
</FUNCTION>
<FUNCTION>
<NAME>html_text_slave_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
HTMLText           *owner,guint               posStart,guint               posLen,guint               start_word
</FUNCTION>
<MACRO>
<NAME>TAG_ESCAPE</NAME>
#define TAG_ESCAPE 13
</MACRO>
<MACRO>
<NAME>TAB_SIZE</NAME>
#define TAB_SIZE 8
</MACRO>
<FUNCTION>
<NAME>html_tokenizer_new</NAME>
<RETURNS>HTMLTokenizer  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_tokenizer_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLTokenizer *tokenizer
</FUNCTION>
<FUNCTION>
<NAME>html_tokenizer_begin</NAME>
<RETURNS>void  </RETURNS>
HTMLTokenizer *t,gchar *content_type
</FUNCTION>
<FUNCTION>
<NAME>html_tokenizer_write</NAME>
<RETURNS>void  </RETURNS>
HTMLTokenizer *t,const gchar *string,size_t size
</FUNCTION>
<FUNCTION>
<NAME>html_tokenizer_end</NAME>
<RETURNS>void  </RETURNS>
HTMLTokenizer *t
</FUNCTION>
<FUNCTION>
<NAME>html_tokenizer_peek_token</NAME>
<RETURNS>gchar  *</RETURNS>
HTMLTokenizer *t
</FUNCTION>
<FUNCTION>
<NAME>html_tokenizer_next_token</NAME>
<RETURNS>gchar  *</RETURNS>
HTMLTokenizer *t
</FUNCTION>
<FUNCTION>
<NAME>html_tokenizer_has_more_tokens</NAME>
<RETURNS>gboolean  </RETURNS>
HTMLTokenizer *t
</FUNCTION>
<FUNCTION>
<NAME>g_unichar_to_utf8</NAME>
<RETURNS>gint  </RETURNS>
gint c, gchar *outbuf
</FUNCTION>
<FUNCTION>
<NAME>html_types_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_type_name</NAME>
<RETURNS>const gchar  *</RETURNS>
HTMLType     type
</FUNCTION>
<FUNCTION>
<NAME>html_type_from_name</NAME>
<RETURNS>HTMLType  </RETURNS>
const gchar *name
</FUNCTION>
<STRUCT>
<NAME>HTMLObject</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLObjectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLAnchor</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLAnchorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLBlockStackElement</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLButton</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLButtonClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLCheckBox</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLCheckBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLClue</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLClueAligned</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLClueAlignedClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLClueClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLClueFlow</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLClueFlowClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLClueH</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLClueHClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLClueV</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLClueVClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLColor</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLColorSet</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLCursor</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLDrawQueue</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLDrawQueueClearElement</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLEmbedded</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLEmbeddedClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLEngine</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLEngineClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLEngineEditSelectionUpdater</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLEngineSaveState</NAME>
</STRUCT>
<TYPEDEF>
<NAME>HTMLFontFace</NAME>
typedef gchar HTMLFontFace;
</TYPEDEF>
<STRUCT>
<NAME>HTMLFont</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLFontManager</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLFontSet</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLForm</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLGdkPainter</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLGdkPainterClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLHidden</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLHiddenClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLHSpace</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLHSpaceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLIFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLIFrameClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLImage</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLImageAnimation</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLImageClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLImageFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLImageInput</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLImageInputClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLImagePointer</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLInterval</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLLinkText</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLLinkTextClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLList</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLPainter</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLPainterClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLPoint</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLPrinter</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLPrinterClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLRadio</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLRadioClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLReplace</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLRule</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLRuleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLSelect</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLSelectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLSearch</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLSettings</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLStack</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLStringTokenizer</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTable</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTableCell</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTableCellClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLText</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTextArea</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTextAreaClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTextClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTextInput</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTextInputClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTextSlave</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTextSlaveClass</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLTokenizer</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLUndo</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLUndoData</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLUndoAction</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLVSpace</NAME>
</STRUCT>
<STRUCT>
<NAME>HTMLVSpaceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>SpellError</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>HTMLObjectForallFunc</NAME>
<RETURNS>void </RETURNS>
HTMLObject        *self,
						 HTMLEngine        *e,
						 gpointer          data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>HTMLFontManagerAllocFont</NAME>
<RETURNS>gpointer </RETURNS>
gchar            *face_name,
						 gdouble           size,
						 GtkHTMLFontStyle  style
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>HTMLFontManagerRefFont</NAME>
<RETURNS>void </RETURNS>
gpointer          font
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>HTMLFontManagerUnrefFont</NAME>
<RETURNS>void </RETURNS>
gpointer          font
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>HTMLStackFreeFunc</NAME>
<RETURNS>void </RETURNS>
gpointer          data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>HTMLUndoFunc</NAME>
<RETURNS>void </RETURNS>
HTMLEngine        *engine,
						 HTMLUndoData      *data,
						 HTMLUndoDirection  dir
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>HTMLUndoDataDestroyFunc</NAME>
<RETURNS>void </RETURNS>
HTMLUndoData      *data
</USER_FUNCTION>
<TYPEDEF>
<NAME>HTMLEngineSaveReceiverFn</NAME>
typedef GtkHTMLSaveReceiverFn HTMLEngineSaveReceiverFn;
</TYPEDEF>
<MACRO>
<NAME>HTML_UNDO_ACTION</NAME>
#define HTML_UNDO_ACTION(x) ((HTMLUndoAction *) x)
</MACRO>
<STRUCT>
<NAME>HTMLUndoAction</NAME>
struct HTMLUndoAction {
	
	gchar *description;             /* A text description of the action, to be displayed in the menus.  */
	HTMLUndoFunc function;	        /* Function to call when the action is performed.  */
	HTMLUndoData *data;             /* Data to pass to the action function when it's called.  */
	guint position;                 /* Cursor position, to be set when the action is executed.  */
};
</STRUCT>
<FUNCTION>
<NAME>html_undo_action_new</NAME>
<RETURNS>HTMLUndoAction  *</RETURNS>
const gchar            *description,HTMLUndoFunc            function,HTMLUndoData           *data,guint                   position
</FUNCTION>
<FUNCTION>
<NAME>html_undo_action_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLUndoAction         *action
</FUNCTION>
<MACRO>
<NAME>HTML_UNDO_LIMIT</NAME>
#define HTML_UNDO_LIMIT 1024
</MACRO>
<STRUCT>
<NAME>HTMLUndo</NAME>
struct HTMLUndo {
	/* List of undo actions (HTMLUndoAction).  */
	GList *undo_stack;
	guint undo_stack_size;

	/* List of redo actions (HTMLUndoAction).  */
	GList *redo_stack;
	guint redo_stack_size;

	/* these lists are stacks containing other
	   levels undo/redo after calling html_undo_level_start */
	GSList *undo_levels;
	GSList *redo_levels;
	guint   undo_levels_size;
};
</STRUCT>
<MACRO>
<NAME>HTML_UNDO_DATA</NAME>
#define HTML_UNDO_DATA(x) ((HTMLUndoData *) x)
</MACRO>
<STRUCT>
<NAME>HTMLUndoData</NAME>
struct HTMLUndoData {
	HTMLUndoDataDestroyFunc destroy;
	gint ref_count;
};
</STRUCT>
<FUNCTION>
<NAME>html_undo_new</NAME>
<RETURNS>HTMLUndo           *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_undo_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLUndo          *undo
</FUNCTION>
<FUNCTION>
<NAME>html_undo_do_undo</NAME>
<RETURNS>void  </RETURNS>
HTMLUndo          *undo,HTMLEngine        *engine
</FUNCTION>
<FUNCTION>
<NAME>html_undo_do_redo</NAME>
<RETURNS>void  </RETURNS>
HTMLUndo          *undo,HTMLEngine        *engine
</FUNCTION>
<FUNCTION>
<NAME>html_undo_discard_redo</NAME>
<RETURNS>void  </RETURNS>
HTMLUndo          *undo
</FUNCTION>
<FUNCTION>
<NAME>html_undo_add_undo_action</NAME>
<RETURNS>void  </RETURNS>
HTMLUndo          *undo,HTMLUndoAction    *action
</FUNCTION>
<FUNCTION>
<NAME>html_undo_add_redo_action</NAME>
<RETURNS>void  </RETURNS>
HTMLUndo          *undo,HTMLUndoAction    *action
</FUNCTION>
<FUNCTION>
<NAME>html_undo_add_action</NAME>
<RETURNS>void  </RETURNS>
HTMLUndo          *undo,HTMLUndoAction    *action,HTMLUndoDirection  dir
</FUNCTION>
<FUNCTION>
<NAME>html_undo_level_begin</NAME>
<RETURNS>void  </RETURNS>
HTMLUndo          *undo,const gchar       *description
</FUNCTION>
<FUNCTION>
<NAME>html_undo_level_end</NAME>
<RETURNS>void  </RETURNS>
HTMLUndo          *undo
</FUNCTION>
<FUNCTION>
<NAME>html_undo_data_init</NAME>
<RETURNS>void  </RETURNS>
HTMLUndoData      *data
</FUNCTION>
<FUNCTION>
<NAME>html_undo_data_ref</NAME>
<RETURNS>void  </RETURNS>
HTMLUndoData      *data
</FUNCTION>
<FUNCTION>
<NAME>html_undo_data_unref</NAME>
<RETURNS>void  </RETURNS>
HTMLUndoData      *data
</FUNCTION>
<FUNCTION>
<NAME>html_undo_direction_reverse</NAME>
<RETURNS>HTMLUndoDirection  </RETURNS>
HTMLUndoDirection  dir
</FUNCTION>
<STRUCT>
<NAME>HTMLURL</NAME>
struct HTMLURL {
	gchar *protocol;
	gchar *username;
	gchar *password;
	gchar *hostname;
	guint16 port;
	gchar *path;
	gchar *reference;
};
</STRUCT>
<STRUCT>
<NAME>HTMLURL</NAME>
</STRUCT>
<FUNCTION>
<NAME>html_url_new</NAME>
<RETURNS>HTMLURL  *</RETURNS>
const gchar *s
</FUNCTION>
<FUNCTION>
<NAME>html_url_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLURL *url
</FUNCTION>
<FUNCTION>
<NAME>html_url_dup</NAME>
<RETURNS>HTMLURL  *</RETURNS>
const HTMLURL *url, HTMLURLDupFlags flags
</FUNCTION>
<FUNCTION>
<NAME>html_url_set_protocol</NAME>
<RETURNS>void  </RETURNS>
HTMLURL *url, const gchar *protocol
</FUNCTION>
<FUNCTION>
<NAME>html_url_set_username</NAME>
<RETURNS>void  </RETURNS>
HTMLURL *url, const gchar *username
</FUNCTION>
<FUNCTION>
<NAME>html_url_set_password</NAME>
<RETURNS>void  </RETURNS>
HTMLURL *url, const gchar *password
</FUNCTION>
<FUNCTION>
<NAME>html_url_set_hostname</NAME>
<RETURNS>void  </RETURNS>
HTMLURL *url, const gchar *password
</FUNCTION>
<FUNCTION>
<NAME>html_url_set_port</NAME>
<RETURNS>void  </RETURNS>
HTMLURL *url, gushort port
</FUNCTION>
<FUNCTION>
<NAME>html_url_set_path</NAME>
<RETURNS>void  </RETURNS>
HTMLURL *url, const gchar *path
</FUNCTION>
<FUNCTION>
<NAME>html_url_set_reference</NAME>
<RETURNS>void  </RETURNS>
HTMLURL *url, const gchar *reference
</FUNCTION>
<FUNCTION>
<NAME>html_url_get_protocol</NAME>
<RETURNS>const gchar  *</RETURNS>
const HTMLURL *url
</FUNCTION>
<FUNCTION>
<NAME>html_url_get_username</NAME>
<RETURNS>const gchar  *</RETURNS>
const HTMLURL *url
</FUNCTION>
<FUNCTION>
<NAME>html_url_get_password</NAME>
<RETURNS>const gchar  *</RETURNS>
const HTMLURL *url
</FUNCTION>
<FUNCTION>
<NAME>html_url_get_hostname</NAME>
<RETURNS>const gchar  *</RETURNS>
const HTMLURL *url
</FUNCTION>
<FUNCTION>
<NAME>html_url_get_port</NAME>
<RETURNS>gushort  </RETURNS>
const HTMLURL *url
</FUNCTION>
<FUNCTION>
<NAME>html_url_get_path</NAME>
<RETURNS>const gchar  *</RETURNS>
const HTMLURL *url
</FUNCTION>
<FUNCTION>
<NAME>html_url_get_reference</NAME>
<RETURNS>const gchar  *</RETURNS>
const HTMLURL *url
</FUNCTION>
<FUNCTION>
<NAME>html_url_to_string</NAME>
<RETURNS>gchar  *</RETURNS>
const HTMLURL *url
</FUNCTION>
<FUNCTION>
<NAME>html_url_append_path</NAME>
<RETURNS>HTMLURL  *</RETURNS>
const HTMLURL *url, const gchar *path
</FUNCTION>
<MACRO>
<NAME>HTML_VSPACE</NAME>
#define HTML_VSPACE(x) ((HTMLVSpace *)(x))
</MACRO>
<STRUCT>
<NAME>HTMLVSpace</NAME>
struct HTMLVSpace {
	HTMLObject object;
	HTMLClearType clear;
};
</STRUCT>
<VARIABLE>
<NAME>html_vspace_class</NAME>
extern HTMLVSpaceClass html_vspace_class;
</VARIABLE>
<FUNCTION>
<NAME>html_vspace_type_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>html_vspace_class_init</NAME>
<RETURNS>void  </RETURNS>
HTMLVSpaceClass *klass,HTMLType         type,guint            object_size
</FUNCTION>
<FUNCTION>
<NAME>html_vspace_init</NAME>
<RETURNS>void  </RETURNS>
HTMLVSpace      *vspace,HTMLVSpaceClass *klass,HTMLClearType    clear
</FUNCTION>
<FUNCTION>
<NAME>html_vspace_new</NAME>
<RETURNS>HTMLObject  *</RETURNS>
HTMLClearType    clear
</FUNCTION>
<MACRO>
<NAME>LEFT_BORDER</NAME>
#define LEFT_BORDER 10
</MACRO>
<MACRO>
<NAME>RIGHT_BORDER</NAME>
#define RIGHT_BORDER 10
</MACRO>
<MACRO>
<NAME>TOP_BORDER</NAME>
#define TOP_BORDER 10
</MACRO>
<MACRO>
<NAME>BOTTOM_BORDER</NAME>
#define BOTTOM_BORDER 10
</MACRO>
<STRUCT>
<NAME>HTMLParser</NAME>
struct HTMLParser {

	HTMLEngine *engine;

	gboolean parsing;
	HTMLTokenizer *ht;
	HTMLStringTokenizer *st;

	HTMLObject *clue;
	HTMLObject *flow;

	gint leftBorder;
	gint rightBorder;
	gint topBorder;
	gint bottomBorder;

	/* Current indentation level.  */
	guint indent_level;

	/* For the widget */
	gint width;
	gint height;

	HTMLHAlignType divAlign;

	/* Number of tokens parsed in the current time-slice */
	gint parseCount;
	gint granularity;

	gboolean inTitle;
	gboolean inPre;
	gboolean inOption;
	gboolean inTextArea;
	gboolean eat_space;

	gboolean newPage;
 
	HTMLStack *font_style_stack; /* Font style stack, elements are GtkHTMLFontStyles.  */
	HTMLStack *font_face_stack;
	HTMLStack *color_stack;	/* Color stack, elements are GdkColors.  */
	HTMLStack *clueflow_style_stack; /* Clueflow style stack, elements are HTMLClueFlowStyles.  */

	gchar *url;
	gchar *target;

	HTMLBlockStackElement *blockStack;

	/* timer id to schedule paint events */
	guint updateTimer;

	/* timer id for parsing routine */
	guint timerId;

	/* FIXME: replace with a `gchar *'?  */
	GString *title;

	gboolean writing;

	/* The background pixmap, an HTMLImagePointer */
        gpointer bgPixmapPtr;
  
	HTMLStack *listStack;     /* Stack of lists currently active */
	HTMLStack *embeddedStack; /* Stack of embedded "object"'s */
	HTMLStack *glossaryStack; /* HTMLGlossaryEntry */

	/*
	 * This list holds strings which are displayed in the view,
	 * but are not actually contained in the HTML source.
	 * e.g. The numbers in an ordered list.
	 * FIXME?
	 */
	GList *tempStrings;

	HTMLForm *form;
	HTMLSelect *formSelect;
	HTMLTextArea *formTextArea;
	GList *formList;
	GString *formText;
	gboolean noWrap;

	/* This is TRUE if we cannot insert a paragraph break (which is just an
           extra empty line).  It's set to FALSE as soon as some element is
           added to a flow.  The purpose is to avoid having paragraph breaks to
           be inserted in sequence, or after elements that have some vspace of
           their own.  */
	gboolean avoid_para;

	/* This is TRUE if we want a paragraph break to be inserted before the
           next element.  */
	gboolean pending_para;

	/* Alignment for the pending paragraph we are going to insert.  */
	HTMLHAlignType pending_para_alignment;
};
</STRUCT>
<FUNCTION>
<NAME>html_parser_new</NAME>
<RETURNS>HTMLParser     *</RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_parser_destroy</NAME>
<RETURNS>void  </RETURNS>
HTMLParser  *p
</FUNCTION>
<FUNCTION>
<NAME>html_parser_begin</NAME>
<RETURNS>GtkHTMLStream  *</RETURNS>
HTMLParser  *p,char        *content_type
</FUNCTION>
<FUNCTION>
<NAME>html_parser_run</NAME>
<RETURNS>void  </RETURNS>
HTMLParser  *p
</FUNCTION>
<FUNCTION>
<NAME>html_parser_stop</NAME>
<RETURNS>void  </RETURNS>
HTMLParser  *p
</FUNCTION>
<FUNCTION>
<NAME>html_engine_copy</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_cut</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_cut_line</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_delete</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_paste</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_paste_object</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e,HTMLObject  *o,guint        len
</FUNCTION>
<FUNCTION>
<NAME>html_engine_paste_text</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e,const gchar *text,guint        len
</FUNCTION>
<FUNCTION>
<NAME>html_engine_insert_text</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e,const gchar *text,guint        len
</FUNCTION>
<FUNCTION>
<NAME>html_engine_insert_object</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e,HTMLObject  *o,guint        len
</FUNCTION>
<FUNCTION>
<NAME>html_engine_insert_link</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e,const gchar *url,const gchar *target
</FUNCTION>
<FUNCTION>
<NAME>html_engine_insert_empty_paragraph</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e
</FUNCTION>
<FUNCTION>
<NAME>html_engine_delete_n</NAME>
<RETURNS>void  </RETURNS>
HTMLEngine  *e,guint        len,gboolean     forward
</FUNCTION>
