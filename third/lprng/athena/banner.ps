%!

% $Id: banner.ps,v 1.1 1999-04-05 16:06:33 mwhitson Exp $

% The following should be defined by a wrapper (such as banner.pl):

% /logo { } def

% /user (jrhacker) def
% /host (my-hostname-is-longer-than-yours) def
% /queuejob (nil:foobar.ps) def
% /date (Wednesday, August 8, 1998. 12:56:28 PM) def
% /motd (To find answers to common printing questions, type\n\033Courier     olc answers\n\033Times-Roman at the \033Courier athena%\033Times-Roman prompt, and choose \033Courier "PRINTING Answers"\033Times-Roman .) def
% /bannertype /random def

% XXX  We should find some better metric for determining paper size
/inchheight 11 def
/inchwidth 8.5 def

% end of banner.pl stuff

/inch { 72 mul } def

inchwidth inch 0 translate 90 rotate
/height inchwidth inch def
/width inchheight inch def

% Font to print the username in
/userfontsize 72 def
/userfont /Helvetica findfont userfontsize scalefont def

% Font for the motd
/motdfontsize 10 def
/motdfont /Times-Roman findfont motdfontsize scalefont def

% Font for the other info
/otherfontsize 12 def
/otherfont /Helvetica-Narrow findfont otherfontsize scalefont def

/newline {
  motdfontsize mul leftmargin exch currentpoint exch pop exch sub moveto
} bind def

/dofont {
  cvn motdfontsize selectfont
} bind def

% Measure a word
/measure {
  gsave
  (\033) search 			% post (\033) pre true OR string false
    { stringwidth pop exch pop exch	% prelen post
      ( ) search exch dofont		% prelen post ( ) true OR prelen false
        { pop measure add }
      if }
    { stringwidth pop }
  ifelse
  grestore
} bind def

% Write one word
/doword {
  dup measure currentpoint pop add rightmargin gt
    { currentpoint pop leftmargin ne { 1 newline } if }
  if

  currentpoint pop exch

  { (\033) search			% post (\033) pre true OR string false
      { show pop ( ) search exch dofont	% post ( ) true OR false
          { pop exch pop currentpoint pop exch }
          { exit }
        ifelse }
      { show exit }
    ifelse
  } loop

  % and write the following space if we wrote anything else
  currentpoint pop ne { ( ) show } if
} bind def

% Write out a paragraph
/parwrap {
  % split into words and write them one by one
  { ( ) search
      { dup length 0 eq { pop show } { doword pop } ifelse }
      { exit }
    ifelse }
  loop
  doword
} bind def

/innerwrap {
  % If text contains newline, parwrap first half, newline, and wrap
  % second half. if not, just parwrap whole thing.
  (\n) search
    { parwrap pop 1.75 newline innerwrap }
    { parwrap }
  ifelse
} bind def

% Wrap text
/wrap {
  exch /rightmargin exch def
  exch /leftmargin exch def
  (Times-Roman) dofont

  innerwrap
} bind def

% Write right-justified
/rshow {
  dup stringwidth pop -1 mul 0 rmoveto show
} bind def

/pagetop height .5 inch sub def
/pagebot .5 inch def
/pageleft .5 inch def
/pageright width .5 inch sub def
/hsplit pageleft pageright add 2 div def
/vsplit pagetop 1.5 inch sub def

/banner {
  % set clipping path
  gsave newpath
  pageleft pagetop moveto pageright pagetop lineto
  pageright vsplit lineto pageleft vsplit lineto pageleft pagetop lineto
  clip newpath

  % date
  pageleft pagetop otherfontsize sub moveto 
  otherfont setfont date show

  % logo
  pageleft hsplit .25 inch sub add 2 div vsplit pagetop add 2 div moveto
  gsave .75 setgray logo grestore

  % motd
  motdfont setfont
  pageleft pagetop otherfontsize motdfontsize 2 mul add sub moveto
  pageleft hsplit .25 inch sub motd wrap

  % vertical line
  hsplit pagetop moveto hsplit vsplit lineto stroke

  % username
  gsave
  pageright pagetop userfontsize .75 mul sub moveto
  userfont setfont 
  pageright hsplit .25 inch add sub dup user stringwidth pop lt
    { user stringwidth pop div 1 scale }
    { pop }
    ifelse
  user stringwidth pop -1 mul 0 rmoveto user show
  grestore

  otherfont setfont

  % host
  pageright pagetop userfontsize sub otherfontsize sub moveto
  host rshow

  % queue/job
  pageright pagetop userfontsize sub otherfontsize 2.2 mul sub moveto
  queuejob rshow

  % horizontal line
  pageleft vsplit moveto pageright vsplit lineto stroke

  % undo clipping path
  grestore

} bind def

% Draw graph paper
/graph {
  % left top right bottom spacing
  % left bottom right top spacing

  /spacing exch def
  /graphtop exch def
  /graphright exch def
  /graphbot exch def
  /graphleft exch def

  gsave 0 setlinewidth

  graphleft spacing graphright 
    { dup graphtop moveto graphbot lineto stroke } for

  graphtop spacing neg graphbot
    { dup graphleft exch moveto graphright exch lineto stroke } for

  grestore
} bind def

% Draw hex paper (from tlyu)
/s30 30 sin def
/c30 30 cos def
/hex{
	% llx lly urx ury spacing
	[/r/ury/urx/lly/llx]{exch def}forall
	gsave
	0 setlinewidth
	llx lly moveto urx lly lineto urx ury lineto llx ury lineto
	closepath clip newpath
	[r 2 r mul] 0 setdash
	lly 2 r c30 mul mul ury {
		dup llx exch moveto urx exch lineto stroke
	} for
	[r 2 r mul] 2 r mul r s30 mul sub setdash
	lly r c30 mul add 2 r c30 mul mul ury {
		dup llx exch moveto urx exch lineto stroke
	} for
	[r 2 r mul] r setdash
	lly urx llx sub r div 3 div cvi 3 r mul mul s30 div c30 mul sub
	2 r c30 mul mul ury {
		dup llx exch moveto
		ury exch sub c30 div s30 mul llx add ury lineto stroke
	} for
	lly 2 r c30 mul mul
	ury urx llx sub r div 3 div cvi 3 r mul mul s30 div c30 mul add
	{
		dup llx exch moveto
		llx sub c30 div s30 mul llx add lly lineto stroke
	} for
	grestore
} bind def

% Draw log-log graph paper (from tlyu)
/loglog {
	% llx lly urx ury spacing
	[/r /ury /urx /lly /llx] {exch def} forall
	0 setlinewidth
	/wd urx llx sub r div cvi r mul def /ht ury lly sub r div cvi r mul def
	llx r urx {lly moveto 0 ht rlineto stroke} for
	lly r ury {llx exch moveto wd 0 rlineto stroke} for
	[.5] 0 setdash
	/logvals [1 1 9 {log r mul} for] def
	llx r urx r sub {lly moveto 0 1 8 {
			logvals exch get
			gsave 0 rmoveto 0 ht rlineto stroke grestore
		} for
	} for
	lly r ury r sub {llx exch moveto 0 1 8 {
			logvals exch get
			gsave 0 exch rmoveto wd 0 rlineto stroke grestore
		} for
	} for
} bind def

% Draw polar graph paper (from tlyu)
/polar {
	% llx lly urx ury spacing
	[/r /ury /urx /lly /llx] {exch def} forall
	gsave
	0 setlinewidth
	/rmax urx llx sub 2 div dup ury lly sub 2 div dup 3 1 roll
	lt {pop} {exch pop} ifelse def
	urx llx sub 2 div llx add ury lly sub 2 div lly add translate
	0 r rmax {0 0 3 2 roll 0 360 arc stroke} for
	24 {15 rotate rmax neg 0 moveto rmax 0 lineto stroke} repeat
} bind def

% 1/8" graph paper
/dograph {
	gsave [.5] 0 setdash pageleft pagebot pageright vsplit .25 inch sub .125 inch graph grestore 
	pageleft pagebot pageright vsplit .25 inch sub .5 inch graph
} bind def

% 1/4" graph paper
/dobiggraph {
	gsave [.5] 0 setdash pageleft pagebot pageright vsplit .25 inch sub .25 inch graph grestore 
} bind def

% 1/8" hex grid paper
/dohex {
	/splittop vsplit .25 inch sub def
	pageleft pagebot pageright splittop .125 inch hex
	gsave 0 setlinewidth      % draw a box around the hex
	pageleft pagebot moveto pageleft splittop lineto pageright splittop lineto
	pageright pagebot lineto closepath stroke grestore
} bind def

% 1" log-log graph paper
/dologlog {
	pageleft pagebot pageright vsplit .25 inch sub 1 inch loglog
} bind def

% 1/8" polar graph paper
/dopolar {
	pageleft pagebot pageright vsplit .25 inch sub .125 inch polar
} bind def

% pick a random graph
/dorandom {
	statusdict/pagecount get exec srand    % Seed off the pagecount.
	[graphweights {{dup} repeat pop} forall] dup length
	rand exch mod get
	dup graphdict exch known {graphdict exch get exec} {dograph} ifelse
} bind def

% Map names (passed in by wrapper script) to functions
/graphdict << 
	/graph		{ dograph }
	/biggraph	{ dobiggraph }
        /hex		{ dohex }
	/loglog		{ dologlog }
	/polar		{ dopolar }
	/random		{ dorandom }
>> def

/graphweights <<
	/graph		7
	/biggraph	1
	/hex		1
	/loglog		1
	/polar		1
>> def

% print out the header information
banner

% look up the type of paper to print and do it.  Default to graph if the type is unknown.
graphdict bannertype known {
	graphdict bannertype get exec
} { 
	dorandom
} ifelse

showpage
