#! /bin/sh
## --------------------- ##
## M4sh Initialization.  ##
## --------------------- ##

# Be Bourne compatible
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
  set -o posix
fi

# Support unset when possible.
if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
  as_unset=unset
else
  as_unset=false
fi


# Work around bugs in pre-3.0 UWIN ksh.
$as_unset ENV MAIL MAILPATH
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
for as_var in LANG LANGUAGE LC_ALL LC_COLLATE LC_CTYPE LC_NUMERIC LC_MESSAGES LC_TIME
do
  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
    eval $as_var=C; export $as_var
  else
    $as_unset $as_var
  fi
done

# Required to use basename.
if expr a : '\(a\)' >/dev/null 2>&1; then
  as_expr=expr
else
  as_expr=false
fi

if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi


# Name of the executable.
as_me=`$as_basename "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)$' \| \
	 .     : '\(.\)' 2>/dev/null ||
echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
  	  /^X\/\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`


# PATH needs CR, and LINENO needs CR and PATH.
# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  echo "#! /bin/sh" >conftest.sh
  echo  "exit 0"   >>conftest.sh
  chmod +x conftest.sh
  if (PATH="/nonexistent;."; conftest.sh) >/dev/null 2>&1; then
    PATH_SEPARATOR=';'
  else
    PATH_SEPARATOR=:
  fi
  rm -f conftest.sh
fi


  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
  # Find who we are.  Look in the path if we contain no path at all
  # relative or not.
  case $0 in
    *[\\/]* ) as_myself=$0 ;;
    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
done

       ;;
  esac
  # We did not find ourselves, most probably we were run as `sh COMMAND'
  # in which case we are not to be found in the path.
  if test "x$as_myself" = x; then
    as_myself=$0
  fi
  if test ! -f "$as_myself"; then
    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
   { (exit 1); exit 1; }; }
  fi
  case $CONFIG_SHELL in
  '')
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  for as_base in sh bash ksh sh5; do
	 case $as_dir in
	 /*)
	   if ("$as_dir/$as_base" -c '
  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
	     CONFIG_SHELL=$as_dir/$as_base
	     export CONFIG_SHELL
	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
	   fi;;
	 esac
       done
done
;;
  esac

  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
  # uniformly replaced by the line number.  The first 'sed' inserts a
  # line-number line before each line; the second 'sed' does the real
  # work.  The second script uses 'N' to pair each line-number line
  # with the numbered line, and appends trailing '-' during
  # substitution so that $LINENO is not a special case at line end.
  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
  sed '=' <$as_myself |
    sed '
      N
      s,$,-,
      : loop
      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
      t loop
      s,-$,,
      s,^['$as_cr_digits']*\n,,
    ' >$as_me.lineno &&
  chmod +x $as_me.lineno ||
    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
   { (exit 1); exit 1; }; }

  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensible to this).
  . ./$as_me.lineno
  # Exit status is that of the last command.
  exit
}


case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
  *c*,-n*) ECHO_N= ECHO_C='
' ECHO_T='	' ;;
  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
esac

if expr a : '\(a\)' >/dev/null 2>&1; then
  as_expr=expr
else
  as_expr=false
fi

rm -f conf$$ conf$$.exe conf$$.file
echo >conf$$.file
if ln -s conf$$.file conf$$ 2>/dev/null; then
  # We could just check for DJGPP; but this test a) works b) is more generic
  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
  if test -f conf$$.exe; then
    # Don't use ln at all; we don't have any links
    as_ln_s='cp -p'
  else
    as_ln_s='ln -s'
  fi
elif ln conf$$.file conf$$ 2>/dev/null; then
  as_ln_s=ln
else
  as_ln_s='cp -p'
fi
rm -f conf$$ conf$$.exe conf$$.file

if mkdir -p . 2>/dev/null; then
  as_mkdir_p=:
else
  as_mkdir_p=false
fi

as_executable_p="test -f"

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"


# IFS
# We need space, tab and new line, in precisely that order.
as_nl='
'
IFS=" 	$as_nl"

# CDPATH.
$as_unset CDPATH

# PATH needs CR, and LINENO needs CR and PATH.
# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  echo "#! /bin/sh" >conftest.sh
  echo  "exit 0"   >>conftest.sh
  chmod +x conftest.sh
  if (PATH="/nonexistent;."; conftest.sh) >/dev/null 2>&1; then
    PATH_SEPARATOR=';'
  else
    PATH_SEPARATOR=:
  fi
  rm -f conftest.sh
fi


  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
  # Find who we are.  Look in the path if we contain no path at all
  # relative or not.
  case $0 in
    *[\\/]* ) as_myself=$0 ;;
    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
done

       ;;
  esac
  # We did not find ourselves, most probably we were run as `sh COMMAND'
  # in which case we are not to be found in the path.
  if test "x$as_myself" = x; then
    as_myself=$0
  fi
  if test ! -f "$as_myself"; then
    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
   { (exit 1); exit 1; }; }
  fi
  case $CONFIG_SHELL in
  '')
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  for as_base in sh bash ksh sh5; do
	 case $as_dir in
	 /*)
	   if ("$as_dir/$as_base" -c '
  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
	     CONFIG_SHELL=$as_dir/$as_base
	     export CONFIG_SHELL
	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
	   fi;;
	 esac
       done
done
;;
  esac

  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
  # uniformly replaced by the line number.  The first 'sed' inserts a
  # line-number line before each line; the second 'sed' does the real
  # work.  The second script uses 'N' to pair each line-number line
  # with the numbered line, and appends trailing '-' during
  # substitution so that $LINENO is not a special case at line end.
  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
  sed '=' <$as_myself |
    sed '
      N
      s,$,-,
      : loop
      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
      t loop
      s,-$,,
      s,^['$as_cr_digits']*\n,,
    ' >$as_me.lineno &&
  chmod +x $as_me.lineno ||
    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
   { (exit 1); exit 1; }; }

  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensible to this).
  . ./$as_me.lineno
  # Exit status is that of the last command.
  exit
}


case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
  *c*,-n*) ECHO_N= ECHO_C='
' ECHO_T='	' ;;
  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
esac

if expr a : '\(a\)' >/dev/null 2>&1; then
  as_expr=expr
else
  as_expr=false
fi

rm -f conf$$ conf$$.exe conf$$.file
echo >conf$$.file
if ln -s conf$$.file conf$$ 2>/dev/null; then
  # We could just check for DJGPP; but this test a) works b) is more generic
  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
  if test -f conf$$.exe; then
    # Don't use ln at all; we don't have any links
    as_ln_s='cp -p'
  else
    as_ln_s='ln -s'
  fi
elif ln conf$$.file conf$$ 2>/dev/null; then
  as_ln_s=ln
else
  as_ln_s='cp -p'
fi
rm -f conf$$ conf$$.exe conf$$.file

if mkdir -p . 2>/dev/null; then
  as_mkdir_p=:
else
  as_mkdir_p=false
fi

as_executable_p="test -f"

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"


# IFS
# We need space, tab and new line, in precisely that order.
as_nl='
'
IFS=" 	$as_nl"

# CDPATH.
$as_unset CDPATH



SHELL=${CONFIG_SHELL-/bin/sh}

# How were we run?
at_cli_args="$@"

# Load the config file.
for at_file in atconfig atlocal
do
  test -r $at_file || continue
  . ./$at_file || { echo "$as_me: error: invalid content: $at_file" >&2
   { (exit 1); exit 1; }; }
done

# atconfig delivers paths relative to the directory the test suite is
# in, but the groups themselves are run in testsuite-dir/group-dir.
if test -n "$at_top_srcdir"; then
  builddir=../..
  for at_dir in srcdir top_srcdir top_builddir
  do
    at_val=`eval echo '${'at_$at_dir'}'`
    eval "$at_dir=$at_val/../.."
  done
fi

# Not all shells have the 'times' builtin; the subshell is needed to make
# sure we discard the 'times: not found' message from the shell.
at_times_skip=:
(times) >/dev/null 2>&1 && at_times_skip=false

# CLI Arguments to pass to the debugging scripts.
at_debug_args=
# -e sets to true
at_errexit_p=false
# Shall we be verbose?
at_verbose=:
at_quiet=echo

# Shall we keep the debug scripts?  Must be `:' when the suite is
# run by a debug script, so that the script doesn't remove itself.
at_debug_p=false
# Display help message?
at_help_p=false
# List test groups?
at_list_p=false
# Test groups to run
at_groups=

# The directory we are in.
at_dir=`pwd`
# The directory the whole suite works in.
# Should be absolutely to let the user `cd' at will.
at_suite_dir=$at_dir/$as_me.dir
# The file containing the location of the last AT_CHECK.
at_check_line_file=$at_suite_dir/at-check-line
# The files containing the output of the tested commands.
at_stdout=$at_suite_dir/at-stdout
at_stder1=$at_suite_dir/at-stder1
at_stderr=$at_suite_dir/at-stderr
# The file containing dates.
at_times_file=$at_suite_dir/at-times

# List of the tested programs.
at_tested='bison'
# List of the all the test groups.
at_groups_all=' banner-1 1 2 3 4 banner-2 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 banner-3 21 22 23 banner-4 24 25 26 27 28 29 banner-5 30 31 32 33 34 banner-6 35 36 37 38 banner-7 39 40 41 banner-8 42 43 44 45 46 47 48 49 banner-9 50 51 52 53 54 55 56 57 58 59 60 banner-10 61 62 63 64 65 66 67 68 69 70 71 banner-11 72 73 74 75 76 banner-12 77 78 banner-13 79 80 81 82 83 84 85 86 87 88 banner-14 89 90 91 92 93 94 95 96 97'
# As many dots as there are digits in the last test group number.
# Used to normalize the test group numbers so that `ls' lists them in
# numerical order.
at_format='..'
# Description of all the test groups.
at_help_all=
at_help_all=$at_help_all'1;input.at:28;Invalid $n;
'
at_help_all=$at_help_all'2;input.at:46;Invalid @n;
'
at_help_all=$at_help_all'3;input.at:64;Type Clashes;
'
at_help_all=$at_help_all'4;input.at:93;Torturing the Scanner;
'
at_help_all=$at_help_all'5;output.at:38;Output files:  & -dv.;
'
at_help_all=$at_help_all'6;output.at:40;Output files:  & -dv -o foo.c.;
'
at_help_all=$at_help_all'7;output.at:42;Output files:  & -dv -o foo.tab.c.;
'
at_help_all=$at_help_all'8;output.at:44;Output files:  & -dv -y.;
'
at_help_all=$at_help_all'9;output.at:46;Output files:  & -dv -b bar.;
'
at_help_all=$at_help_all'10;output.at:48;Output files:  & -dv -g -o foo.c.;
'
at_help_all=$at_help_all'11;output.at:52;Output files: %defines %verbose & .;
'
at_help_all=$at_help_all'12;output.at:54;Output files: %defines %verbose %yacc & .;
'
at_help_all=$at_help_all'13;output.at:57;Output files: %defines %verbose %yacc & .;
'
at_help_all=$at_help_all'14;output.at:61;Output files: %file-prefix="bar" %defines %verbose & .;
'
at_help_all=$at_help_all'15;output.at:63;Output files: %output="bar.c" %defines %verbose %yacc & .;
'
at_help_all=$at_help_all'16;output.at:67;Output files: %file-prefix="baz" %output="bar.c" %defines %verbose %yacc & .;
'
at_help_all=$at_help_all'17;output.at:72;Output files: %defines %verbose & .;
'
at_help_all=$at_help_all'18;output.at:75;Output files: %defines %verbose  & -o foo.c.;
'
at_help_all=$at_help_all'19;output.at:79;Output files:  & --defines=foo.hpp -o foo.c++.;
'
at_help_all=$at_help_all'20;output.at:83;Output files:  & -o foo.c++ --graph=foo.gph.;
'
at_help_all=$at_help_all'21;sets.at:66;Nullable;
'
at_help_all=$at_help_all'22;sets.at:151;Broken Closure;
'
at_help_all=$at_help_all'23;sets.at:193;Firsts;
'
at_help_all=$at_help_all'24;reduce.at:26;Useless Terminals;
'
at_help_all=$at_help_all'25;reduce.at:70;Useless Nonterminals;
'
at_help_all=$at_help_all'26;reduce.at:125;Useless Rules;report
'
at_help_all=$at_help_all'27;reduce.at:212;Reduced Automaton;report
'
at_help_all=$at_help_all'28;reduce.at:301;Underivable Rules;report
'
at_help_all=$at_help_all'29;reduce.at:342;Empty Language;
'
at_help_all=$at_help_all'30;synclines.at:91;Prologue synch line;
'
at_help_all=$at_help_all'31;synclines.at:110;%union synch line;
'
at_help_all=$at_help_all'32;synclines.at:133;Postprologue synch line;
'
at_help_all=$at_help_all'33;synclines.at:152;Action synch line;
'
at_help_all=$at_help_all'34;synclines.at:170;Epilogue synch line;
'
at_help_all=$at_help_all'35;headers.at:27;%union and --defines;
'
at_help_all=$at_help_all'36;headers.at:71;Invalid CPP guards: input/input;
'
at_help_all=$at_help_all'37;headers.at:72;Invalid CPP guards: 9foo;
'
at_help_all=$at_help_all'38;headers.at:81;export YYLTYPE;
'
at_help_all=$at_help_all'39;actions.at:25;Mid-rule actions;
'
at_help_all=$at_help_all'40;actions.at:89;Exotic Dollars;
'
at_help_all=$at_help_all'41;actions.at:160;Printers and Destructors;
'
at_help_all=$at_help_all'42;conflicts.at:31;S/R in initial;
'
at_help_all=$at_help_all'43;conflicts.at:51;%nonassoc and eof;
'
at_help_all=$at_help_all'44;conflicts.at:134;Unresolved SR Conflicts;report
'
at_help_all=$at_help_all'45;conflicts.at:241;Resolved SR Conflicts;report
'
at_help_all=$at_help_all'46;conflicts.at:363;Defaulted Conflicted Reduction;report
'
at_help_all=$at_help_all'47;conflicts.at:482;%expect not enough;
'
at_help_all=$at_help_all'48;conflicts.at:502;%expect right;
'
at_help_all=$at_help_all'49;conflicts.at:519;%expect too much;
'
at_help_all=$at_help_all'50;calc.at:449;Calculator ;
'
at_help_all=$at_help_all'51;calc.at:451;Calculator --defines;
'
at_help_all=$at_help_all'52;calc.at:452;Calculator --locations;
'
at_help_all=$at_help_all'53;calc.at:453;Calculator --name-prefix=calc;
'
at_help_all=$at_help_all'54;calc.at:454;Calculator --verbose;
'
at_help_all=$at_help_all'55;calc.at:455;Calculator --yacc;
'
at_help_all=$at_help_all'56;calc.at:456;Calculator %error-verbose;
'
at_help_all=$at_help_all'57;calc.at:458;Calculator %error-verbose --locations;
'
at_help_all=$at_help_all'58;calc.at:460;Calculator %error-verbose --defines --locations --name-prefix=calc --verbose --yacc;
'
at_help_all=$at_help_all'59;calc.at:462;Calculator %debug;
'
at_help_all=$at_help_all'60;calc.at:463;Calculator %error-verbose %debug --defines --locations --name-prefix=calc --verbose --yacc;
'
at_help_all=$at_help_all'61;calc.at:480;Calculator %glr_parser ;
'
at_help_all=$at_help_all'62;calc.at:482;Calculator %glr_parser --defines;
'
at_help_all=$at_help_all'63;calc.at:483;Calculator %glr_parser --locations;
'
at_help_all=$at_help_all'64;calc.at:484;Calculator %glr_parser --name-prefix=calc;
'
at_help_all=$at_help_all'65;calc.at:485;Calculator %glr_parser --verbose;
'
at_help_all=$at_help_all'66;calc.at:486;Calculator %glr_parser --yacc;
'
at_help_all=$at_help_all'67;calc.at:487;Calculator %glr_parser %error-verbose;
'
at_help_all=$at_help_all'68;calc.at:489;Calculator %glr_parser %error-verbose --locations;
'
at_help_all=$at_help_all'69;calc.at:491;Calculator %glr_parser %error-verbose --defines --locations --name-prefix=calc --verbose --yacc;
'
at_help_all=$at_help_all'70;calc.at:493;Calculator %glr_parser %debug;
'
at_help_all=$at_help_all'71;calc.at:494;Calculator %glr_parser %error-verbose %debug --defines --locations --name-prefix=calc --verbose --yacc;
'
at_help_all=$at_help_all'72;torture.at:140;Big triangle;
'
at_help_all=$at_help_all'73;torture.at:231;Big horizontal;
'
at_help_all=$at_help_all'74;torture.at:367;Many lookaheads;
'
at_help_all=$at_help_all'75;torture.at:441;Exploding the Stack Size with Alloca;
'
at_help_all=$at_help_all'76;torture.at:462;Exploding the Stack Size with Malloc;
'
at_help_all=$at_help_all'77;existing.at:24;GNU AWK Grammar;
'
at_help_all=$at_help_all'78;existing.at:364;GNU Cim Grammar;
'
at_help_all=$at_help_all'79;regression.at:27;Early token definitions;
'
at_help_all=$at_help_all'80;regression.at:65;Braces parsing;
'
at_help_all=$at_help_all'81;regression.at:87;Duplicate string;
'
at_help_all=$at_help_all'82;regression.at:113;Rule Line Numbers;report
'
at_help_all=$at_help_all'83;regression.at:257;Mixing %token styles;
'
at_help_all=$at_help_all'84;regression.at:280;Invalid inputs;
'
at_help_all=$at_help_all'85;regression.at:313;Token definitions;
'
at_help_all=$at_help_all'86;regression.at:341;Characters Escapes;
'
at_help_all=$at_help_all'87;regression.at:371;Web2c Report;report
'
at_help_all=$at_help_all'88;regression.at:548;Web2c Actions;report
'
at_help_all=$at_help_all'89;cxx-type.at:226;GLR: Resolve ambiguity, impure, no locations;
'
at_help_all=$at_help_all'90;cxx-type.at:232;GLR: Resolve ambiguity, impure, locations;
'
at_help_all=$at_help_all'91;cxx-type.at:238;GLR: Resolve ambiguity, pure, no locations;
'
at_help_all=$at_help_all'92;cxx-type.at:244;GLR: Resolve ambiguity, pure, locations;
'
at_help_all=$at_help_all'93;cxx-type.at:252;GLR: Merge conflicting parses, impure, no locations;
'
at_help_all=$at_help_all'94;cxx-type.at:259;GLR: Merge conflicting parses, impure, locations;
'
at_help_all=$at_help_all'95;cxx-type.at:266;GLR: Merge conflicting parses, pure, no locations;
'
at_help_all=$at_help_all'96;cxx-type.at:272;GLR: Merge conflicting parses, pure, locations;
'
at_help_all=$at_help_all'97;cxx-type.at:280;GLR: Verbose messages, resolve ambiguity, impure, no locations;
'



while test $# -gt 0; do
  case $1 in
    --help | -h )
        at_help_p=:
        ;;

    --list | -l )
        at_list_p=:
        ;;

    --version | -V )
        echo "$as_me (GNU Bison 1.50a)"
        exit 0
        ;;

    --clean | -c )
        rm -rf $at_suite_dir $as_me.log
        exit 0
        ;;

    --debug | -d )
        at_debug_p=:
        ;;

    --errexit | -e )
        at_debug_p=:
        at_errexit_p=:
        ;;

    --verbose | -v )
        at_verbose=echo; at_quiet=:
        ;;

    --trace | -x )
        at_traceon='set -vx'; at_traceoff='set +vx'
        ;;

    [0-9] | [0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9][0-9][0-9])
        at_groups="$at_groups$1 "
        ;;

    # Ranges
    [0-9]- | [0-9][0-9]- | [0-9][0-9][0-9]- | [0-9][0-9][0-9][0-9]-)
        at_range_start=`echo $1 |tr -d '-'`
        at_range=`echo " $at_groups_all " | \
          sed -e 's,^.* '$at_range_start' ,'$at_range_start' ,'`
        at_groups="$at_groups$at_range "
        ;;

    -[0-9] | -[0-9][0-9] | -[0-9][0-9][0-9] | -[0-9][0-9][0-9][0-9])
        at_range_end=`echo $1 |tr -d '-'`
        at_range=`echo " $at_groups_all " | \
          sed -e 's, '$at_range_end' .*$, '$at_range_end','`
        at_groups="$at_groups$at_range "
        ;;

    [0-9]-[0-9] | [0-9]-[0-9][0-9] | [0-9]-[0-9][0-9][0-9] | \
    [0-9]-[0-9][0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9] | \
    [0-9][0-9]-[0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] )
        at_range_start=`echo $1 |sed 's,-.*,,'`
        at_range_end=`echo $1 |sed 's,.*-,,'`
        # FIXME: Maybe test to make sure start <= end?
        at_range=`echo " $at_groups_all " | \
          sed -e 's,^.* '$at_range_start' ,'$at_range_start' ,' \
              -e 's, '$at_range_end' .*$, '$at_range_end','`
        at_groups="$at_groups$at_range "
        ;;

    # Keywords.
    --keywords | -k )
        shift
        at_groups_selected=$at_help_all
        for at_keyword in `IFS=,; set X $1; shift; echo ${1+$@}`
        do
          # It is on purpose that we match the test group titles too.
          at_groups_selected=`echo "$at_groups_selected" |
			      grep -i "^[^;]*;[^;]*;.*$at_keyword"`
        done
        at_groups_selected=`echo "$at_groups_selected" | sed 's/;.*//'`
	# Smash the end of lines.
	at_groups_selected=`echo $at_groups_selected`
        at_groups="$at_groups$at_groups_selected "
        ;;

    *=*)
  	at_envvar=`expr "x$1" : 'x\([^=]*\)='`
  	# Reject names that are not valid shell variable names.
  	expr "x$at_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
  	  { echo "$as_me: error: invalid variable name: $at_envvar" >&2
   { (exit 1); exit 1; }; }
  	at_value=`expr "x$1" : 'x[^=]*=\(.*\)'`
  	at_value=`echo "$at_value" | sed "s/'/'\\\\\\\\''/g"`
  	eval "$at_envvar='$at_value'"
  	export $at_envvar
	# Propagate to debug scripts.
  	at_debug_args="$at_debug_args $1"
  	;;

     *) echo "$as_me: invalid option: $1" >&2
        echo "Try \`$0 --help' for more information." >&2
        exit 1
        ;;
  esac
  shift
done

# Selected test groups.
test -z "$at_groups" && at_groups=$at_groups_all

# Help message.
if $at_help_p; then
  cat <<_ATEOF
Usage: $0 [OPTION]... [VARIABLE=VALUE]... [TESTS]

Run all the tests, or the selected TESTS, and save a detailed log file.
Upon failure, create debugging scripts.

You should not change environment variables unless explicitly passed
as command line arguments.  Set \`AUTOTEST_PATH' to select the executables
to exercise.  Each relative directory is expanded as build and source
directories relatively to the top level of this distribution.  E.g.,

  $ $0 AUTOTEST_PATH=bin

possibly amounts into

  PATH=/tmp/foo-1.0/bin:/src/foo-1.0/bin:\$PATH

Operation modes:
  -h, --help     print the help message, then exit
  -V, --version  print version number, then exit
  -c, --clean    remove all the files this test suite might create and exit
  -l, --list     describes all the tests, or the selected TESTS

Execution tuning:
  -k, --keywords=KEYWORDS
                 select the tests matching all the comma separated KEYWORDS
                 accumulates
  -e, --errexit  abort as soon as a test fails; implies --debug
  -v, --verbose  force more detailed output
                 default for debugging scripts
  -d, --debug    inhibit clean up and debug script creation
                 default for debugging scripts
  -x, --trace    enable tests shell tracing

Report bugs to <bug-bison@gnu.org>.
_ATEOF
  exit 0
fi

# List of tests.
if $at_list_p; then
  cat <<_ATEOF
GNU Bison 1.50a test suite test groups:

 NUM: FILENAME:LINE      TEST-GROUP-NAME
      KEYWORDS

_ATEOF
  # "  1 42  45 " => "^(1|42|45);".
  at_groups_pattern=`echo "$at_groups" | sed 's/^  *//;s/  *$//;s/  */|/g'`
  echo "$at_help_all" |
    awk 'BEGIN { FS = ";" }
         { if ($1 !~ /^('"$at_groups_pattern"')$/) next }
         { if ($1) printf " %3d: %-18s %s\n", $1, $2, $3
           if ($4) printf "      %s\n", $4 } '
  exit 0
fi

# Don't take risks: use only absolute directories in PATH.
#
# For stand-alone test suites, AUTOTEST_PATH is relative to `.'.
#
# For embedded test suites, AUTOTEST_PATH is relative to the top level
# of the package.  Then expand it into build/src parts, since users
# may create executables in both places.
#
# There might be directories that don't exist, but don't redirect
# builtins' (eg., cd) stderr directly: Ultrix's sh hates that.
AUTOTEST_PATH=`echo $AUTOTEST_PATH | tr ':' $PATH_SEPARATOR`
at_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $AUTOTEST_PATH $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  case $as_dir in
  [\\/]* | ?:[\\/]* )
    at_path=$at_path$PATH_SEPARATOR$as_dir
    ;;
  * )
    if test -z "$at_top_builddir"; then
      # Stand-alone test suite.
      at_path=$at_path$PATH_SEPARATOR$as_dir
    else
      # Embedded test suite.
      at_path=$at_path$PATH_SEPARATOR$at_top_builddir/$as_dir
      at_path=$at_path$PATH_SEPARATOR$at_top_srcdir/$as_dir
    fi
    ;;
esac
done


# Now build and simplify PATH.
PATH=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $at_path
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  as_dir=`(cd "$as_dir" && pwd) 2>/dev/null`
test -d "$as_dir" || continue
case $PATH in
                  $as_dir                 | \
                  $as_dir$PATH_SEPARATOR* | \
  *$PATH_SEPARATOR$as_dir                 | \
  *$PATH_SEPARATOR$as_dir$PATH_SEPARATOR* ) ;;

  '') PATH=$as_dir ;;
   *) PATH=$PATH$PATH_SEPARATOR$as_dir ;;
esac
done

export PATH

# Setting up the FDs.
# 5 is stdout conditioned by verbosity.
if test $at_verbose = echo; then
  exec 5>&1
else
  exec 5>/dev/null
fi

# 6 is the log file.  To be preserved if `-d'.

if $at_debug_p; then
  exec 6>/dev/null
else
  exec 6>$as_me.log
fi

# Banners and logs.
cat <<\_ASBOX
## --------------------------- ##
## GNU Bison 1.50a test suite. ##
## --------------------------- ##
_ASBOX
{
  cat <<\_ASBOX
## --------------------------- ##
## GNU Bison 1.50a test suite. ##
## --------------------------- ##
_ASBOX
  echo

  echo "$as_me: command line was:"
  echo "  $ $0 $at_cli_args"
  echo

  # Try to find a few ChangeLogs in case it might help determining the
  # exact version.  Use the relative dir: if the top dir is a symlink,
  # find will not follow it (and options to follow the links are not
  # portable), which would result in no output here.
  if test -n "$at_top_srcdir"; then
    cat <<\_ASBOX
## ----------- ##
## ChangeLogs. ##
## ----------- ##
_ASBOX
    echo
    for at_file in `find "$at_top_srcdir" -name ChangeLog -print`
    do
      echo "$as_me: $at_file:"
      sed 's/^/| /;10q' $at_file
      echo
    done

    {
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  echo "PATH: $as_dir"
done

}
    echo
  fi

  # Contents of the config files.
  for at_file in atconfig atlocal
  do
    test -r $at_file || continue
    echo "$as_me: $at_file:"
    sed 's/^/| /' $at_file
    echo
  done

  cat <<\_ASBOX
## ---------------- ##
## Tested programs. ##
## ---------------- ##
_ASBOX
  echo
} >&6

# Report what programs are being tested.
for at_program in : $at_tested
do
  test "$at_program" = : && continue
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -f $as_dir/$at_program && break
done

  if test -f $as_dir/$at_program; then
    {
      echo "testsuite.at:39: $as_dir/$at_program --version"
      $as_dir/$at_program --version
      echo
    } >&6 2>&1
  else
    { { echo "$as_me:$LINENO: error: cannot find $at_program" >&6
echo "$as_me: error: cannot find $at_program" >&2;}
   { (exit 1); exit 1; }; }
  fi
done

{
  cat <<\_ASBOX
## --------------------------- ##
## Silently running the tests. ##
## --------------------------- ##
_ASBOX
} >&6

at_start_date=`date`
at_start_time=`(date +%s) 2>/dev/null`
echo "$as_me: starting at: $at_start_date" >&6
at_pass_list=
at_fail_list=
at_skip_list=
at_group_count=0

# Create the master directory if it doesn't already exist.
test -d $at_suite_dir ||
  mkdir $at_suite_dir ||
  { { echo "$as_me:$LINENO: error: cannot create $at_suite_dir" >&6
echo "$as_me: error: cannot create $at_suite_dir" >&2;}
   { (exit 1); exit 1; }; }

# Can we diff with `/dev/null'?  DU 5.0 refuses.
if diff /dev/null /dev/null >/dev/null 2>&1; then
  at_devnull=/dev/null
else
  at_devnull=$at_suite_dir/devnull
  cp /dev/null $at_devnull
fi

# Use `diff -u' when possible.
if diff -u $at_devnull $at_devnull >/dev/null 2>&1; then
  at_diff='diff -u'
else
  at_diff=diff
fi


for at_group in $at_groups
do
  # Be sure to come back to the top test directory.
  cd $at_suite_dir

  case $at_group in
    banner-*) ;;
    *)
     # Skip tests we already run (using --keywords makes it easy to get
     # duplication).
     case " $at_pass_test $at_skip_test $at_fail_test " in
       *" $at_group "* ) continue;;
     esac

     # Normalize the test group number.
     at_group_normalized=`expr "00000$at_group" : ".*\($at_format\)"`

     # Create a fresh directory for the next test group, and enter.
     at_group_dir=$at_suite_dir/$at_group_normalized
     rm -rf $at_group_dir
     mkdir $at_group_dir ||
       { { echo "$as_me:$LINENO: error: cannot create $at_group_dir" >&6
echo "$as_me: error: cannot create $at_group_dir" >&2;}
   { (exit 1); exit 1; }; }
     cd $at_group_dir
    ;;
  esac

  at_status=0
  # Clearly separate the test groups when verbose.
  test $at_group_count != 0 && $at_verbose
  case $at_group in

  banner-1 ) # Banner 1. input.at:19
    cat <<\_ATEOF

Input Processing.

_ATEOF
    ;;

  1 ) # 1. input.at:28: Invalid $n
    at_setup_line='input.at:28'
    $at_verbose "1. input.at:28: testing Invalid $n..."
    $at_quiet $ECHO_N "  1: input.at:28       $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%%
exp: { $$ = $1 ; };
_ATEOF


$at_traceoff
$at_verbose "input.at:37: bison input.y"
echo input.at:37 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:2.6-14: invalid value: \$1
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "input.at:37: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  2 ) # 2. input.at:46: Invalid @n
    at_setup_line='input.at:46'
    $at_verbose "2. input.at:46: testing Invalid @n..."
    $at_quiet $ECHO_N "  2: input.at:46       $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%%
exp: { @$ = @1 ; };
_ATEOF


$at_traceoff
$at_verbose "input.at:55: bison input.y"
echo input.at:55 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:2.6-14: invalid value: @1
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "input.at:55: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  3 ) # 3. input.at:64: Type Clashes
    at_setup_line='input.at:64'
    $at_verbose "3. input.at:64: testing Type Clashes..."
    $at_quiet $ECHO_N "  3: input.at:64       $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%token foo
%type <bar> exp
%%
exp: foo {} foo
   | foo
   | /* Empty. */
   ;
_ATEOF


$at_traceoff
$at_verbose "input.at:80: bison input.y"
echo input.at:80 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:4.4-15: type clash (\`bar' \`') on default action
input.y:5.4-8: type clash (\`bar' \`') on default action
input.y:6.4: empty rule for typed nonterminal, and no action
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "input.at:80: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  4 ) # 4. input.at:93: Torturing the Scanner
    at_setup_line='input.at:93'
    $at_verbose "4. input.at:93: testing Torturing the Scanner..."
    $at_quiet $ECHO_N "  4: input.at:93       $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%{
/* This is seen in GCC: a %{ and %} in middle of a comment. */
const char *foo = "So %{ and %} can be here too.";

#include <stdio.h>
%}
/* %{ and %} can be here too. */

%{
/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;
%}

/* Exercise M4 quoting: ']]', 0.  */

/* Also exercise %union. */
%union
{
  value_t ival; /* A comment to exercise an old bug. */
};


/* Exercise post-prologue dependency to %union.  */
%{
static YYSTYPE value_t_as_yystype (value_t val);

/* Exercise quotes in declarations.  */
char quote[] = "]],";
%}

%{
static void yyerror (const char *s);
static int yylex (void);
%}

%type <ival> '1'

/* Exercise quotes in strings.  */
%token FAKE "fake [],"

%%
/* Exercise M4 quoting: ']]', 1.  */
exp: '1'
  {
    /* Exercise quotes in braces.  */
    char tmp[] = "[%c],\n";
    printf (tmp, $1);
  }
;
%%
/* Exercise M4 quoting: ']]', 2.  */

static YYSTYPE
value_t_as_yystype (value_t val)
{
  YYSTYPE res;
  res.ival = val;
  return res;
}

static int
yylex (void)
{
  static const char *input = "1";
  yylval = value_t_as_yystype (*input);
  return *input++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}
_ATEOF


cat >main.c <<'_ATEOF'
typedef int value_t;
#include "input.h"

int yyparse (void);

int
main (void)
{
  return yyparse ();
}
_ATEOF


$at_traceoff
$at_verbose "input.at:184: bison -d -v -o input.c input.y"
echo input.at:184 >$at_check_line_file
( $at_traceon; bison -d -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "input.at:184: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "input.at:185: \$CC \$CFLAGS \$CPPFLAGS input.c main.c -o input"
echo input.at:185 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c main.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "input.at:185: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "input.at:188: \$PREPARSER ./input"
echo input.at:188 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "[1],
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "input.at:188: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-2 ) # Banner 2. output.at:19
    cat <<\_ATEOF

Output file names.

_ATEOF
    ;;

  5 ) # 5. output.at:38: Output files:  & -dv.
    at_setup_line='output.at:38'
    $at_verbose "5. output.at:38: testing Output files:  & -dv...."
    $at_quiet $ECHO_N "  5: output.at:38      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:38: bison -dv foo.y"
echo output.at:38 >$at_check_line_file
( $at_traceon; bison -dv foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:38: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:38: ls foo.output foo.tab.c foo.tab.h"
echo output.at:38 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:38: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  6 ) # 6. output.at:40: Output files:  & -dv -o foo.c.
    at_setup_line='output.at:40'
    $at_verbose "6. output.at:40: testing Output files:  & -dv -o foo.c...."
    $at_quiet $ECHO_N "  6: output.at:40      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:40: bison -dv -o foo.c foo.y"
echo output.at:40 >$at_check_line_file
( $at_traceon; bison -dv -o foo.c foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:40: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:40: ls foo.c foo.h foo.output"
echo output.at:40 >$at_check_line_file
( $at_traceon; ls foo.c foo.h foo.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:40: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  7 ) # 7. output.at:42: Output files:  & -dv -o foo.tab.c.
    at_setup_line='output.at:42'
    $at_verbose "7. output.at:42: testing Output files:  & -dv -o foo.tab.c...."
    $at_quiet $ECHO_N "  7: output.at:42      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:42: bison -dv -o foo.tab.c foo.y"
echo output.at:42 >$at_check_line_file
( $at_traceon; bison -dv -o foo.tab.c foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:42: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:42: ls foo.output foo.tab.c foo.tab.h"
echo output.at:42 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:42: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  8 ) # 8. output.at:44: Output files:  & -dv -y.
    at_setup_line='output.at:44'
    $at_verbose "8. output.at:44: testing Output files:  & -dv -y...."
    $at_quiet $ECHO_N "  8: output.at:44      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:44: bison -dv -y foo.y"
echo output.at:44 >$at_check_line_file
( $at_traceon; bison -dv -y foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:44: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:44: ls y.output y.tab.c y.tab.h"
echo output.at:44 >$at_check_line_file
( $at_traceon; ls y.output y.tab.c y.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:44: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  9 ) # 9. output.at:46: Output files:  & -dv -b bar.
    at_setup_line='output.at:46'
    $at_verbose "9. output.at:46: testing Output files:  & -dv -b bar...."
    $at_quiet $ECHO_N "  9: output.at:46      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:46: bison -dv -b bar foo.y"
echo output.at:46 >$at_check_line_file
( $at_traceon; bison -dv -b bar foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:46: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:46: ls bar.output bar.tab.c bar.tab.h"
echo output.at:46 >$at_check_line_file
( $at_traceon; ls bar.output bar.tab.c bar.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:46: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  10 ) # 10. output.at:48: Output files:  & -dv -g -o foo.c.
    at_setup_line='output.at:48'
    $at_verbose "10. output.at:48: testing Output files:  & -dv -g -o foo.c...."
    $at_quiet $ECHO_N " 10: output.at:48      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:48: bison -dv -g -o foo.c foo.y"
echo output.at:48 >$at_check_line_file
( $at_traceon; bison -dv -g -o foo.c foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:48: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:48: ls foo.c foo.h foo.output foo.vcg"
echo output.at:48 >$at_check_line_file
( $at_traceon; ls foo.c foo.h foo.output foo.vcg ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:48: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  11 ) # 11. output.at:52: Output files: %defines %verbose & .
    at_setup_line='output.at:52'
    $at_verbose "11. output.at:52: testing Output files: %defines %verbose & ...."
    $at_quiet $ECHO_N " 11: output.at:52      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:52: bison  foo.y"
echo output.at:52 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:52: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:52: ls foo.output foo.tab.c foo.tab.h"
echo output.at:52 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:52: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  12 ) # 12. output.at:54: Output files: %defines %verbose %yacc & .
    at_setup_line='output.at:54'
    $at_verbose "12. output.at:54: testing Output files: %defines %verbose %yacc & ...."
    $at_quiet $ECHO_N " 12: output.at:54      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:54: bison  foo.y"
echo output.at:54 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:54: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:54: ls y.output y.tab.c y.tab.h"
echo output.at:54 >$at_check_line_file
( $at_traceon; ls y.output y.tab.c y.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:54: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  13 ) # 13. output.at:57: Output files: %defines %verbose %yacc & .
    at_setup_line='output.at:57'
    $at_verbose "13. output.at:57: testing Output files: %defines %verbose %yacc & ...."
    $at_quiet $ECHO_N " 13: output.at:57      $ECHO_C"
    (
      $at_traceon

cat >foo.yy <<'_ATEOF'
%defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:57: bison  foo.yy"
echo output.at:57 >$at_check_line_file
( $at_traceon; bison  foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:57: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:57: ls y.output y.tab.c y.tab.h"
echo output.at:57 >$at_check_line_file
( $at_traceon; ls y.output y.tab.c y.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:57: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  14 ) # 14. output.at:61: Output files: %file-prefix="bar" %defines %verbose & .
    at_setup_line='output.at:61'
    $at_verbose "14. output.at:61: testing Output files: %file-prefix="bar" %defines %verbose & ...."
    $at_quiet $ECHO_N " 14: output.at:61      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%file-prefix="bar" %defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:61: bison  foo.y"
echo output.at:61 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:61: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:61: ls bar.output bar.tab.c bar.tab.h"
echo output.at:61 >$at_check_line_file
( $at_traceon; ls bar.output bar.tab.c bar.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:61: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  15 ) # 15. output.at:63: Output files: %output="bar.c" %defines %verbose %yacc & .
    at_setup_line='output.at:63'
    $at_verbose "15. output.at:63: testing Output files: %output="bar.c" %defines %verbose %yacc & ...."
    $at_quiet $ECHO_N " 15: output.at:63      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%output="bar.c" %defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:63: bison  foo.y"
echo output.at:63 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:63: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:63: ls bar.output bar.c bar.h"
echo output.at:63 >$at_check_line_file
( $at_traceon; ls bar.output bar.c bar.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:63: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  16 ) # 16. output.at:67: Output files: %file-prefix="baz" %output="bar.c" %defines %verbose %yacc & .
    at_setup_line='output.at:67'
    $at_verbose "16. output.at:67: testing Output files: %file-prefix="baz" %output="bar.c" %defines %verbose %yacc & ...."
    $at_quiet $ECHO_N " 16: output.at:67      $ECHO_C"
    (
      $at_traceon

cat >foo.y <<'_ATEOF'
%file-prefix="baz" %output="bar.c" %defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:67: bison  foo.y"
echo output.at:67 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:67: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:67: ls bar.output bar.c bar.h"
echo output.at:67 >$at_check_line_file
( $at_traceon; ls bar.output bar.c bar.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:67: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  17 ) # 17. output.at:72: Output files: %defines %verbose & .
    at_setup_line='output.at:72'
    $at_verbose "17. output.at:72: testing Output files: %defines %verbose & ...."
    $at_quiet $ECHO_N " 17: output.at:72      $ECHO_C"
    (
      $at_traceon

cat >foo.yy <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:72: bison  foo.yy"
echo output.at:72 >$at_check_line_file
( $at_traceon; bison  foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:72: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:72: ls foo.output foo.tab.cc foo.tab.hh"
echo output.at:72 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.cc foo.tab.hh ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:72: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  18 ) # 18. output.at:75: Output files: %defines %verbose  & -o foo.c.
    at_setup_line='output.at:75'
    $at_verbose "18. output.at:75: testing Output files: %defines %verbose  & -o foo.c...."
    $at_quiet $ECHO_N " 18: output.at:75      $ECHO_C"
    (
      $at_traceon

cat >foo.yy <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:75: bison -o foo.c foo.yy"
echo output.at:75 >$at_check_line_file
( $at_traceon; bison -o foo.c foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:75: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:75: ls foo.c foo.h foo.output"
echo output.at:75 >$at_check_line_file
( $at_traceon; ls foo.c foo.h foo.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:75: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  19 ) # 19. output.at:79: Output files:  & --defines=foo.hpp -o foo.c++.
    at_setup_line='output.at:79'
    $at_verbose "19. output.at:79: testing Output files:  & --defines=foo.hpp -o foo.c++...."
    $at_quiet $ECHO_N " 19: output.at:79      $ECHO_C"
    (
      $at_traceon

cat >foo.yy <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:79: bison --defines=foo.hpp -o foo.c++ foo.yy"
echo output.at:79 >$at_check_line_file
( $at_traceon; bison --defines=foo.hpp -o foo.c++ foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:79: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:79: ls foo.c++ foo.hpp"
echo output.at:79 >$at_check_line_file
( $at_traceon; ls foo.c++ foo.hpp ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:79: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  20 ) # 20. output.at:83: Output files:  & -o foo.c++ --graph=foo.gph.
    at_setup_line='output.at:83'
    $at_verbose "20. output.at:83: testing Output files:  & -o foo.c++ --graph=foo.gph...."
    $at_quiet $ECHO_N " 20: output.at:83      $ECHO_C"
    (
      $at_traceon

cat >foo.yy <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
$at_verbose "output.at:83: bison -o foo.c++ --graph=foo.gph foo.yy"
echo output.at:83 >$at_check_line_file
( $at_traceon; bison -o foo.c++ --graph=foo.gph foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:83: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "output.at:83: ls foo.c++ foo.gph"
echo output.at:83 >$at_check_line_file
( $at_traceon; ls foo.c++ foo.gph ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "output.at:83: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-3 ) # Banner 3. sets.at:59
    cat <<\_ATEOF

Grammar Sets (Firsts etc.).

_ATEOF
    ;;

  21 ) # 21. sets.at:66: Nullable
    at_setup_line='sets.at:66'
    $at_verbose "21. sets.at:66: testing Nullable..."
    $at_quiet $ECHO_N " 21: sets.at:66        $ECHO_C"
    (
      $at_traceon


# At some point, nullable had been smoking grass, and managed to say:
#
# Entering set_nullable
# NULLABLE
#         'e': yes
#         (null): no
# ...

cat >input.y <<'_ATEOF'
%%
e: 'e' | /* Nothing */;
_ATEOF


$at_traceoff
$at_verbose "sets.at:81: bison --trace=sets input.y"
echo sets.at:81 >$at_check_line_file
( $at_traceon; bison --trace=sets input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:81: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

cat >extract.sed <<'_ATEOF'
#n
/^NULLABLE$/ {
   :null
   p
   n
   /^[ 	]*$/ !b null
}
/^FIRSTS$/ {
   :firsts
   p
   n
   /^[ 	]*$/ !b firsts
}
/^FDERIVES$/ {
   :fderiv
   p
   n
   /^[ 	]*$/ !b fderiv
}
/^DERIVES$/ {
   :deriv
   p
   n
   /^[ 	]*$/ !b deriv
}
_ATEOF

$at_traceoff
$at_verbose "sets.at:82: sed -f extract.sed stderr"
echo sets.at:82 >$at_check_line_file
( $at_traceon; sed -f extract.sed stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:82: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "sets.at:82: mv stdout sets"
echo sets.at:82 >$at_check_line_file
( $at_traceon; mv stdout sets ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:82: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "sets.at:107: cat sets"
echo sets.at:107 >$at_check_line_file
( $at_traceon; cat sets ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "DERIVES
	\$accept derives
		  0  e \$end
	e derives
		  1  'e'
		  2  /* empty */
NULLABLE
	\$accept: no
	e: yes
FIRSTS
	\$accept firsts
		\$accept
		e
	e firsts
		e
FDERIVES
	\$accept derives
		  0  e \$end
		  1  'e'
		  2  /* empty */
	e derives
		  1  'e'
		  2  /* empty */
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:107: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  22 ) # 22. sets.at:151: Broken Closure
    at_setup_line='sets.at:151'
    $at_verbose "22. sets.at:151: testing Broken Closure..."
    $at_quiet $ECHO_N " 22: sets.at:151       $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%%
a: b;
b: c;
c: d;
d: e;
e: f;
f: g;
g: h;
h: 'h';
_ATEOF


$at_traceoff
$at_verbose "sets.at:165: bison --trace=sets input.y"
echo sets.at:165 >$at_check_line_file
( $at_traceon; bison --trace=sets input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:165: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "sets.at:183: sed -n 's/[	 ]*\$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr"
echo sets.at:183 >$at_check_line_file
( $at_traceon; sed -n 's/[	 ]*$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "RTC: Firsts Output BEGIN

   012345678
  .---------.
 0|111111111|
 1| 11111111|
 2|  1111111|
 3|   111111|
 4|    11111|
 5|     1111|
 6|      111|
 7|       11|
 8|        1|
  \`---------'
RTC: Firsts Output END
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:183: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  23 ) # 23. sets.at:193: Firsts
    at_setup_line='sets.at:193'
    $at_verbose "23. sets.at:193: testing Firsts..."
    $at_quiet $ECHO_N " 23: sets.at:193       $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%nonassoc '<' '>'
%left '+' '-'
%right '^' '='
%%
exp:
   exp '<' exp
 | exp '>' exp
 | exp '+' exp
 | exp '-' exp
 | exp '^' exp
 | exp '=' exp
 | "exp"
 ;
_ATEOF


$at_traceoff
$at_verbose "sets.at:211: bison --trace=sets input.y"
echo sets.at:211 >$at_check_line_file
( $at_traceon; bison --trace=sets input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:211: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

cat >extract.sed <<'_ATEOF'
#n
/^NULLABLE$/ {
   :null
   p
   n
   /^[ 	]*$/ !b null
}
/^FIRSTS$/ {
   :firsts
   p
   n
   /^[ 	]*$/ !b firsts
}
/^FDERIVES$/ {
   :fderiv
   p
   n
   /^[ 	]*$/ !b fderiv
}
/^DERIVES$/ {
   :deriv
   p
   n
   /^[ 	]*$/ !b deriv
}
_ATEOF

$at_traceoff
$at_verbose "sets.at:212: sed -f extract.sed stderr"
echo sets.at:212 >$at_check_line_file
( $at_traceon; sed -f extract.sed stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:212: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "sets.at:212: mv stdout sets"
echo sets.at:212 >$at_check_line_file
( $at_traceon; mv stdout sets ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:212: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "sets.at:252: cat sets"
echo sets.at:252 >$at_check_line_file
( $at_traceon; cat sets ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "DERIVES
	\$accept derives
		  0  exp \$end
	exp derives
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
NULLABLE
	\$accept: no
	exp: no
FIRSTS
	\$accept firsts
		\$accept
		exp
	exp firsts
		exp
FDERIVES
	\$accept derives
		  0  exp \$end
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
	exp derives
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "sets.at:252: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-4 ) # Banner 4. reduce.at:19
    cat <<\_ATEOF

Grammar Reduction.

_ATEOF
    ;;

  24 ) # 24. reduce.at:26: Useless Terminals
    at_setup_line='reduce.at:26'
    $at_verbose "24. reduce.at:26: testing Useless Terminals..."
    $at_quiet $ECHO_N " 24: reduce.at:26      $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output="input.c"

%token useless1
%token useless2
%token useless3
%token useless4
%token useless5
%token useless6
%token useless7
%token useless8
%token useless9

%token useful
%%
exp: useful;
_ATEOF


$at_traceoff
$at_verbose "reduce.at:47: bison input.y"
echo reduce.at:47 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:47: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "reduce.at:60: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:60 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Terminals which are not used
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:60: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  25 ) # 25. reduce.at:70: Useless Nonterminals
    at_setup_line='reduce.at:70'
    $at_verbose "25. reduce.at:70: testing Useless Nonterminals..."
    $at_quiet $ECHO_N " 25: reduce.at:70      $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output="input.c"

%nterm useless1
%nterm useless2
%nterm useless3
%nterm useless4
%nterm useless5
%nterm useless6
%nterm useless7
%nterm useless8
%nterm useless9

%token useful
%%
exp: useful;
_ATEOF


$at_traceoff
$at_verbose "reduce.at:102: bison input.y"
echo reduce.at:102 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 9 useless nonterminals
input.y:4.8-15: warning: useless nonterminal: useless1
input.y:5.8-15: warning: useless nonterminal: useless2
input.y:6.8-15: warning: useless nonterminal: useless3
input.y:7.8-15: warning: useless nonterminal: useless4
input.y:8.8-15: warning: useless nonterminal: useless5
input.y:9.8-15: warning: useless nonterminal: useless6
input.y:10.8-15: warning: useless nonterminal: useless7
input.y:11.8-15: warning: useless nonterminal: useless8
input.y:12.8-15: warning: useless nonterminal: useless9
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:102: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "reduce.at:115: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:115 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:115: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  26 ) # 26. reduce.at:125: Useless Rules
    at_setup_line='reduce.at:125'
    $at_verbose "26. reduce.at:125: testing Useless Rules..."
    $at_quiet $ECHO_N " 26: reduce.at:125     $ECHO_C"
    (
      $at_traceon




cat >input.y <<'_ATEOF'
%verbose
%output="input.c"
%token useful
%%
exp: useful;
useless1: '1';
useless2: '2';
useless3: '3';
useless4: '4';
useless5: '5';
useless6: '6';
useless7: '7';
useless8: '8';
useless9: '9';
_ATEOF


$at_traceoff
$at_verbose "reduce.at:166: bison input.y"
echo reduce.at:166 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 9 useless nonterminals and 9 useless rules
input.y:6.1-8: warning: useless nonterminal: useless1
input.y:7.1-8: warning: useless nonterminal: useless2
input.y:8.1-8: warning: useless nonterminal: useless3
input.y:9.1-8: warning: useless nonterminal: useless4
input.y:10.1-8: warning: useless nonterminal: useless5
input.y:11.1-8: warning: useless nonterminal: useless6
input.y:12.1-8: warning: useless nonterminal: useless7
input.y:13.1-8: warning: useless nonterminal: useless8
input.y:14.1-8: warning: useless nonterminal: useless9
input.y:6.9-13: warning: useless rule: useless1: '1'
input.y:7.9-13: warning: useless rule: useless2: '2'
input.y:8.9-13: warning: useless rule: useless3: '3'
input.y:9.9-13: warning: useless rule: useless4: '4'
input.y:10.9-13: warning: useless rule: useless5: '5'
input.y:11.9-13: warning: useless rule: useless6: '6'
input.y:12.9-13: warning: useless rule: useless7: '7'
input.y:13.9-13: warning: useless rule: useless8: '8'
input.y:14.9-13: warning: useless rule: useless9: '9'
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:166: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "reduce.at:199: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:199 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
Terminals which are not used
   '1'
   '2'
   '3'
   '4'
   '5'
   '6'
   '7'
   '8'
   '9'
Useless rules
    2 useless1: '1'
    3 useless2: '2'
    4 useless3: '3'
    5 useless4: '4'
    6 useless5: '5'
    7 useless6: '6'
    8 useless7: '7'
    9 useless8: '8'
   10 useless9: '9'
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:199: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  27 ) # 27. reduce.at:212: Reduced Automaton
    at_setup_line='reduce.at:212'
    $at_verbose "27. reduce.at:212: testing Reduced Automaton..."
    $at_quiet $ECHO_N " 27: reduce.at:212     $ECHO_C"
    (
      $at_traceon




# The non reduced grammar.
# ------------------------
cat >not-reduced.y <<'_ATEOF'
/* A useless token. */
%token useless_token
/* A useful one. */
%token useful
%verbose
%output="not-reduced.c"

%%

exp: useful            { /* A useful action. */ }
   | non_productive    { /* A non productive action. */ }
   ;

not_reachable: useful  { /* A not reachable action. */ }
             ;

non_productive: non_productive useless_token
                       { /* Another non productive action. */ }
              ;
%%
_ATEOF


$at_traceoff
$at_verbose "reduce.at:248: bison not-reduced.y"
echo reduce.at:248 >$at_check_line_file
( $at_traceon; bison not-reduced.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "not-reduced.y: warning: 2 useless nonterminals and 3 useless rules
not-reduced.y:14.1-13: warning: useless nonterminal: not_reachable
not-reduced.y:11.6-19: warning: useless nonterminal: non_productive
not-reduced.y:11.4-57: warning: useless rule: exp: non_productive
not-reduced.y:14.14-56: warning: useless rule: not_reachable: useful
not-reduced.y:17.15-18.63: warning: useless rule: non_productive: non_productive useless_token
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:248: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "reduce.at:260: sed -n '/^Grammar/q;/^\$/!p' not-reduced.output"
echo reduce.at:260 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' not-reduced.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals
   not_reachable
   non_productive
Terminals which are not used
   useless_token
Useless rules
    2 exp: non_productive
    3 not_reachable: useful
    4 non_productive: non_productive useless_token
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:260: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# The reduced grammar.
# --------------------
cat >reduced.y <<'_ATEOF'
/* A useless token. */
%token useless_token
/* A useful one. */
%token useful
%verbose
%output="reduced.c"

%%

exp: useful            { /* A useful action. */ }
//   | non_productive    { /* A non productive action. */ } */
   ;

//not_reachable: useful  { /* A not reachable action. */ }
//             ;

//non_productive: non_productive useless_token
//                       { /* Another non productive action. */ }
//              ;
%%
_ATEOF


$at_traceoff
$at_verbose "reduce.at:287: bison reduced.y"
echo reduce.at:287 >$at_check_line_file
( $at_traceon; bison reduced.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:287: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Comparing the parsers.
cp reduced.c expout
$at_traceoff
$at_verbose "reduce.at:291: sed 's/not-reduced/reduced/g' not-reduced.c"
echo reduce.at:291 >$at_check_line_file
( $at_traceon; sed 's/not-reduced/reduced/g' not-reduced.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:291: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  28 ) # 28. reduce.at:301: Underivable Rules
    at_setup_line='reduce.at:301'
    $at_verbose "28. reduce.at:301: testing Underivable Rules..."
    $at_quiet $ECHO_N " 28: reduce.at:301     $ECHO_C"
    (
      $at_traceon




cat >input.y <<'_ATEOF'
%verbose
%output="input.c"
%token useful
%%
exp: useful | underivable;
underivable: indirection;
indirection: underivable;
_ATEOF


$at_traceoff
$at_verbose "reduce.at:322: bison input.y"
echo reduce.at:322 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 2 useless nonterminals and 3 useless rules
input.y:5.15-25: warning: useless nonterminal: underivable
input.y:6.14-24: warning: useless nonterminal: indirection
input.y:5.13-25: warning: useless rule: exp: underivable
input.y:6.12-24: warning: useless rule: underivable: indirection
input.y:7.12-24: warning: useless rule: indirection: underivable
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:322: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "reduce.at:332: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:332 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals
   underivable
   indirection
Useless rules
    2 exp: underivable
    3 underivable: indirection
    4 indirection: underivable
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "reduce.at:332: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  29 ) # 29. reduce.at:342: Empty Language
    at_setup_line='reduce.at:342'
    $at_verbose "29. reduce.at:342: testing Empty Language..."
    $at_quiet $ECHO_N " 29: reduce.at:342     $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%output="input.c"
%%
exp: exp;
_ATEOF


$at_traceoff
$at_verbose "reduce.at:353: bison input.y"
echo reduce.at:353 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 2 useless nonterminals and 2 useless rules
input.y:3.1-3: fatal error: start symbol exp does not derive any sentence
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "reduce.at:353: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-5 ) # Banner 5. synclines.at:19
    cat <<\_ATEOF

User Actions.

_ATEOF
    ;;

  30 ) # 30. synclines.at:91: Prologue synch line
    at_setup_line='synclines.at:91'
    $at_verbose "30. synclines.at:91: testing Prologue synch line..."
    $at_quiet $ECHO_N " 30: synclines.at:91   $ECHO_C"
    (
      $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


$at_traceoff
$at_verbose "synclines.at:91: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c || (exit 1)"
echo synclines.at:91 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c || (exit 1) ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "synclines.at:91: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
$at_verbose "synclines.at:91: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:91 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:91: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "synclines.at:91: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:91 >$at_check_line_file
( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:91: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input.y <<'_ATEOF'
%{
#error "2"
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
_ATEOF

$at_traceoff
$at_verbose "synclines.at:91: bison -o input.c input.y"
echo synclines.at:91 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:91: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "synclines.at:91: \$CC \$CFLAGS \$CPPFLAGS -c input.c || (exit 1)"
echo synclines.at:91 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c || (exit 1) ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "synclines.at:91: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
$at_verbose "synclines.at:91: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:91 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:91: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "synclines.at:91: cat stdout"
echo synclines.at:91 >$at_check_line_file
( $at_traceon; cat stdout ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "input.y:2: #error \"2\"
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:91: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  31 ) # 31. synclines.at:110: %union synch line
    at_setup_line='synclines.at:110'
    $at_verbose "31. synclines.at:110: testing %union synch line..."
    $at_quiet $ECHO_N " 31: synclines.at:110  $ECHO_C"
    (
      $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


$at_traceoff
$at_verbose "synclines.at:110: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c || (exit 1)"
echo synclines.at:110 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c || (exit 1) ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "synclines.at:110: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
$at_verbose "synclines.at:110: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:110 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:110: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "synclines.at:110: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:110 >$at_check_line_file
( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:110: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input.y <<'_ATEOF'
%union {
#error "2"
}
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
_ATEOF

$at_traceoff
$at_verbose "synclines.at:110: bison -o input.c input.y"
echo synclines.at:110 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:110: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "synclines.at:110: \$CC \$CFLAGS \$CPPFLAGS -c input.c || (exit 1)"
echo synclines.at:110 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c || (exit 1) ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "synclines.at:110: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
$at_verbose "synclines.at:110: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:110 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:110: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "synclines.at:110: cat stdout"
echo synclines.at:110 >$at_check_line_file
( $at_traceon; cat stdout ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "input.y:2: #error \"2\"
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:110: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  32 ) # 32. synclines.at:133: Postprologue synch line
    at_setup_line='synclines.at:133'
    $at_verbose "32. synclines.at:133: testing Postprologue synch line..."
    $at_quiet $ECHO_N " 32: synclines.at:133  $ECHO_C"
    (
      $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


$at_traceoff
$at_verbose "synclines.at:133: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c || (exit 1)"
echo synclines.at:133 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c || (exit 1) ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "synclines.at:133: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
$at_verbose "synclines.at:133: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:133 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:133: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "synclines.at:133: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:133 >$at_check_line_file
( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:133: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%union
{
  int ival;
}
%{
#error "10"
%}
%%
exp: '0';
_ATEOF

$at_traceoff
$at_verbose "synclines.at:133: bison -o input.c input.y"
echo synclines.at:133 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:133: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "synclines.at:133: \$CC \$CFLAGS \$CPPFLAGS -c input.c || (exit 1)"
echo synclines.at:133 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c || (exit 1) ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "synclines.at:133: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
$at_verbose "synclines.at:133: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:133 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:133: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "synclines.at:133: cat stdout"
echo synclines.at:133 >$at_check_line_file
( $at_traceon; cat stdout ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "input.y:10: #error \"10\"
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:133: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  33 ) # 33. synclines.at:152: Action synch line
    at_setup_line='synclines.at:152'
    $at_verbose "33. synclines.at:152: testing Action synch line..."
    $at_quiet $ECHO_N " 33: synclines.at:152  $ECHO_C"
    (
      $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


$at_traceoff
$at_verbose "synclines.at:152: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c || (exit 1)"
echo synclines.at:152 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c || (exit 1) ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "synclines.at:152: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
$at_verbose "synclines.at:152: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:152 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:152: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "synclines.at:152: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:152 >$at_check_line_file
( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:152: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp:
{
#error "8"
};
_ATEOF

$at_traceoff
$at_verbose "synclines.at:152: bison -o input.c input.y"
echo synclines.at:152 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:152: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "synclines.at:152: \$CC \$CFLAGS \$CPPFLAGS -c input.c || (exit 1)"
echo synclines.at:152 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c || (exit 1) ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "synclines.at:152: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
$at_verbose "synclines.at:152: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:152 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:152: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "synclines.at:152: cat stdout"
echo synclines.at:152 >$at_check_line_file
( $at_traceon; cat stdout ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "input.y:8: #error \"8\"
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:152: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  34 ) # 34. synclines.at:170: Epilogue synch line
    at_setup_line='synclines.at:170'
    $at_verbose "34. synclines.at:170: testing Epilogue synch line..."
    $at_quiet $ECHO_N " 34: synclines.at:170  $ECHO_C"
    (
      $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


$at_traceoff
$at_verbose "synclines.at:170: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c || (exit 1)"
echo synclines.at:170 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c || (exit 1) ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "synclines.at:170: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
$at_verbose "synclines.at:170: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:170 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:170: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "synclines.at:170: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:170 >$at_check_line_file
( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:170: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
%%
#error "8"
_ATEOF

$at_traceoff
$at_verbose "synclines.at:170: bison -o input.c input.y"
echo synclines.at:170 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:170: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "synclines.at:170: \$CC \$CFLAGS \$CPPFLAGS -c input.c || (exit 1)"
echo synclines.at:170 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c || (exit 1) ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "synclines.at:170: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
$at_verbose "synclines.at:170: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:170 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:170: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "synclines.at:170: cat stdout"
echo synclines.at:170 >$at_check_line_file
( $at_traceon; cat stdout ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "input.y:8: #error \"8\"
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "synclines.at:170: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-6 ) # Banner 6. headers.at:19
    cat <<\_ATEOF

Parser Headers.

_ATEOF
    ;;

  35 ) # 35. headers.at:27: %union and --defines
    at_setup_line='headers.at:27'
    $at_verbose "35. headers.at:27: testing %union and --defines..."
    $at_quiet $ECHO_N " 35: headers.at:27     $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%union
{
  int   integer;
  char *string ;
}
%%
exp: {};
_ATEOF


$at_traceoff
$at_verbose "headers.at:39: bison --defines input.y"
echo headers.at:39 >$at_check_line_file
( $at_traceon; bison --defines input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "headers.at:39: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  36 ) # 36. headers.at:71: Invalid CPP guards: input/input
    at_setup_line='headers.at:71'
    $at_verbose "36. headers.at:71: testing Invalid CPP guards: input/input..."
    $at_quiet $ECHO_N " 36: headers.at:71     $ECHO_C"
    (
      $at_traceon


# Possibly create inner directories.
dirname=`(dirname input/input) 2>/dev/null ||
$as_expr Xinput/input : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
         Xinput/input : 'X\(//\)[^/]' \| \
         Xinput/input : 'X\(//\)$' \| \
         Xinput/input : 'X\(/\)' \| \
         .     : '\(.\)' 2>/dev/null ||
echo Xinput/input |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
  	  /^X\(\/\/\)$/{ s//\1/; q; }
  	  /^X\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`
{ if $as_mkdir_p; then
    mkdir -p $dirname
  else
    as_dir=$dirname
    as_dirs=
    while test ! -d "$as_dir"; do
      as_dirs="$as_dir $as_dirs"
      as_dir=`(dirname "$as_dir") 2>/dev/null ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
         X"$as_dir" : 'X\(//\)[^/]' \| \
         X"$as_dir" : 'X\(//\)$' \| \
         X"$as_dir" : 'X\(/\)' \| \
         .     : '\(.\)' 2>/dev/null ||
echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
  	  /^X\(\/\/\)$/{ s//\1/; q; }
  	  /^X\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`
    done
    test ! -n "$as_dirs" || mkdir $as_dirs
  fi || { { echo "$as_me:$LINENO: error: cannot create directory $dirname" >&6
echo "$as_me: error: cannot create directory $dirname" >&2;}
   { (exit 1); exit 1; }; }; }


cat >input/input.y <<'_ATEOF'
%%
dummy:;
_ATEOF


$at_traceoff
$at_verbose "headers.at:71: bison --defines=input/input.h input/input.y"
echo headers.at:71 >$at_check_line_file
( $at_traceon; bison --defines=input/input.h input/input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "headers.at:71: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# CPP should be happy with it.
$at_traceoff
$at_verbose "headers.at:71: \$CC -E input/input.h"
echo headers.at:71 >$at_check_line_file
( $at_traceon; $CC -E input/input.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "headers.at:71: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  37 ) # 37. headers.at:72: Invalid CPP guards: 9foo
    at_setup_line='headers.at:72'
    $at_verbose "37. headers.at:72: testing Invalid CPP guards: 9foo..."
    $at_quiet $ECHO_N " 37: headers.at:72     $ECHO_C"
    (
      $at_traceon


# Possibly create inner directories.
dirname=`(dirname 9foo) 2>/dev/null ||
$as_expr X9foo : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
         X9foo : 'X\(//\)[^/]' \| \
         X9foo : 'X\(//\)$' \| \
         X9foo : 'X\(/\)' \| \
         .     : '\(.\)' 2>/dev/null ||
echo X9foo |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
  	  /^X\(\/\/\)$/{ s//\1/; q; }
  	  /^X\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`
{ if $as_mkdir_p; then
    mkdir -p $dirname
  else
    as_dir=$dirname
    as_dirs=
    while test ! -d "$as_dir"; do
      as_dirs="$as_dir $as_dirs"
      as_dir=`(dirname "$as_dir") 2>/dev/null ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
         X"$as_dir" : 'X\(//\)[^/]' \| \
         X"$as_dir" : 'X\(//\)$' \| \
         X"$as_dir" : 'X\(/\)' \| \
         .     : '\(.\)' 2>/dev/null ||
echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
  	  /^X\(\/\/\)$/{ s//\1/; q; }
  	  /^X\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`
    done
    test ! -n "$as_dirs" || mkdir $as_dirs
  fi || { { echo "$as_me:$LINENO: error: cannot create directory $dirname" >&6
echo "$as_me: error: cannot create directory $dirname" >&2;}
   { (exit 1); exit 1; }; }; }


cat >9foo.y <<'_ATEOF'
%%
dummy:;
_ATEOF


$at_traceoff
$at_verbose "headers.at:72: bison --defines=9foo.h 9foo.y"
echo headers.at:72 >$at_check_line_file
( $at_traceon; bison --defines=9foo.h 9foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "headers.at:72: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# CPP should be happy with it.
$at_traceoff
$at_verbose "headers.at:72: \$CC -E 9foo.h"
echo headers.at:72 >$at_check_line_file
( $at_traceon; $CC -E 9foo.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "headers.at:72: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  38 ) # 38. headers.at:81: export YYLTYPE
    at_setup_line='headers.at:81'
    $at_verbose "38. headers.at:81: testing export YYLTYPE..."
    $at_quiet $ECHO_N " 38: headers.at:81     $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%locations

%name-prefix="my_"
%{
#include <stdio.h>
#include <stdlib.h>

static int
my_lex (void)
{
  return EOF;
}

static void
my_error (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

%}
%%
exp:;
_ATEOF


$at_traceoff
$at_verbose "headers.at:108: bison --defines -o input.c input.y"
echo headers.at:108 >$at_check_line_file
( $at_traceon; bison --defines -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "headers.at:108: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# YYLTYPE should be defined, and MY_LLOC declared.
cat >caller.c <<'_ATEOF'
#include "input.h"
YYLTYPE *my_llocp = &my_lloc;

int my_parse (void);

int
main (void)
{
  return my_parse ();
}
_ATEOF


# Link and execute, just to make sure everything is fine (and in
# particular, that MY_LLOC is indeed defined somewhere).
$at_traceoff
$at_verbose "headers.at:126: \$CC \$CFLAGS \$CPPFLAGS caller.c input.c -o caller"
echo headers.at:126 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS caller.c input.c -o caller ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "headers.at:126: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "headers.at:127: \$PREPARSER ./caller"
echo headers.at:127 >$at_check_line_file
( $at_traceon; $PREPARSER ./caller ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "headers.at:127: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-7 ) # Banner 7. actions.at:19
    cat <<\_ATEOF

User Actions.

_ATEOF
    ;;

  39 ) # 39. actions.at:25: Mid-rule actions
    at_setup_line='actions.at:25'
    $at_verbose "39. actions.at:25: testing Mid-rule actions..."
    $at_quiet $ECHO_N " 39: actions.at:25     $ECHO_C"
    (
      $at_traceon


# Bison once forgot the mid-rule actions.  It was because the action
# was attached to the host rule (the one with the mid-rule action),
# instead of being attached to the empty rule dedicated to this
# action.

cat >input.y <<'_ATEOF'
%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define YYDEBUG         1
# define YYERROR_VERBOSE 1
%}
%%
exp:     { putchar ('0'); }
     '1' { putchar ('1'); }
     '2' { putchar ('2'); }
     '3' { putchar ('3'); }
     '4' { putchar ('4'); }
     '5' { putchar ('5'); }
     '6' { putchar ('6'); }
     '7' { putchar ('7'); }
     '8' { putchar ('8'); }
     '9' { putchar ('9'); }
         { putchar ('\n'); }
   ;
%%
static int
yylex (void)
{
  static const char *input = "123456789";
  return *input++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF


$at_traceoff
$at_verbose "actions.at:75: bison -d -v -o input.c input.y"
echo actions.at:75 >$at_check_line_file
( $at_traceon; bison -d -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "actions.at:75: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "actions.at:76: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo actions.at:76 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "actions.at:76: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "actions.at:79: \$PREPARSER ./input"
echo actions.at:79 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "0123456789
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "actions.at:79: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  40 ) # 40. actions.at:89: Exotic Dollars
    at_setup_line='actions.at:89'
    $at_verbose "40. actions.at:89: testing Exotic Dollars..."
    $at_quiet $ECHO_N " 40: actions.at:89     $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define YYDEBUG         1
# define YYERROR_VERBOSE 1
%}

%union
{
  int val;
};

%type <val> a_1 a_2 a_5
            sum_of_the_five_previous_values

%%
exp: a_1 a_2 { $<val>$ = 3; } { $<val>$ = $<val>3 + 1; } a_5
     sum_of_the_five_previous_values
    {
       printf ("%d\n", $6);
    }
;
a_1: { $$ = 1; };
a_2: { $$ = 2; };
a_5: { $$ = 5; };

sum_of_the_five_previous_values:
    {
       $$ = $<val>0 + $<val>-1 + $<val>-2 + $<val>-3 + $<val>-4;
    }
;

%%
static int
yylex (void)
{
  return EOF;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF


$at_traceoff
$at_verbose "actions.at:146: bison -d -v -o input.c input.y"
echo actions.at:146 >$at_check_line_file
( $at_traceon; bison -d -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "actions.at:146: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "actions.at:147: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo actions.at:147 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "actions.at:147: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "actions.at:150: \$PREPARSER ./input"
echo actions.at:150 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "actions.at:150: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  41 ) # 41. actions.at:160: Printers and Destructors
    at_setup_line='actions.at:160'
    $at_verbose "41. actions.at:160: testing Printers and Destructors..."
    $at_quiet $ECHO_N " 41: actions.at:160    $ECHO_C"
    (
      $at_traceon


# Make sure complex $n work.

cat >input.y <<'_ATEOF'
%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define YYERROR_VERBOSE 1
#define YYDEBUG 1
%}
%verbose
%union
{
  int ival;
}
%type <ival> 'x' thing line input

%printer { fprintf (yyout, "%d from %d", $$, @$.first_line); }
   input line thing 'x'

%destructor
  {
    fprintf (stdout, "Freeing ");
    /* FIXME: Ouch: INTERNAL DETAILS EXPOSED HERE. */
    /* Cannot use $$ which is the union member, not the union itself. */
    yysymprint (stdout, yytype, yyvalue, @$);
    fprintf (stdout, "\n");
  }
  input line thing 'x'

%{
static int yylex (void);
static void yyerror (const char *msg);
%}


%%
input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input(%d): /* Nothing */';'\n", $$);
    }
| line input /* Right recursive to load the stack so that popping at
		EOF can	be exercised.  */
    {
      $$ = 2;
      printf ("input(%d): line(%d) input(%d)';'\n", $$, $1, $2);
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line(%d): thing(%d) thing(%d) thing(%d) ';'\n", $$, $1, $2, $3);
    }
| thing thing ';'
    {
      $$ = $1;
      printf ("line(%d): thing(%d) thing(%d) ';'\n", $$, $1, $2);
    }
| thing ';'
    {
      $$ = $1;
      printf ("line(%d): thing(%d) ';'\n", $$, $1);
    }
| error ';'
    {
      $$ = -1;
      printf ("line(%d): error ';'\n", $$);
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing(%d): 'x'(%d)\n", $$, $1);
    }
;
%%
static int
yylex (void)
{
  static const unsigned int input[] =
    {
      /* Exericise the discarding of stack top and input until `error'
         can be reduced.  */
      'x', 'x', 'x', 'x', 'x', 'x', ';',

      /* Load the stack and provoke an error that cannot be caught by
         the grammar, to check that the stack is cleared. */
      'x', 'x', ';',
      'x', ';',
      'y'
    };
  static unsigned int counter = 0;

  if (counter < (sizeof(input) / sizeof (input[0])))
    {
       yylval.ival = counter;
       /* As in BASIC, line numbers go from 10 to 10.  */
       yylloc.first_line = 10 * counter;
       printf ("sending: '%c' (value = %d, line %d)\n",
               input[counter], yylval.ival, yylloc.first_line);
       return (int) input[counter++];
    }
  else
    {
      printf ("sending: EOF\n");
      return EOF;
    }
}

static void
yyerror (const char *msg)
{
  fprintf (stdout, "%d: %s\n", yylloc.first_line, msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  if (yyparse ())
    {
      fprintf (stdout, "Parsing FAILED.\n");
      exit (1);
    }
  fprintf (stdout, "Successful parse.\n");
  return 0;
}
_ATEOF


$at_traceoff
$at_verbose "actions.at:298: bison --location -d -v -o input.c input.y"
echo actions.at:298 >$at_check_line_file
( $at_traceon; bison --location -d -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "actions.at:298: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "actions.at:299: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo actions.at:299 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "actions.at:299: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "actions.at:336: \$PREPARSER ./input"
echo actions.at:336 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "sending: 'x' (value = 0, line 0)
thing(0): 'x'(0)
sending: 'x' (value = 1, line 10)
thing(1): 'x'(1)
sending: 'x' (value = 2, line 20)
thing(2): 'x'(2)
sending: 'x' (value = 3, line 30)
30: parse error, unexpected 'x', expecting ';'
Freeing nterm thing (2 from 20)
Freeing nterm thing (1 from 10)
Freeing nterm thing (0 from 0)
Freeing token 'x' (3 from 30)
sending: 'x' (value = 4, line 40)
Freeing token 'x' (4 from 40)
sending: 'x' (value = 5, line 50)
Freeing token 'x' (5 from 50)
sending: ';' (value = 6, line 60)
line(-1): error ';'
sending: 'x' (value = 7, line 70)
thing(7): 'x'(7)
sending: 'x' (value = 8, line 80)
thing(8): 'x'(8)
sending: ';' (value = 9, line 90)
line(7): thing(7) thing(8) ';'
sending: 'x' (value = 10, line 100)
thing(10): 'x'(10)
sending: ';' (value = 11, line 110)
line(10): thing(10) ';'
sending: 'y' (value = 12, line 120)
120: parse error, unexpected \$undefined, expecting \$end or 'x'
sending: EOF
Freeing nterm line (10 from 100)
Freeing nterm line (7 from 70)
Freeing nterm line (-1 from 50)
Parsing FAILED.
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "actions.at:336: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-8 ) # Banner 8. conflicts.at:19
    cat <<\_ATEOF

Conflicts.

_ATEOF
    ;;

  42 ) # 42. conflicts.at:31: S/R in initial
    at_setup_line='conflicts.at:31'
    $at_verbose "42. conflicts.at:31: testing S/R in initial..."
    $at_quiet $ECHO_N " 42: conflicts.at:31   $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%expect 1
%%
exp: e 'e';
e: 'e' | /* Nothing. */;
_ATEOF


$at_traceoff
$at_verbose "conflicts.at:42: bison -o input.c input.y"
echo conflicts.at:42 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:4.8: warning: rule never reduced because of conflicts: e: /* empty */
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:42: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  43 ) # 43. conflicts.at:51: %nonassoc and eof
    at_setup_line='conflicts.at:51'
    $at_verbose "43. conflicts.at:51: testing %nonassoc and eof..."
    $at_quiet $ECHO_N " 43: conflicts.at:51   $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
#endif

#define YYERROR_VERBOSE 1
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
  exit (1);
}

/* The current argument. */
static const char *input = NULL;

static int
yylex (void)
{
  /* No token stands for end of file. */
  if (input && *input)
    return *input++;
  else
    return 0;
}

%}

%nonassoc '<' '>'

%%
expr: expr '<' expr
    | expr '>' expr
    | '0'
    ;
%%
int
main (int argc, const char *argv[])
{
  if (argc > 1)
    input = argv[1];
  return yyparse ();
}
_ATEOF


# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "conflicts.at:106: bison -o input.c input.y"
echo conflicts.at:106 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:106: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "conflicts.at:107: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo conflicts.at:107 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:107: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "conflicts.at:109: \$PREPARSER ./input '0<0'"
echo conflicts.at:109 >$at_check_line_file
( $at_traceon; $PREPARSER ./input '0<0' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:109: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# FIXME: This is an actual bug, but a new one, in the sense that
# no one has ever spotted it!  The messages are *wrong*: there should
# be nothing there, it should be expected eof.
$at_traceoff
$at_verbose "conflicts.at:115: \$PREPARSER ./input '0<0<0'"
echo conflicts.at:115 >$at_check_line_file
( $at_traceon; $PREPARSER ./input '0<0<0' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error, unexpected '<', expecting '<' or '>'
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "conflicts.at:115: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "conflicts.at:117: \$PREPARSER ./input '0>0'"
echo conflicts.at:117 >$at_check_line_file
( $at_traceon; $PREPARSER ./input '0>0' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:117: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "conflicts.at:120: \$PREPARSER ./input '0>0>0'"
echo conflicts.at:120 >$at_check_line_file
( $at_traceon; $PREPARSER ./input '0>0>0' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error, unexpected '>', expecting '<' or '>'
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "conflicts.at:120: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "conflicts.at:124: \$PREPARSER ./input '0<0>0'"
echo conflicts.at:124 >$at_check_line_file
( $at_traceon; $PREPARSER ./input '0<0>0' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error, unexpected '>', expecting '<' or '>'
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "conflicts.at:124: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  44 ) # 44. conflicts.at:134: Unresolved SR Conflicts
    at_setup_line='conflicts.at:134'
    $at_verbose "44. conflicts.at:134: testing Unresolved SR Conflicts..."
    $at_quiet $ECHO_N " 44: conflicts.at:134  $ECHO_C"
    (
      $at_traceon




cat >input.y <<'_ATEOF'
%token NUM OP
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
$at_verbose "conflicts.at:146: bison -o input.c --report=all input.y"
echo conflicts.at:146 >$at_check_line_file
( $at_traceon; bison -o input.c --report=all input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 1 shift/reduce conflict
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:146: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Check the contents of the report.
$at_traceoff
$at_verbose "conflicts.at:231: cat input.output"
echo conflicts.at:231 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "State 5 contains 1 shift/reduce conflict.


Grammar

    0 \$accept: exp \$end

    1 exp: exp OP exp
    2    | NUM


Terminals, with rules where they appear

\$end (0) 0
error (256)
NUM (258) 2
OP (259) 1


Nonterminals, with rules where they appear

\$accept (5)
    on left: 0
exp (6)
    on left: 1 2, on right: 0 1


state 0

    0 \$accept: . exp \$end
    1 exp: . exp OP exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 2


state 1

    2 exp: NUM .

    \$default  reduce using rule 2 (exp)


state 2

    0 \$accept: exp . \$end
    1 exp: exp . OP exp

    \$end  shift, and go to state 3
    OP    shift, and go to state 4


state 3

    0 \$accept: exp \$end .

    \$default  accept


state 4

    1 exp: . exp OP exp
    1    | exp OP . exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 5


state 5

    1 exp: exp . OP exp  [\$end, OP]
    1    | exp OP exp .  [\$end, OP]

    OP  shift, and go to state 4

    OP        [reduce using rule 1 (exp)]
    \$default  reduce using rule 1 (exp)
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:231: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  45 ) # 45. conflicts.at:241: Resolved SR Conflicts
    at_setup_line='conflicts.at:241'
    $at_verbose "45. conflicts.at:241: testing Resolved SR Conflicts..."
    $at_quiet $ECHO_N " 45: conflicts.at:241  $ECHO_C"
    (
      $at_traceon




cat >input.y <<'_ATEOF'
%token NUM OP
%left OP
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
$at_verbose "conflicts.at:252: bison -o input.c --report=all input.y"
echo conflicts.at:252 >$at_check_line_file
( $at_traceon; bison -o input.c --report=all input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:252: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Check the contents of the report.
$at_traceoff
$at_verbose "conflicts.at:333: cat input.output"
echo conflicts.at:333 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Grammar

    0 \$accept: exp \$end

    1 exp: exp OP exp
    2    | NUM


Terminals, with rules where they appear

\$end (0) 0
error (256)
NUM (258) 2
OP (259) 1


Nonterminals, with rules where they appear

\$accept (5)
    on left: 0
exp (6)
    on left: 1 2, on right: 0 1


state 0

    0 \$accept: . exp \$end
    1 exp: . exp OP exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 2


state 1

    2 exp: NUM .

    \$default  reduce using rule 2 (exp)


state 2

    0 \$accept: exp . \$end
    1 exp: exp . OP exp

    \$end  shift, and go to state 3
    OP    shift, and go to state 4


state 3

    0 \$accept: exp \$end .

    \$default  accept


state 4

    1 exp: . exp OP exp
    1    | exp OP . exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 5


state 5

    1 exp: exp . OP exp  [\$end, OP]
    1    | exp OP exp .  [\$end, OP]

    \$default  reduce using rule 1 (exp)

    Conflict between rule 1 and token OP resolved as reduce (%left OP).
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:333: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  46 ) # 46. conflicts.at:363: Defaulted Conflicted Reduction
    at_setup_line='conflicts.at:363'
    $at_verbose "46. conflicts.at:363: testing Defaulted Conflicted Reduction..."
    $at_quiet $ECHO_N " 46: conflicts.at:363  $ECHO_C"
    (
      $at_traceon



cat >input.y <<'_ATEOF'
%%
exp: num | id;
num: '0';
id : '0';
%%
_ATEOF


$at_traceoff
$at_verbose "conflicts.at:377: bison -o input.c --report=all input.y"
echo conflicts.at:377 >$at_check_line_file
( $at_traceon; bison -o input.c --report=all input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 1 reduce/reduce conflict
input.y:4.4-8: warning: rule never reduced because of conflicts: id: '0'
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:377: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Check the contents of the report.
$at_traceoff
$at_verbose "conflicts.at:471: cat input.output"
echo conflicts.at:471 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Rules never reduced

    4 id: '0'


State 1 contains 1 reduce/reduce conflict.


Grammar

    0 \$accept: exp \$end

    1 exp: num
    2    | id

    3 num: '0'

    4 id: '0'


Terminals, with rules where they appear

\$end (0) 0
'0' (48) 3 4
error (256)


Nonterminals, with rules where they appear

\$accept (4)
    on left: 0
exp (5)
    on left: 1 2, on right: 0
num (6)
    on left: 3, on right: 1
id (7)
    on left: 4, on right: 2


state 0

    0 \$accept: . exp \$end
    1 exp: . num
    2    | . id
    3 num: . '0'
    4 id: . '0'

    '0'  shift, and go to state 1

    exp  go to state 2
    num  go to state 3
    id   go to state 4


state 1

    3 num: '0' .  [\$end]
    4 id: '0' .  [\$end]

    \$end      reduce using rule 3 (num)
    \$end      [reduce using rule 4 (id)]
    \$default  reduce using rule 3 (num)


state 2

    0 \$accept: exp . \$end

    \$end  shift, and go to state 5


state 3

    1 exp: num .

    \$default  reduce using rule 1 (exp)


state 4

    2 exp: id .

    \$default  reduce using rule 2 (exp)


state 5

    0 \$accept: exp \$end .

    \$default  accept
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:471: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  47 ) # 47. conflicts.at:482: %expect not enough
    at_setup_line='conflicts.at:482'
    $at_verbose "47. conflicts.at:482: testing %expect not enough..."
    $at_quiet $ECHO_N " 47: conflicts.at:482  $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 0
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
$at_verbose "conflicts.at:494: bison -o input.c input.y"
echo conflicts.at:494 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 1 shift/reduce conflict
input.y: expected 0 shift/reduce conflicts
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "conflicts.at:494: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  48 ) # 48. conflicts.at:502: %expect right
    at_setup_line='conflicts.at:502'
    $at_verbose "48. conflicts.at:502: testing %expect right..."
    $at_quiet $ECHO_N " 48: conflicts.at:502  $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 1
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
$at_verbose "conflicts.at:511: bison -o input.c input.y"
echo conflicts.at:511 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "conflicts.at:511: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  49 ) # 49. conflicts.at:519: %expect too much
    at_setup_line='conflicts.at:519'
    $at_verbose "49. conflicts.at:519: testing %expect too much..."
    $at_quiet $ECHO_N " 49: conflicts.at:519  $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 2
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
$at_verbose "conflicts.at:531: bison -o input.c input.y"
echo conflicts.at:531 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 1 shift/reduce conflict
input.y: expected 2 shift/reduce conflicts
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "conflicts.at:531: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-9 ) # Banner 9. calc.at:440
    cat <<\_ATEOF

Simple LALR Calculator.

_ATEOF
    ;;

  50 ) # 50. calc.at:449: Calculator
    at_setup_line='calc.at:449'
    $at_verbose "50. calc.at:449: testing Calculator ..."
    $at_quiet $ECHO_N " 50: calc.at:449       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */



/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:449: bison -o calc.c  calc.y"
echo calc.at:449 >$at_check_line_file
( $at_traceon; bison -o calc.c  calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:449: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:449 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:449: \$PREPARSER ./calc input"
echo calc.at:449 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:449: \$PREPARSER ./calc input"
echo calc.at:449 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:449: cat stderr"
echo calc.at:449 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:449: \$PREPARSER ./calc input"
echo calc.at:449 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:449: cat stderr"
echo calc.at:449 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:449: \$PREPARSER ./calc input"
echo calc.at:449 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:449: cat stderr"
echo calc.at:449 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:449: \$PREPARSER ./calc input"
echo calc.at:449 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:449: cat stderr"
echo calc.at:449 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:449: \$PREPARSER ./calc input"
echo calc.at:449 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:449: cat stderr"
echo calc.at:449 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:449: \$PREPARSER ./calc /dev/null"
echo calc.at:449 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:449: cat stderr"
echo calc.at:449 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:449: \$PREPARSER ./calc input"
echo calc.at:449 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:449: cat stderr"
echo calc.at:449 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:449: \$PREPARSER ./calc input"
echo calc.at:449 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:449: cat stderr"
echo calc.at:449 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:449: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  51 ) # 51. calc.at:451: Calculator --defines
    at_setup_line='calc.at:451'
    $at_verbose "51. calc.at:451: testing Calculator --defines..."
    $at_quiet $ECHO_N " 51: calc.at:451       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */



/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:451: bison -o calc.c --defines calc.y"
echo calc.at:451 >$at_check_line_file
( $at_traceon; bison -o calc.c --defines calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:451: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:451 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:451: \$PREPARSER ./calc input"
echo calc.at:451 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:451: \$PREPARSER ./calc input"
echo calc.at:451 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:451: cat stderr"
echo calc.at:451 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:451: \$PREPARSER ./calc input"
echo calc.at:451 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:451: cat stderr"
echo calc.at:451 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:451: \$PREPARSER ./calc input"
echo calc.at:451 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:451: cat stderr"
echo calc.at:451 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:451: \$PREPARSER ./calc input"
echo calc.at:451 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:451: cat stderr"
echo calc.at:451 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:451: \$PREPARSER ./calc input"
echo calc.at:451 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:451: cat stderr"
echo calc.at:451 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:451: \$PREPARSER ./calc /dev/null"
echo calc.at:451 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:451: cat stderr"
echo calc.at:451 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:451: \$PREPARSER ./calc input"
echo calc.at:451 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:451: cat stderr"
echo calc.at:451 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:451: \$PREPARSER ./calc input"
echo calc.at:451 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:451: cat stderr"
echo calc.at:451 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:451: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  52 ) # 52. calc.at:452: Calculator --locations
    at_setup_line='calc.at:452'
    $at_verbose "52. calc.at:452: testing Calculator --locations..."
    $at_quiet $ECHO_N " 52: calc.at:452       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */



/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:452: bison -o calc.c --locations calc.y"
echo calc.at:452 >$at_check_line_file
( $at_traceon; bison -o calc.c --locations calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:452: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:452 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:452: \$PREPARSER ./calc input"
echo calc.at:452 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:452: \$PREPARSER ./calc input"
echo calc.at:452 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:452: cat stderr"
echo calc.at:452 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:452: \$PREPARSER ./calc input"
echo calc.at:452 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:452: cat stderr"
echo calc.at:452 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:452: \$PREPARSER ./calc input"
echo calc.at:452 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:452: cat stderr"
echo calc.at:452 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:452: \$PREPARSER ./calc input"
echo calc.at:452 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:452: cat stderr"
echo calc.at:452 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:452: \$PREPARSER ./calc input"
echo calc.at:452 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:452: cat stderr"
echo calc.at:452 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:452: \$PREPARSER ./calc /dev/null"
echo calc.at:452 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:452: cat stderr"
echo calc.at:452 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:452: \$PREPARSER ./calc input"
echo calc.at:452 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:452: cat stderr"
echo calc.at:452 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:452: \$PREPARSER ./calc input"
echo calc.at:452 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:452: cat stderr"
echo calc.at:452 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:452: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  53 ) # 53. calc.at:453: Calculator --name-prefix=calc
    at_setup_line='calc.at:453'
    $at_verbose "53. calc.at:453: testing Calculator --name-prefix=calc..."
    $at_quiet $ECHO_N " 53: calc.at:453       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */



/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:453: bison -o calc.c --name-prefix=calc calc.y"
echo calc.at:453 >$at_check_line_file
( $at_traceon; bison -o calc.c --name-prefix=calc calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:453: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:453 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:453: \$PREPARSER ./calc input"
echo calc.at:453 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:453: \$PREPARSER ./calc input"
echo calc.at:453 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:453: cat stderr"
echo calc.at:453 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:453: \$PREPARSER ./calc input"
echo calc.at:453 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:453: cat stderr"
echo calc.at:453 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:453: \$PREPARSER ./calc input"
echo calc.at:453 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:453: cat stderr"
echo calc.at:453 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:453: \$PREPARSER ./calc input"
echo calc.at:453 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:453: cat stderr"
echo calc.at:453 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:453: \$PREPARSER ./calc input"
echo calc.at:453 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:453: cat stderr"
echo calc.at:453 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:453: \$PREPARSER ./calc /dev/null"
echo calc.at:453 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:453: cat stderr"
echo calc.at:453 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:453: \$PREPARSER ./calc input"
echo calc.at:453 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:453: cat stderr"
echo calc.at:453 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:453: \$PREPARSER ./calc input"
echo calc.at:453 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:453: cat stderr"
echo calc.at:453 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:453: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  54 ) # 54. calc.at:454: Calculator --verbose
    at_setup_line='calc.at:454'
    $at_verbose "54. calc.at:454: testing Calculator --verbose..."
    $at_quiet $ECHO_N " 54: calc.at:454       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */



/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:454: bison -o calc.c --verbose calc.y"
echo calc.at:454 >$at_check_line_file
( $at_traceon; bison -o calc.c --verbose calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:454: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:454 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:454: \$PREPARSER ./calc input"
echo calc.at:454 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:454: \$PREPARSER ./calc input"
echo calc.at:454 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:454: cat stderr"
echo calc.at:454 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:454: \$PREPARSER ./calc input"
echo calc.at:454 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:454: cat stderr"
echo calc.at:454 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:454: \$PREPARSER ./calc input"
echo calc.at:454 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:454: cat stderr"
echo calc.at:454 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:454: \$PREPARSER ./calc input"
echo calc.at:454 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:454: cat stderr"
echo calc.at:454 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:454: \$PREPARSER ./calc input"
echo calc.at:454 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:454: cat stderr"
echo calc.at:454 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:454: \$PREPARSER ./calc /dev/null"
echo calc.at:454 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:454: cat stderr"
echo calc.at:454 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:454: \$PREPARSER ./calc input"
echo calc.at:454 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:454: cat stderr"
echo calc.at:454 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:454: \$PREPARSER ./calc input"
echo calc.at:454 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:454: cat stderr"
echo calc.at:454 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:454: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  55 ) # 55. calc.at:455: Calculator --yacc
    at_setup_line='calc.at:455'
    $at_verbose "55. calc.at:455: testing Calculator --yacc..."
    $at_quiet $ECHO_N " 55: calc.at:455       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */



/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:455: bison -o calc.c --yacc calc.y"
echo calc.at:455 >$at_check_line_file
( $at_traceon; bison -o calc.c --yacc calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:455: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:455 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:455: \$PREPARSER ./calc input"
echo calc.at:455 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:455: \$PREPARSER ./calc input"
echo calc.at:455 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:455: cat stderr"
echo calc.at:455 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:455: \$PREPARSER ./calc input"
echo calc.at:455 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:455: cat stderr"
echo calc.at:455 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:455: \$PREPARSER ./calc input"
echo calc.at:455 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:455: cat stderr"
echo calc.at:455 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:455: \$PREPARSER ./calc input"
echo calc.at:455 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:455: cat stderr"
echo calc.at:455 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:455: \$PREPARSER ./calc input"
echo calc.at:455 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:455: cat stderr"
echo calc.at:455 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:455: \$PREPARSER ./calc /dev/null"
echo calc.at:455 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:455: cat stderr"
echo calc.at:455 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:455: \$PREPARSER ./calc input"
echo calc.at:455 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:455: cat stderr"
echo calc.at:455 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:455: \$PREPARSER ./calc input"
echo calc.at:455 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:455: cat stderr"
echo calc.at:455 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:455: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  56 ) # 56. calc.at:456: Calculator %error-verbose
    at_setup_line='calc.at:456'
    $at_verbose "56. calc.at:456: testing Calculator %error-verbose..."
    $at_quiet $ECHO_N " 56: calc.at:456       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%error-verbose

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:456: bison -o calc.c  calc.y"
echo calc.at:456 >$at_check_line_file
( $at_traceon; bison -o calc.c  calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:456: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:456 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:456: \$PREPARSER ./calc input"
echo calc.at:456 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:456: \$PREPARSER ./calc input"
echo calc.at:456 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:456: cat stderr"
echo calc.at:456 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:456: \$PREPARSER ./calc input"
echo calc.at:456 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:456: cat stderr"
echo calc.at:456 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:456: \$PREPARSER ./calc input"
echo calc.at:456 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:456: cat stderr"
echo calc.at:456 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:456: \$PREPARSER ./calc input"
echo calc.at:456 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:456: cat stderr"
echo calc.at:456 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:456: \$PREPARSER ./calc input"
echo calc.at:456 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:456: cat stderr"
echo calc.at:456 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:456: \$PREPARSER ./calc /dev/null"
echo calc.at:456 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:456: cat stderr"
echo calc.at:456 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:456: \$PREPARSER ./calc input"
echo calc.at:456 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:456: cat stderr"
echo calc.at:456 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:456: \$PREPARSER ./calc input"
echo calc.at:456 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:456: cat stderr"
echo calc.at:456 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:456: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  57 ) # 57. calc.at:458: Calculator %error-verbose --locations
    at_setup_line='calc.at:458'
    $at_verbose "57. calc.at:458: testing Calculator %error-verbose --locations..."
    $at_quiet $ECHO_N " 57: calc.at:458       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%error-verbose

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:458: bison -o calc.c  --locations calc.y"
echo calc.at:458 >$at_check_line_file
( $at_traceon; bison -o calc.c  --locations calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:458: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:458 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:458: \$PREPARSER ./calc input"
echo calc.at:458 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:458: \$PREPARSER ./calc input"
echo calc.at:458 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:458: cat stderr"
echo calc.at:458 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:458: \$PREPARSER ./calc input"
echo calc.at:458 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:458: cat stderr"
echo calc.at:458 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:458: \$PREPARSER ./calc input"
echo calc.at:458 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:458: cat stderr"
echo calc.at:458 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:458: \$PREPARSER ./calc input"
echo calc.at:458 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:458: cat stderr"
echo calc.at:458 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:458: \$PREPARSER ./calc input"
echo calc.at:458 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:458: cat stderr"
echo calc.at:458 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:458: \$PREPARSER ./calc /dev/null"
echo calc.at:458 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:458: cat stderr"
echo calc.at:458 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:458: \$PREPARSER ./calc input"
echo calc.at:458 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:458: cat stderr"
echo calc.at:458 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:458: \$PREPARSER ./calc input"
echo calc.at:458 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:458: cat stderr"
echo calc.at:458 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:458: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  58 ) # 58. calc.at:460: Calculator %error-verbose --defines --locations --name-prefix=calc --verbose --yacc
    at_setup_line='calc.at:460'
    $at_verbose "58. calc.at:460: testing Calculator %error-verbose --defines --locations --name-prefix=calc --verbose --yacc..."
    $at_quiet $ECHO_N " 58: calc.at:460       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%error-verbose

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:460: bison -o calc.c  --defines --locations --name-prefix=calc --verbose --yacc calc.y"
echo calc.at:460 >$at_check_line_file
( $at_traceon; bison -o calc.c  --defines --locations --name-prefix=calc --verbose --yacc calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:460: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:460 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:460: \$PREPARSER ./calc input"
echo calc.at:460 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:460: \$PREPARSER ./calc input"
echo calc.at:460 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:460: cat stderr"
echo calc.at:460 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:460: \$PREPARSER ./calc input"
echo calc.at:460 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:460: cat stderr"
echo calc.at:460 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:460: \$PREPARSER ./calc input"
echo calc.at:460 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:460: cat stderr"
echo calc.at:460 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:460: \$PREPARSER ./calc input"
echo calc.at:460 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:460: cat stderr"
echo calc.at:460 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:460: \$PREPARSER ./calc input"
echo calc.at:460 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:460: cat stderr"
echo calc.at:460 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:460: \$PREPARSER ./calc /dev/null"
echo calc.at:460 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:460: cat stderr"
echo calc.at:460 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:460: \$PREPARSER ./calc input"
echo calc.at:460 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:460: cat stderr"
echo calc.at:460 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:460: \$PREPARSER ./calc input"
echo calc.at:460 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:460: cat stderr"
echo calc.at:460 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:460: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  59 ) # 59. calc.at:462: Calculator %debug
    at_setup_line='calc.at:462'
    $at_verbose "59. calc.at:462: testing Calculator %debug..."
    $at_quiet $ECHO_N " 59: calc.at:462       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%debug

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:462: bison -o calc.c  calc.y"
echo calc.at:462 >$at_check_line_file
( $at_traceon; bison -o calc.c  calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:462: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:462 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:462: \$PREPARSER ./calc input"
echo calc.at:462 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:462: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:462 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "486
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:462: \$PREPARSER ./calc input"
echo calc.at:462 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:462: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:462 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "11
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:462: cat stderr"
echo calc.at:462 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:462: \$PREPARSER ./calc input"
echo calc.at:462 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:462: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:462 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:462: cat stderr"
echo calc.at:462 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:462: \$PREPARSER ./calc input"
echo calc.at:462 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:462: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:462 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:462: cat stderr"
echo calc.at:462 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:462: \$PREPARSER ./calc input"
echo calc.at:462 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:462: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:462 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "22
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:462: cat stderr"
echo calc.at:462 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:462: \$PREPARSER ./calc input"
echo calc.at:462 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:462: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:462 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "14
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:462: cat stderr"
echo calc.at:462 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:462: \$PREPARSER ./calc /dev/null"
echo calc.at:462 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:462: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:462 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:462: cat stderr"
echo calc.at:462 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:462: \$PREPARSER ./calc input"
echo calc.at:462 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:462: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:462 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "82
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:462: cat stderr"
echo calc.at:462 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:462: \$PREPARSER ./calc input"
echo calc.at:462 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:462: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:462 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "21
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:462: cat stderr"
echo calc.at:462 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:462: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  60 ) # 60. calc.at:463: Calculator %error-verbose %debug --defines --locations --name-prefix=calc --verbose --yacc
    at_setup_line='calc.at:463'
    $at_verbose "60. calc.at:463: testing Calculator %error-verbose %debug --defines --locations --name-prefix=calc --verbose --yacc..."
    $at_quiet $ECHO_N " 60: calc.at:463       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%error-verbose %debug

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:463: bison -o calc.c   --defines --locations --name-prefix=calc --verbose --yacc calc.y"
echo calc.at:463 >$at_check_line_file
( $at_traceon; bison -o calc.c   --defines --locations --name-prefix=calc --verbose --yacc calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:463: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:463 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:463: \$PREPARSER ./calc input"
echo calc.at:463 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:463: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:463 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "486
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:463: \$PREPARSER ./calc input"
echo calc.at:463 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:463: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:463 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "11
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:463: cat stderr"
echo calc.at:463 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:463: \$PREPARSER ./calc input"
echo calc.at:463 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:463: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:463 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:463: cat stderr"
echo calc.at:463 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:463: \$PREPARSER ./calc input"
echo calc.at:463 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:463: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:463 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:463: cat stderr"
echo calc.at:463 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:463: \$PREPARSER ./calc input"
echo calc.at:463 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:463: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:463 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "22
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:463: cat stderr"
echo calc.at:463 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:463: \$PREPARSER ./calc input"
echo calc.at:463 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:463: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:463 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "14
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:463: cat stderr"
echo calc.at:463 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:463: \$PREPARSER ./calc /dev/null"
echo calc.at:463 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:463: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:463 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:463: cat stderr"
echo calc.at:463 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:463: \$PREPARSER ./calc input"
echo calc.at:463 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:463: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:463 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "82
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:463: cat stderr"
echo calc.at:463 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:463: \$PREPARSER ./calc input"
echo calc.at:463 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "calc.at:463: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:463 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "21
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:463: cat stderr"
echo calc.at:463 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:463: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-10 ) # Banner 10. calc.at:470
    cat <<\_ATEOF

Simple GLR Calculator.

_ATEOF
    ;;

  61 ) # 61. calc.at:480: Calculator %glr_parser
    at_setup_line='calc.at:480'
    $at_verbose "61. calc.at:480: testing Calculator %glr_parser ..."
    $at_quiet $ECHO_N " 61: calc.at:480       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:480: bison -o calc.c   calc.y"
echo calc.at:480 >$at_check_line_file
( $at_traceon; bison -o calc.c   calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:480: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:480 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:480: \$PREPARSER ./calc input"
echo calc.at:480 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:480: \$PREPARSER ./calc input"
echo calc.at:480 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:480: cat stderr"
echo calc.at:480 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:480: \$PREPARSER ./calc input"
echo calc.at:480 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:480: cat stderr"
echo calc.at:480 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:480: \$PREPARSER ./calc input"
echo calc.at:480 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:480: cat stderr"
echo calc.at:480 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:480: \$PREPARSER ./calc input"
echo calc.at:480 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:480: cat stderr"
echo calc.at:480 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:480: \$PREPARSER ./calc input"
echo calc.at:480 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:480: cat stderr"
echo calc.at:480 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:480: \$PREPARSER ./calc /dev/null"
echo calc.at:480 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:480: cat stderr"
echo calc.at:480 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:480: \$PREPARSER ./calc input"
echo calc.at:480 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:480: cat stderr"
echo calc.at:480 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:480: \$PREPARSER ./calc input"
echo calc.at:480 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:480: cat stderr"
echo calc.at:480 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:480: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  62 ) # 62. calc.at:482: Calculator %glr_parser --defines
    at_setup_line='calc.at:482'
    $at_verbose "62. calc.at:482: testing Calculator %glr_parser --defines..."
    $at_quiet $ECHO_N " 62: calc.at:482       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:482: bison -o calc.c  --defines calc.y"
echo calc.at:482 >$at_check_line_file
( $at_traceon; bison -o calc.c  --defines calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:482: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:482 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:482: \$PREPARSER ./calc input"
echo calc.at:482 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:482: \$PREPARSER ./calc input"
echo calc.at:482 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:482: cat stderr"
echo calc.at:482 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:482: \$PREPARSER ./calc input"
echo calc.at:482 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:482: cat stderr"
echo calc.at:482 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:482: \$PREPARSER ./calc input"
echo calc.at:482 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:482: cat stderr"
echo calc.at:482 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:482: \$PREPARSER ./calc input"
echo calc.at:482 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:482: cat stderr"
echo calc.at:482 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:482: \$PREPARSER ./calc input"
echo calc.at:482 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:482: cat stderr"
echo calc.at:482 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:482: \$PREPARSER ./calc /dev/null"
echo calc.at:482 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:482: cat stderr"
echo calc.at:482 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:482: \$PREPARSER ./calc input"
echo calc.at:482 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:482: cat stderr"
echo calc.at:482 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:482: \$PREPARSER ./calc input"
echo calc.at:482 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:482: cat stderr"
echo calc.at:482 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:482: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  63 ) # 63. calc.at:483: Calculator %glr_parser --locations
    at_setup_line='calc.at:483'
    $at_verbose "63. calc.at:483: testing Calculator %glr_parser --locations..."
    $at_quiet $ECHO_N " 63: calc.at:483       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:483: bison -o calc.c  --locations calc.y"
echo calc.at:483 >$at_check_line_file
( $at_traceon; bison -o calc.c  --locations calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:483: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:483 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:483: \$PREPARSER ./calc input"
echo calc.at:483 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:483: \$PREPARSER ./calc input"
echo calc.at:483 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:483: cat stderr"
echo calc.at:483 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:483: \$PREPARSER ./calc input"
echo calc.at:483 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:483: cat stderr"
echo calc.at:483 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:483: \$PREPARSER ./calc input"
echo calc.at:483 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:483: cat stderr"
echo calc.at:483 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:483: \$PREPARSER ./calc input"
echo calc.at:483 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:483: cat stderr"
echo calc.at:483 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:483: \$PREPARSER ./calc input"
echo calc.at:483 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:483: cat stderr"
echo calc.at:483 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:483: \$PREPARSER ./calc /dev/null"
echo calc.at:483 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:483: cat stderr"
echo calc.at:483 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:483: \$PREPARSER ./calc input"
echo calc.at:483 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:483: cat stderr"
echo calc.at:483 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:483: \$PREPARSER ./calc input"
echo calc.at:483 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:483: cat stderr"
echo calc.at:483 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:483: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  64 ) # 64. calc.at:484: Calculator %glr_parser --name-prefix=calc
    at_setup_line='calc.at:484'
    $at_verbose "64. calc.at:484: testing Calculator %glr_parser --name-prefix=calc..."
    $at_quiet $ECHO_N " 64: calc.at:484       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:484: bison -o calc.c  --name-prefix=calc calc.y"
echo calc.at:484 >$at_check_line_file
( $at_traceon; bison -o calc.c  --name-prefix=calc calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:484: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:484 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:484: \$PREPARSER ./calc input"
echo calc.at:484 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:484: \$PREPARSER ./calc input"
echo calc.at:484 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:484: cat stderr"
echo calc.at:484 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:484: \$PREPARSER ./calc input"
echo calc.at:484 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:484: cat stderr"
echo calc.at:484 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:484: \$PREPARSER ./calc input"
echo calc.at:484 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:484: cat stderr"
echo calc.at:484 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:484: \$PREPARSER ./calc input"
echo calc.at:484 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:484: cat stderr"
echo calc.at:484 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:484: \$PREPARSER ./calc input"
echo calc.at:484 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:484: cat stderr"
echo calc.at:484 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:484: \$PREPARSER ./calc /dev/null"
echo calc.at:484 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:484: cat stderr"
echo calc.at:484 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:484: \$PREPARSER ./calc input"
echo calc.at:484 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:484: cat stderr"
echo calc.at:484 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:484: \$PREPARSER ./calc input"
echo calc.at:484 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:484: cat stderr"
echo calc.at:484 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:484: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  65 ) # 65. calc.at:485: Calculator %glr_parser --verbose
    at_setup_line='calc.at:485'
    $at_verbose "65. calc.at:485: testing Calculator %glr_parser --verbose..."
    $at_quiet $ECHO_N " 65: calc.at:485       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:485: bison -o calc.c  --verbose calc.y"
echo calc.at:485 >$at_check_line_file
( $at_traceon; bison -o calc.c  --verbose calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:485: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:485 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:485: \$PREPARSER ./calc input"
echo calc.at:485 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:485: \$PREPARSER ./calc input"
echo calc.at:485 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:485: cat stderr"
echo calc.at:485 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:485: \$PREPARSER ./calc input"
echo calc.at:485 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:485: cat stderr"
echo calc.at:485 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:485: \$PREPARSER ./calc input"
echo calc.at:485 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:485: cat stderr"
echo calc.at:485 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:485: \$PREPARSER ./calc input"
echo calc.at:485 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:485: cat stderr"
echo calc.at:485 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:485: \$PREPARSER ./calc input"
echo calc.at:485 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:485: cat stderr"
echo calc.at:485 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:485: \$PREPARSER ./calc /dev/null"
echo calc.at:485 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:485: cat stderr"
echo calc.at:485 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:485: \$PREPARSER ./calc input"
echo calc.at:485 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:485: cat stderr"
echo calc.at:485 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:485: \$PREPARSER ./calc input"
echo calc.at:485 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:485: cat stderr"
echo calc.at:485 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:485: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  66 ) # 66. calc.at:486: Calculator %glr_parser --yacc
    at_setup_line='calc.at:486'
    $at_verbose "66. calc.at:486: testing Calculator %glr_parser --yacc..."
    $at_quiet $ECHO_N " 66: calc.at:486       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:486: bison -o calc.c  --yacc calc.y"
echo calc.at:486 >$at_check_line_file
( $at_traceon; bison -o calc.c  --yacc calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:486: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:486 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:486: \$PREPARSER ./calc input"
echo calc.at:486 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:486: \$PREPARSER ./calc input"
echo calc.at:486 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:486: cat stderr"
echo calc.at:486 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:486: \$PREPARSER ./calc input"
echo calc.at:486 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:486: cat stderr"
echo calc.at:486 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:486: \$PREPARSER ./calc input"
echo calc.at:486 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:486: cat stderr"
echo calc.at:486 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:486: \$PREPARSER ./calc input"
echo calc.at:486 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:486: cat stderr"
echo calc.at:486 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:486: \$PREPARSER ./calc input"
echo calc.at:486 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:486: cat stderr"
echo calc.at:486 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:486: \$PREPARSER ./calc /dev/null"
echo calc.at:486 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:486: cat stderr"
echo calc.at:486 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:486: \$PREPARSER ./calc input"
echo calc.at:486 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:486: cat stderr"
echo calc.at:486 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:486: \$PREPARSER ./calc input"
echo calc.at:486 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:486: cat stderr"
echo calc.at:486 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:486: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  67 ) # 67. calc.at:487: Calculator %glr_parser %error-verbose
    at_setup_line='calc.at:487'
    $at_verbose "67. calc.at:487: testing Calculator %glr_parser %error-verbose..."
    $at_quiet $ECHO_N " 67: calc.at:487       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser %error-verbose

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:487: bison -o calc.c   calc.y"
echo calc.at:487 >$at_check_line_file
( $at_traceon; bison -o calc.c   calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:487: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:487 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:487: \$PREPARSER ./calc input"
echo calc.at:487 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:487: \$PREPARSER ./calc input"
echo calc.at:487 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:487: cat stderr"
echo calc.at:487 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:487: \$PREPARSER ./calc input"
echo calc.at:487 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:487: cat stderr"
echo calc.at:487 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:487: \$PREPARSER ./calc input"
echo calc.at:487 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:487: cat stderr"
echo calc.at:487 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:487: \$PREPARSER ./calc input"
echo calc.at:487 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:487: cat stderr"
echo calc.at:487 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:487: \$PREPARSER ./calc input"
echo calc.at:487 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:487: cat stderr"
echo calc.at:487 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:487: \$PREPARSER ./calc /dev/null"
echo calc.at:487 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:487: cat stderr"
echo calc.at:487 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:487: \$PREPARSER ./calc input"
echo calc.at:487 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:487: cat stderr"
echo calc.at:487 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:487: \$PREPARSER ./calc input"
echo calc.at:487 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:487: cat stderr"
echo calc.at:487 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:487: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  68 ) # 68. calc.at:489: Calculator %glr_parser %error-verbose --locations
    at_setup_line='calc.at:489'
    $at_verbose "68. calc.at:489: testing Calculator %glr_parser %error-verbose --locations..."
    $at_quiet $ECHO_N " 68: calc.at:489       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser %error-verbose

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:489: bison -o calc.c   --locations calc.y"
echo calc.at:489 >$at_check_line_file
( $at_traceon; bison -o calc.c   --locations calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:489: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:489 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:489: \$PREPARSER ./calc input"
echo calc.at:489 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:489: \$PREPARSER ./calc input"
echo calc.at:489 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:489: cat stderr"
echo calc.at:489 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:489: \$PREPARSER ./calc input"
echo calc.at:489 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:489: cat stderr"
echo calc.at:489 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:489: \$PREPARSER ./calc input"
echo calc.at:489 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:489: cat stderr"
echo calc.at:489 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:489: \$PREPARSER ./calc input"
echo calc.at:489 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:489: cat stderr"
echo calc.at:489 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:489: \$PREPARSER ./calc input"
echo calc.at:489 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:489: cat stderr"
echo calc.at:489 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:489: \$PREPARSER ./calc /dev/null"
echo calc.at:489 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:489: cat stderr"
echo calc.at:489 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:489: \$PREPARSER ./calc input"
echo calc.at:489 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:489: cat stderr"
echo calc.at:489 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:489: \$PREPARSER ./calc input"
echo calc.at:489 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:489: cat stderr"
echo calc.at:489 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:489: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  69 ) # 69. calc.at:491: Calculator %glr_parser %error-verbose --defines --locations --name-prefix=calc --verbose --yacc
    at_setup_line='calc.at:491'
    $at_verbose "69. calc.at:491: testing Calculator %glr_parser %error-verbose --defines --locations --name-prefix=calc --verbose --yacc..."
    $at_quiet $ECHO_N " 69: calc.at:491       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser %error-verbose

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:491: bison -o calc.c   --defines --locations --name-prefix=calc --verbose --yacc calc.y"
echo calc.at:491 >$at_check_line_file
( $at_traceon; bison -o calc.c   --defines --locations --name-prefix=calc --verbose --yacc calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:491: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:491 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:491: \$PREPARSER ./calc input"
echo calc.at:491 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:491: \$PREPARSER ./calc input"
echo calc.at:491 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:491: cat stderr"
echo calc.at:491 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:491: \$PREPARSER ./calc input"
echo calc.at:491 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:491: cat stderr"
echo calc.at:491 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:491: \$PREPARSER ./calc input"
echo calc.at:491 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:491: cat stderr"
echo calc.at:491 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:491: \$PREPARSER ./calc input"
echo calc.at:491 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:491: cat stderr"
echo calc.at:491 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:491: \$PREPARSER ./calc input"
echo calc.at:491 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:491: cat stderr"
echo calc.at:491 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:491: \$PREPARSER ./calc /dev/null"
echo calc.at:491 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:491: cat stderr"
echo calc.at:491 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:491: \$PREPARSER ./calc input"
echo calc.at:491 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:491: cat stderr"
echo calc.at:491 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:491: \$PREPARSER ./calc input"
echo calc.at:491 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:491: cat stderr"
echo calc.at:491 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:491: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  70 ) # 70. calc.at:493: Calculator %glr_parser %debug
    at_setup_line='calc.at:493'
    $at_verbose "70. calc.at:493: testing Calculator %glr_parser %debug..."
    $at_quiet $ECHO_N " 70: calc.at:493       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser %debug

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:493: bison -o calc.c   calc.y"
echo calc.at:493 >$at_check_line_file
( $at_traceon; bison -o calc.c   calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:493: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:493 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:493: \$PREPARSER ./calc input"
echo calc.at:493 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:493: \$PREPARSER ./calc input"
echo calc.at:493 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:493: cat stderr"
echo calc.at:493 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:493: \$PREPARSER ./calc input"
echo calc.at:493 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:493: cat stderr"
echo calc.at:493 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:493: \$PREPARSER ./calc input"
echo calc.at:493 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:493: cat stderr"
echo calc.at:493 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:493: \$PREPARSER ./calc input"
echo calc.at:493 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:493: cat stderr"
echo calc.at:493 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:493: \$PREPARSER ./calc input"
echo calc.at:493 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:493: cat stderr"
echo calc.at:493 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:493: \$PREPARSER ./calc /dev/null"
echo calc.at:493 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:493: cat stderr"
echo calc.at:493 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:493: \$PREPARSER ./calc input"
echo calc.at:493 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:493: cat stderr"
echo calc.at:493 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:493: \$PREPARSER ./calc input"
echo calc.at:493 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/parse error, .*$/parse error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
$at_verbose "calc.at:493: cat stderr"
echo calc.at:493 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:493: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  71 ) # 71. calc.at:494: Calculator %glr_parser %error-verbose %debug --defines --locations --name-prefix=calc --verbose --yacc
    at_setup_line='calc.at:494'
    $at_verbose "71. calc.at:494: testing Calculator %glr_parser %error-verbose %debug --defines --locations --name-prefix=calc --verbose --yacc..."
    $at_quiet $ECHO_N " 71: calc.at:494       $ECHO_C"
    (
      $at_traceon


cat >calc.y <<'_ATEOF'
/* Infix notation calculator--calc */

%{
#include <config.h>
/* We don't need a perfect malloc for these tests. */
#undef malloc
#include <stdio.h>

#if STDC_HEADERS
# include <stdlib.h>
# include <string.h>
#else
char *strcat(char *dest, const char *src);
#endif
#include <ctype.h>

static int power (int base, int exponent);
static void yyerror (const char *s);
static int yylex (void);
static int yygetc (void);
static void yyungetc (int c);

extern void perror (const char *s);

/* Exercise pre-prologue dependency to %union.  */
typedef int value_t;

%}

/* Exercise %union. */
%union
{
  value_t ival;
};

/* Bison Declarations */
%token CALC_EOF 0 "end of file"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

%glr_parser %error-verbose %debug

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'      {}
| exp '\n'  {}
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
     if ($1 != $3)
       fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
     $$ = $1 == $3;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 0;              }
;
%%
/* The input. */
FILE *yyin;

static void
yyerror (const char *s)
{
#if YYLSP_NEEDED
  fprintf (stderr, "%d.%d-%d.%d: ",
	   yylloc.first_line, yylloc.first_column,
	   yylloc.last_line, yylloc.last_column);
#endif
  fprintf (stderr, "%s\n", s);
}


#if YYLSP_NEEDED
static YYLTYPE last_yylloc;
#endif
static int
yygetc (void)
{
  int res = getc (yyin);
#if YYLSP_NEEDED
  last_yylloc = yylloc;
  if (res == '\n')
    {
      yylloc.last_line++;
      yylloc.last_column = 1;
    }
  else
    yylloc.last_column++;
#endif
  return res;
}


static void
yyungetc (int c)
{
#if YYLSP_NEEDED
  /* Wrong when C == `\n'. */
  yylloc = last_yylloc;
#endif
  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc (c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  int c;

#if YYLSP_NEEDED
  yylloc.first_column = yylloc.last_column;
  yylloc.first_line = yylloc.last_line;
#endif

  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
#if YYLSP_NEEDED
      yylloc.first_column = yylloc.last_column;
      yylloc.first_line = yylloc.last_line;
#endif
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (c);
      yylval.ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}

int
main (int argc, const char **argv)
{
  yyin = NULL;

  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

#if YYDEBUG
  yydebug = 1;
#endif
#if YYLSP_NEEDED
  yylloc.last_column = 1;
  yylloc.last_line = 1;
#endif
  yyparse ();
  return 0;
}
_ATEOF




# Specify the output files to avoid problems on different file systems.
$at_traceoff
$at_verbose "calc.at:494: bison -o calc.c    --defines --locations --name-prefix=calc --verbose --yacc calc.y"
echo calc.at:494 >$at_check_line_file
( $at_traceon; bison -o calc.c    --defines --locations --name-prefix=calc --verbose --yacc calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "calc.at:494: \$CC \$CFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:494 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
$at_verbose "calc.at:494: \$PREPARSER ./calc input"
echo calc.at:494 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon




# Some parse errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
$at_verbose "calc.at:494: \$PREPARSER ./calc input"
echo calc.at:494 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:494: cat stderr"
echo calc.at:494 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
$at_verbose "calc.at:494: \$PREPARSER ./calc input"
echo calc.at:494 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3-1.4: parse error, unexpected '/', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:494: cat stderr"
echo calc.at:494 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
$at_verbose "calc.at:494: \$PREPARSER ./calc input"
echo calc.at:494 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected $undefined, expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:494: cat stderr"
echo calc.at:494 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
$at_verbose "calc.at:494: \$PREPARSER ./calc input"
echo calc.at:494 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.7-1.8: parse error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:494: cat stderr"
echo calc.at:494 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
$at_verbose "calc.at:494: \$PREPARSER ./calc input"
echo calc.at:494 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.1-2.2: parse error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:494: cat stderr"
echo calc.at:494 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
$at_verbose "calc.at:494: \$PREPARSER ./calc /dev/null"
echo calc.at:494 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1-1.2: parse error, unexpected "end of file", expecting "number" or '-' or '\n' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:494: cat stderr"
echo calc.at:494 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure i. to have several errors, ii. to test the action
# associated to `error'.
cat >input <<'_ATEOF'
(1 ++ 2) + (0 0) = 1
_ATEOF

$at_traceoff
$at_verbose "calc.at:494: \$PREPARSER ./calc input"
echo calc.at:494 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.5-1.6: parse error, unexpected '+', expecting "number" or '-' or '('
1.15-1.16: parse error, unexpected "number"
calc: error: 0 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:494: cat stderr"
echo calc.at:494 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Add a studid example demonstrating that Bison can further improve the
# error message.  FIXME: Fix this ridiculous message.
cat >input <<'_ATEOF'
()
_ATEOF

$at_traceoff
$at_verbose "calc.at:494: \$PREPARSER ./calc input"
echo calc.at:494 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; tee stderr <$at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2-1.3: parse error, unexpected ')', expecting "number" or '-' or '('
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
$at_verbose "calc.at:494: cat stderr"
echo calc.at:494 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff expout $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "calc.at:494: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-11 ) # Banner 11. torture.at:19
    cat <<\_ATEOF

Torture Tests.

_ATEOF
    ;;

  72 ) # 72. torture.at:140: Big triangle
    at_setup_line='torture.at:140'
    $at_verbose "72. torture.at:140: testing Big triangle..."
    $at_quiet $ECHO_N " 72: torture.at:140    $ECHO_C"
    (
      $at_traceon


# I have been able to go up to 2000 on my machine.
# I tried 3000, a 29Mb grammar file, but then my system killed bison.
# With 500 and the new parser, which consume far too much memory,
# it gets killed too.  Of course the parser is to be cleaned.
cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
my $max = $ARGV[0] || 10;

print <<EOF;
%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define YYERROR_VERBOSE 1
#define YYDEBUG 1

static int yylex (void);
static void yyerror (const char *msg);
%}
%union
{
  int val;
};

%token END "end"
%type <val> exp input
EOF

for my $size (1 .. $max)
  {
    print "%token t$size $size \"$size\"\n";
  };

print <<EOF;
%%
input:
  exp        { assert (\$1 == 0); \$\$ = \$1; }
| input exp  { assert (\$2 == \$1 + 1); \$\$ = \$2; }
;

exp:
  END
    { \$\$ = 0; }
EOF

for my $size (1 .. $max)
  {
    use Text::Wrap;
    print wrap ("| ", "   ",
		(map { "\"$_\"" } (1 .. $size)),
		" END \n"),
		  "    { \$\$ = $size; }\n";
  };
print ";\n";

print <<EOF;
%%
static int
yylex (void)
{
  static int inner = 1;
  static int outer = 0;
  if (outer > $max)
    return 0;
  else if (inner > outer)
    {
      inner = 1;
      ++outer;
      return END;
    }
  return inner++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


$at_traceoff
$at_verbose "torture.at:146: perl -w ./gengram.pl 200 || exit 77"
echo torture.at:146 >$at_check_line_file
( $at_traceon; perl -w ./gengram.pl 200 || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:146: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

mv stdout input.y

$at_traceoff
$at_verbose "torture.at:147: bison -v -o input.c input.y"
echo torture.at:147 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:147: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "torture.at:148: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo torture.at:148 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:148: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "torture.at:149: \$PREPARSER ./input"
echo torture.at:149 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:149: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  73 ) # 73. torture.at:231: Big horizontal
    at_setup_line='torture.at:231'
    $at_verbose "73. torture.at:231: testing Big horizontal..."
    $at_quiet $ECHO_N " 73: torture.at:231    $ECHO_C"
    (
      $at_traceon


# I have been able to go up to 10000 on my machine, but I had to
# increase the maximum stack size (* 100).  It gave:
#
# input.y      263k
# input.tab.c  1.3M
# input        453k
#
# gengram.pl 10000                 0.70s user 0.01s sys  99% cpu    0.711 total
# bison input.y                  730.56s user 0.53s sys  99% cpu 12:12.34 total
# gcc -Wall input.tab.c -o input   5.81s user 0.20s sys 100% cpu     6.01 total
# ./input                          0.00s user 0.01s sys 108% cpu     0.01 total
#
cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
my $max = $ARGV[0] || 10;

print <<EOF;
%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define YYERROR_VERBOSE 1
#define YYDEBUG 1

static int yylex (void);
static void yyerror (const char *msg);
%}
EOF

for my $size (1 .. $max)
  {
    print "%token t$size $size \"$size\"\n";
  };

print <<EOF;
%%
EOF

use Text::Wrap;
print
  wrap ("exp: ", "  ",
	(map { "\"$_\"" } (1 .. $max)), ";"),
  "\n";

print <<EOF;
%%
static int
yylex (void)
{
  static int counter = 1;
  if (counter > $max)
    return 0;
  else
  return counter++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


$at_traceoff
$at_verbose "torture.at:245: perl -w ./gengram.pl 1000 || exit 77"
echo torture.at:245 >$at_check_line_file
( $at_traceon; perl -w ./gengram.pl 1000 || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:245: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

mv stdout input.y


# GNU m4 requires about 70 MiB for this test on a 32-bit host.
# Ask for 200 MiB, which should be plenty even on a 64-bit host.
data_limit=`(ulimit -S -d) 2>/dev/null`
case $data_limit in
[0-9]*)
  if test "$data_limit" -lt 204000; then
    ulimit -S -d 204000
  fi
esac

$at_traceoff
$at_verbose "torture.at:251: bison -v -o input.c input.y"
echo torture.at:251 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:251: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "torture.at:252: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo torture.at:252 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:252: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "torture.at:253: \$PREPARSER ./input"
echo torture.at:253 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:253: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  74 ) # 74. torture.at:367: Many lookaheads
    at_setup_line='torture.at:367'
    $at_verbose "74. torture.at:367: testing Many lookaheads..."
    $at_quiet $ECHO_N " 74: torture.at:367    $ECHO_C"
    (
      $at_traceon


cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
use Text::Wrap;
my $max = $ARGV[0] || 10;

print <<EOF;
%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define YYERROR_VERBOSE 1
#define YYDEBUG 1

static int yylex (void);
static void yyerror (const char *msg);
%}
%union
{
  int val;
};

%type <val> input exp
%token token
EOF

print
  wrap ("%type <val> ",
	"            ",
	map { "n$_" } (1 .. $max)),
  "\n";

for my $count (1 .. $max)
  {
    print "%token t$count $count \"$count\"\n";
  };

print <<EOF;
%%
input:
  exp        { assert (\$1 == 1); \$\$ = \$1; }
| input exp  { assert (\$2 == \$1 + 1); \$\$ = \$2; }
;

exp:
  n1 "1" { assert (\$1 == 1); }
EOF

for my $count (2 .. $max)
  {
    print "| n$count \"$count\" { assert (\$1 == $count); }\n";
  };
print ";\n";

for my $count (1 .. $max)
  {
    print "n$count: token { \$\$ = $count; };\n";
  };

print <<EOF;
%%
static int
yylex (void)
{
  static int return_token = 1;
  static int counter = 1;
  if (counter > $max)
    return 0;
  if (return_token)
    {
      return_token = 0;
      return token;
    }
  return_token = 1;
  return counter++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


$at_traceoff
$at_verbose "torture.at:369: perl -w ./gengram.pl 1000 || exit 77"
echo torture.at:369 >$at_check_line_file
( $at_traceon; perl -w ./gengram.pl 1000 || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; tee stdout <$at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:369: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

mv stdout input.y


# GNU m4 requires about 70 MiB for this test on a 32-bit host.
# Ask for 200 MiB, which should be plenty even on a 64-bit host.
data_limit=`(ulimit -S -d) 2>/dev/null`
case $data_limit in
[0-9]*)
  if test "$data_limit" -lt 204000; then
    ulimit -S -d 204000
  fi
esac

$at_traceoff
$at_verbose "torture.at:375: bison -v -o input.c input.y"
echo torture.at:375 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:375: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "torture.at:376: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo torture.at:376 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:376: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "torture.at:377: \$PREPARSER ./input"
echo torture.at:377 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:377: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  75 ) # 75. torture.at:441: Exploding the Stack Size with Alloca
    at_setup_line='torture.at:441'
    $at_verbose "75. torture.at:441: testing Exploding the Stack Size with Alloca..."
    $at_quiet $ECHO_N " 75: torture.at:441    $ECHO_C"
    (
      $at_traceon


# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

  static int yylex (void);
  static void yyerror (const char *msg);
%}
%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
  exit (1);
}

/* There are YYLVAL_MAX of WAIT_FOR_EOFs. */
unsigned int yylval_max;

static int
yylex (void)
{
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  assert (argc == 2);
  yylval = atoi (argv[1]);
  yydebug = 1;
  return yyparse ();
}
_ATEOF

$at_traceoff
$at_verbose "torture.at:443: bison -o input.c input.y"
echo torture.at:443 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:443: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "torture.at:443: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo torture.at:443 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:443: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Below the limit of 200.
$at_traceoff
$at_verbose "torture.at:446: \$PREPARSER ./input 20"
echo torture.at:446 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 20 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:446: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# Two enlargements: 2 * 2 * 200.
$at_traceoff
$at_verbose "torture.at:448: \$PREPARSER ./input 900"
echo torture.at:448 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 900 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:448: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# Fails: beyond the limit of 10,000 (which we don't reach anyway since we
# multiply by two starting at 200 => 5120 is the last possible).
$at_traceoff
$at_verbose "torture.at:451: \$PREPARSER ./input 10000"
echo torture.at:451 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 10000 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "torture.at:451: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  76 ) # 76. torture.at:462: Exploding the Stack Size with Malloc
    at_setup_line='torture.at:462'
    $at_verbose "76. torture.at:462: testing Exploding the Stack Size with Malloc..."
    $at_quiet $ECHO_N " 76: torture.at:462    $ECHO_C"
    (
      $at_traceon


# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#define YYSTACK_USE_ALLOCA 0
  static int yylex (void);
  static void yyerror (const char *msg);
%}
%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
  exit (1);
}

/* There are YYLVAL_MAX of WAIT_FOR_EOFs. */
unsigned int yylval_max;

static int
yylex (void)
{
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  assert (argc == 2);
  yylval = atoi (argv[1]);
  yydebug = 1;
  return yyparse ();
}
_ATEOF

$at_traceoff
$at_verbose "torture.at:464: bison -o input.c input.y"
echo torture.at:464 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:464: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "torture.at:464: \$CC \$CFLAGS \$CPPFLAGS input.c -o input"
echo torture.at:464 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:464: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon



# Below the limit of 200.
$at_traceoff
$at_verbose "torture.at:467: \$PREPARSER ./input 20"
echo torture.at:467 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 20 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:467: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# Two enlargements: 2 * 2 * 200.
$at_traceoff
$at_verbose "torture.at:469: \$PREPARSER ./input 900"
echo torture.at:469 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 900 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "torture.at:469: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

# Fails: beyond the limit of 10,000 (which we don't reach anyway since we
# multiply by two starting at 200 => 5120 is the possible).
$at_traceoff
$at_verbose "torture.at:472: \$PREPARSER ./input 10000"
echo torture.at:472 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 10000 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "torture.at:472: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-12 ) # Banner 12. existing.at:19
    cat <<\_ATEOF

Existing Grammars.

_ATEOF
    ;;

  77 ) # 77. existing.at:24: GNU AWK Grammar
    at_setup_line='existing.at:24'
    $at_verbose "77. existing.at:24: testing GNU AWK Grammar..."
    $at_quiet $ECHO_N " 77: existing.at:24    $ECHO_C"
    (
      $at_traceon


# We have been careful to strip all the actions excepts the
# mid-rule actions.  We rely on %expect to check that there are
# indeed 65 SR conflicts.
#
# Bison was once wrong, due to an incorrect computation of nullable.
# It reported 485 SR conflicts!

cat >input.y <<'_ATEOF'
%expect 65

%token FUNC_CALL NAME REGEXP
%token ERROR
%token YNUMBER YSTRING
%token RELOP APPEND_OP
%token ASSIGNOP MATCHOP NEWLINE CONCAT_OP
%token LEX_BEGIN LEX_END LEX_IF LEX_ELSE LEX_RETURN LEX_DELETE
%token LEX_WHILE LEX_DO LEX_FOR LEX_BREAK LEX_CONTINUE
%token LEX_PRINT LEX_PRINTF LEX_NEXT LEX_EXIT LEX_FUNCTION
%token LEX_GETLINE LEX_NEXTFILE
%token LEX_IN
%token LEX_AND LEX_OR INCREMENT DECREMENT
%token LEX_BUILTIN LEX_LENGTH

/* Lowest to highest */
%right ASSIGNOP
%right '?' ':'
%left LEX_OR
%left LEX_AND
%left LEX_GETLINE
%nonassoc LEX_IN
%left FUNC_CALL LEX_BUILTIN LEX_LENGTH
%nonassoc ','
%nonassoc MATCHOP
%nonassoc RELOP '<' '>' '|' APPEND_OP TWOWAYIO
%left CONCAT_OP
%left YSTRING YNUMBER
%left '+' '-'
%left '*' '/' '%'
%right '!' UNARY
%right '^'
%left INCREMENT DECREMENT
%left '$'
%left '(' ')'
%%

start
	: opt_nls program opt_nls
	;

program
	: rule
	| program rule
	| error
	| program error
	| /* empty */
	;

rule
	: LEX_BEGIN {} action
	| LEX_END {}   action
	| LEX_BEGIN statement_term
	| LEX_END statement_term
	| pattern action
	| action
	| pattern statement_term
	| function_prologue function_body
	;

func_name
	: NAME
	| FUNC_CALL
	| lex_builtin
	;

lex_builtin
	: LEX_BUILTIN
	| LEX_LENGTH
	;

function_prologue
	: LEX_FUNCTION {} func_name '(' opt_param_list r_paren opt_nls
	;

function_body
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;


pattern
	: exp
	| exp ',' exp
	;

regexp
	/*
	 * In this rule, want_regexp tells yylex that the next thing
	 * is a regexp so it should read up to the closing slash.
	 */
	: '/' {} REGEXP '/'
	;

action
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

statements
	: statement
	| statements statement
	| error
	| statements error
	;

statement_term
	: nls
	| semi opt_nls
	;

statement
	: semi opt_nls
	| l_brace r_brace
	| l_brace statements r_brace
	| if_statement
	| LEX_WHILE '(' exp r_paren opt_nls statement
	| LEX_DO opt_nls statement LEX_WHILE '(' exp r_paren opt_nls
	| LEX_FOR '(' NAME LEX_IN NAME r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls exp semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_BREAK statement_term
	| LEX_CONTINUE statement_term
	| print '(' expression_list r_paren output_redir statement_term
	| print opt_rexpression_list output_redir statement_term
	| LEX_NEXT statement_term
	| LEX_NEXTFILE statement_term
	| LEX_EXIT opt_exp statement_term
	| LEX_RETURN {} opt_exp statement_term
	| LEX_DELETE NAME '[' expression_list ']' statement_term
	| LEX_DELETE NAME  statement_term
	| exp statement_term
	;

print
	: LEX_PRINT
	| LEX_PRINTF
	;

if_statement
	: LEX_IF '(' exp r_paren opt_nls statement
	| LEX_IF '(' exp r_paren opt_nls statement
	     LEX_ELSE opt_nls statement
	;

nls
	: NEWLINE
	| nls NEWLINE
	;

opt_nls
	: /* empty */
	| nls
	;

input_redir
	: /* empty */
	| '<' simp_exp
	;

output_redir
	: /* empty */
	| '>' exp
	| APPEND_OP exp
	| '|' exp
	| TWOWAYIO exp
	;

opt_param_list
	: /* empty */
	| param_list
	;

param_list
	: NAME
	| param_list comma NAME
	| error
	| param_list error
	| param_list comma error
	;

/* optional expression, as in for loop */
opt_exp
	: /* empty */
	| exp
	;

opt_rexpression_list
	: /* empty */
	| rexpression_list
	;

rexpression_list
	: rexp
	| rexpression_list comma rexp
	| error
	| rexpression_list error
	| rexpression_list error rexp
	| rexpression_list comma error
	;

opt_expression_list
	: /* empty */
	| expression_list
	;

expression_list
	: exp
	| expression_list comma exp
	| error
	| expression_list error
	| expression_list error exp
	| expression_list comma error
	;

/* Expressions, not including the comma operator.  */
exp	: variable ASSIGNOP {} exp
	| '(' expression_list r_paren LEX_IN NAME
	| exp '|' LEX_GETLINE opt_variable
	| exp TWOWAYIO LEX_GETLINE opt_variable
	| LEX_GETLINE opt_variable input_redir
	| exp LEX_AND exp
	| exp LEX_OR exp
	| exp MATCHOP exp
	| regexp
	| '!' regexp %prec UNARY
	| exp LEX_IN NAME
	| exp RELOP exp
	| exp '<' exp
	| exp '>' exp
	| exp '?' exp ':' exp
	| simp_exp
	| exp simp_exp %prec CONCAT_OP
	;

rexp
	: variable ASSIGNOP {} rexp
	| rexp LEX_AND rexp
	| rexp LEX_OR rexp
	| LEX_GETLINE opt_variable input_redir
	| regexp
	| '!' regexp %prec UNARY
	| rexp MATCHOP rexp
	| rexp LEX_IN NAME
	| rexp RELOP rexp
	| rexp '?' rexp ':' rexp
	| simp_exp
	| rexp simp_exp %prec CONCAT_OP
	;

simp_exp
	: non_post_simp_exp
	/* Binary operators in order of decreasing precedence.  */
	| simp_exp '^' simp_exp
	| simp_exp '*' simp_exp
	| simp_exp '/' simp_exp
	| simp_exp '%' simp_exp
	| simp_exp '+' simp_exp
	| simp_exp '-' simp_exp
	| variable INCREMENT
	| variable DECREMENT
	;

non_post_simp_exp
	: '!' simp_exp %prec UNARY
	| '(' exp r_paren
	| LEX_BUILTIN
	  '(' opt_expression_list r_paren
	| LEX_LENGTH '(' opt_expression_list r_paren
	| LEX_LENGTH
	| FUNC_CALL '(' opt_expression_list r_paren
	| variable
	| INCREMENT variable
	| DECREMENT variable
	| YNUMBER
	| YSTRING
	| '-' simp_exp    %prec UNARY
	| '+' simp_exp    %prec UNARY
	;

opt_variable
	: /* empty */
	| variable
	;

variable
	: NAME
	| NAME '[' expression_list ']'
	| '$' non_post_simp_exp
	;

l_brace
	: '{' opt_nls
	;

r_brace
	: '}' opt_nls
	;

r_paren
	: ')'
	;

opt_semi
	: /* empty */
	| semi
	;

semi
	: ';'
	;

comma	: ',' opt_nls
	;

%%
_ATEOF


# Pass plenty of options, to exercise plenty of code, even if we
# don't actually check the output.  But SEGV is watching us, and
# so might do dmalloc.
$at_traceoff
$at_verbose "existing.at:355: bison --verbose --defines input.y"
echo existing.at:355 >$at_check_line_file
( $at_traceon; bison --verbose --defines input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "existing.at:355: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  78 ) # 78. existing.at:364: GNU Cim Grammar
    at_setup_line='existing.at:364'
    $at_verbose "78. existing.at:364: testing GNU Cim Grammar..."
    $at_quiet $ECHO_N " 78: existing.at:364   $ECHO_C"
    (
      $at_traceon


# GNU Cim, the GNU Simula 87 Compiler.

# Bison was once wrong, due to an incorrect computation of the RR conflicts.
# It reported 80 SR && 99 RR conflicts instead of 78/10!!!

cat >input.y <<'_ATEOF'
%union {
	long token;
	long ival;
        long arrdim;
	double rval;
	char *ident;
	char *tval;
	char stat_decl;
       }

%token
        HACTIVATE HAFTER /*HAND*/ HARRAY HAT
        HBEFORE HBEGIN HBOOLEAN
        HCHARACTER HCLASS /*HCOMMENT*/ HCONC
        HDELAY HDO
        HELSE HEND HEQ /*HEQV*/ HEXTERNAL
        HFOR
        HGE HGO HGOTO HGT
        HHIDDEN
        HIF /*HIMP*/ HIN HINNER HINSPECT HINTEGER HIS
        HLABEL HLE HLONG HLT
        HNAME HNE HNEW HNONE /*HNOT*/ HNOTEXT
        /*HOR*/ HOTHERWISE
        HPRIOR HPROCEDURE HPROTECTED
        HQUA
        HREACTIVATE HREAL HREF
        HSHORT HSTEP HSWITCH
        HTEXT HTHEN HTHIS HTO
        HUNTIL
        HVALUE HVAR HVIRTUAL
        HWHEN HWHILE

        HASSIGNVALUE HASSIGNREF
        /*HDOT*/ HPAREXPSEPARATOR HLABELSEPARATOR HSTATEMENTSEPARATOR
        HBEGPAR HENDPAR
        HEQR HNER
        HADD HSUB HMUL HDIV HINTDIV HEXP
  	HDOTDOTDOT

%token <ident> HIDENTIFIER
%token <ival> HBOOLEANKONST HINTEGERKONST HCHARACTERKONST
%token <rval> HREALKONST
%token <tval> HTEXTKONST

%type <tval> EXT_IDENT
%type <stat_decl> DECLSTATEMENT MODULSTATEMENT MBEE_DECLSTMS MBEE_DECLSTMSU
%type <stat_decl> MODULS
%type <ident> EXPRESSION_SIMP MBEE_ARG_R_PT
%type <arrdim> BAUND_PAIR_LIST

%right <token> HASSIGN
%left   HORELSE
%left   HANDTHEN
%left   HEQV
%left   HIMP
%left   HOR
%left   HAND

%left   HNOT

%left <token> HVALRELOPERATOR HREFRELOPERATOR HOBJRELOPERATOR

%left	HCONC

%left <token> HTERMOPERATOR
%left <token> UNEAR
%left <token> HFACTOROPERATOR
%left         HPRIMARYOPERATOR

%left   HQUA

%left   HDOT

%start  MAIN_MODULE
%%
/* GRAMATIKK FOR PROGRAM MODULES */
MAIN_MODULE     :       {	  categ=CLOCAL; mout(MBLOCK);
                                  beginBlock(KBLOKK);separat_comp=FALSE;}
			MODULS	{ endBlock(NULL,CCNO);   mout(MENDBLOCK);}
  		|	error HSTATEMENTSEPARATOR MBEE_DECLSTMS
		;
EXT_DECLARATION	:	HEXTERNAL
			MBEE_TYPE
			HPROCEDURE
				{ MBEENEWBLOCK();
				  kind=KPROC;}
			EXT_LIST
		|
			HEXTERNAL
			HIDENTIFIER
			HPROCEDURE
				{ MBEENEWBLOCK();
				  type=TNOTY;
				  kind=KPROC;
				  if($2==Ckind)categ=CCPROC;else
				  yerror (1);
                                  ysensitive=sensitive;
                                  sensitive=ON;}
			HIDENTIFIER { $<ident>$=$5;
                                  sensitive=ysensitive;}
			EXTERNAL_KIND_ITEM
			        { categ=CLOCAL;}
		|	HEXTERNAL
			HCLASS
				{ MBEENEWBLOCK();
				  kind=KCLASS;}
			EXT_LIST

		;
EXTERNAL_KIND_ITEM:	EXT_IDENT
			HOBJRELOPERATOR
				{ if($2!=HIS)yerror (2);}
		        MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{         regDecl($6, type, KPROC, CCPROC);
                                          beginBlock(kind);}
                        HEADING EMPTY_BLOCK
				{ categ=CLOCAL;
				  endBlock($1==NULL?$<ident>0:tag($1),CCCPROC);}
/*		|
			EXT_IDENT
				{ if($1!=NULL)yerror (3);
				  regDecl($0, type, kind, categ);}
			MBEE_REST_EXT_LIST
				{ endBlock(NULL,CCNO);}
		;
MBEE_REST_EXT_LIST:	/* EMPTY
		|	HPAREXPSEPARATOR EXT_KIND_LIST
		;
EXT_KIND_LIST	:	EXT_KIND_ITEM
		|	EXT_KIND_LIST HPAREXPSEPARATOR EXT_KIND_ITEM
		;
EXT_KIND_ITEM	:	HIDENTIFIER
			EXT_IDENT
				{ if($2!=NULL)yerror (3);
				  regDecl($1, type, kind, categ);}*/
		;
EMPTY_BLOCK	:	/*EMPT*/
		|	HBEGIN HEND
		;
EXT_LIST	:	EXT_ITEM
		|	EXT_LIST HPAREXPSEPARATOR EXT_ITEM
		;
EXT_ITEM	:	HIDENTIFIER
			EXT_IDENT
				{ lesinn_external_spec($1,$2, kind);}
		;
EXT_IDENT	:	/* EMPTY */ { $$=NULL;}
		|	HVALRELOPERATOR { if($1!=HEQ)yerror (9);
                                          external=TRUE;}
			HTEXTKONST { $$=$3;external=FALSE;}
		;
/* GRAMATIKK FOR TYPER */
NO_TYPE         :       /*EMPT*/        { type=TNOTY;}
                ;
MBEE_TYPE       :       NO_TYPE
                |       TYPE
                ;
TYPE            :       HREF HBEGPAR
                        HIDENTIFIER
                                { prefquantident=$3;
                                          type=TREF;}
                        HENDPAR
                |       HTEXT           { type=TTEXT;}
                |       HBOOLEAN        { type=TBOOL;}
                |       HCHARACTER      { type=TCHAR;}
                |       HSHORT HINTEGER { type=TSHORT;}
                |       HINTEGER        { type=TINTG;}
                |       HREAL           { type=TREAL;}
                |       HLONG HREAL     { type=TLONG;}
                ;

/* GRAMATIKK FOR DEL AV SETNINGER */
MBEE_ELSE_PART  :       /*EMPT*/
/*		|	HELSE
			HIF
                        EXPRESSION
                        HTHEN   { 		  mout(MELSE);
						  mout(MIF);
                                  OBSBLOCK();}
                        BLOCK   { MBEEENDBLOCK();}
                        MBEE_ELSE_PART          { mout(MENDIF);}*/
                |       HELSE   { OBSBLOCK();     mout(MELSE);}
                        BLOCK   { MBEEENDBLOCK();}
                ;
FOR_LIST        :       FOR_LIST_ELEMENT        { mout(MENDSEP);
                                                  mout(MLISTSEP);}
                |       FOR_LIST_ELEMENT
                        HPAREXPSEPARATOR
                        FOR_LIST                { mout(MLISTSEP);}
                ;
FOR_LIST_ELEMENT:       EXPRESSION
                        MBEE_F_L_EL_R_PT
                ;
MBEE_F_L_EL_R_PT:       /*EMPT*/
                |       HWHILE
                        EXPRESSION              { mout(MFORWHILE);}
                |       HSTEP
                        EXPRESSION
                        HUNTIL
                        EXPRESSION              { mout(MUNTIL);
                                                  mout(MSTEP);}
                ;
GOTO            :       HGO
                        HTO
                |       HGOTO
                ;
CONN_STATE_R_PT :       WHEN_CLAUSE_LIST
                |       HDO   {   beginBlock(KCON);   mout(MDO);
                              OBSBLOCK(); }
                        BLOCK {   endBlock(NULL,CCNO);
                                  MBEEENDBLOCK();  mout(MENDDO);}
                ;
WHEN_CLAUSE_LIST:       HWHEN
                        HIDENTIFIER
                        HDO    {   beginBlock(KCON);  mout(MIDENTIFIER);
                                   OBSBLOCK();     moutId($2);
				   		   mout(MWHEN);}
                        BLOCK  {   endBlock(NULL,CCNO);
                              MBEEENDBLOCK(); mout(MENDWHEN);}
                |       WHEN_CLAUSE_LIST
                        HWHEN
                        HIDENTIFIER
                        HDO    { beginBlock(KCON);	   mout(MIDENTIFIER);
                                 OBSBLOCK();       moutId($3);
				 		   mout(MWHEN);}
                        BLOCK  { endBlock(NULL,CCNO);
                              MBEEENDBLOCK();    mout(MENDWHEN);}
                ;
MBEE_OTWI_CLAUS :       /*EMPT*/
                |       HOTHERWISE {OBSBLOCK();    mout(MOTHERWISE);}

                        BLOCK      {MBEEENDBLOCK();mout(MENDOTHERWISE);}
                ;
ACTIVATOR	:	HACTIVATE		{ mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		|	HREACTIVATE		{ mout(MBOOLEANKONST);
						  moutIval(TRUE);}
		;
SCHEDULE	:	/*EMPT*/		{ mout(MCHARACTERKONST);
						  moutIval(DIRECT);
						  mout(MINTEGERKONST);
						  moutIval(0);
						  mout(MNONE);
						  mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		|	ATDELAY EXPRESSION	{ mout(MNONE);}
			PRIOR
		|	BEFOREAFTER		{ mout(MINTEGERKONST);
						  moutIval(0);}
			EXPRESSION		{ mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		;
ATDELAY		:	HAT			{ mout(MCHARACTERKONST);
						  moutIval(AT);}
		|	HDELAY			{ mout(MCHARACTERKONST);
						  moutIval(DELAYS);}
		;
BEFOREAFTER	:	HBEFORE			{ mout(MCHARACTERKONST);
						  moutIval(BEFORE);}
		|	HAFTER			{ mout(MCHARACTERKONST);
						  moutIval(AFTER);}
		;
PRIOR		:	/*EMPT*/		{ mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		|	HPRIOR			{ mout(MBOOLEANKONST);
						  moutIval(TRUE);}
		;
/* GRAMATIKK FOR SETNINGER OG DEKLARASJONER */
MODULSTATEMENT  :       HWHILE
                        EXPRESSION
                        HDO     { STOPOBSBLOCK(); mout(MWHILE);
                                  OBSBLOCK();}
                        BLOCK   { MBEEENDBLOCK(); mout(MENDWHILE);
					  	          $$=STATEMENT;}
	    	|       HIF
                        EXPRESSION
                        HTHEN   { STOPOBSBLOCK(); mout(MIF);
                                  OBSBLOCK();}
                        BLOCK   { MBEEENDBLOCK();}
                        MBEE_ELSE_PART          { mout(MENDIF);
							  $$=STATEMENT;}
		|       HFOR
                        HIDENTIFIER
                        HASSIGN { STOPOBSBLOCK(); mout(MIDENTIFIER);
                                                  moutId($2);}
                        FOR_LIST
                        HDO     { beginBlock(KFOR);
                        if($3==HASSIGNVALUE)      mout(MFOR);
                                        else      mout(MFORR);
                                  OBSBLOCK();     mout(MFORDO);}
                        BLOCK   { MBEEENDBLOCK();
                                  endBlock(NULL,CCNO); mout(MENDFOR);
							  $$=STATEMENT;}
		|       GOTO
                        EXPRESSION              { mout(MGOTO);
                                  STOPOBSBLOCK();	  $$=STATEMENT;}
		|       HINSPECT
                        EXPRESSION              { mout(MINSPECT);
                                  STOPOBSBLOCK();
                                  beginBlock(KINSP);}
                        CONN_STATE_R_PT
                                { endBlock(NULL,CCNO);}
                        MBEE_OTWI_CLAUS         { mout(MENDINSPECT);
							  $$=STATEMENT;}
		|       HINNER  { STOPOBSBLOCK(); mout(MINNER);
                                  regInner();		  $$=STATEMENT;}
                |       HIDENTIFIER
                        HLABELSEPARATOR
                                { STOPOBSBLOCK();
                                  regDecl($1, TLABEL, KSIMPLE, categ);    mout(MLABEL);
                                                  moutId($1);
                                                  mout(MENDLABEL);}
                        DECLSTATEMENT   { if($4<=DECLARATION)
                                            { yerror (27);
                                              $$=DECLARATION;}
                                          else $$=$4;}
                |       EXPRESSION_SIMP
                        HBEGIN
                                { $<ident>$=$1; }
			IMPORT_SPEC_MODULE
				{ mout(MPRBLOCK);
				  prefquantident=$1;
                                  beginBlock(KPRBLK);}
                        MBEE_DECLSTMS
                        HEND    { endBlock(NULL,CCNO); mout(MENDPRBLOCK);
                                                          $$=STATEMENT;}
		|	EXPRESSION_SIMP HBEGIN error HSTATEMENTSEPARATOR
                        MBEE_DECLSTMS HEND              { $$=STATEMENT;
			         endBlock(NULL,CCNO); mout(MENDPRBLOCK);}
		|	EXPRESSION_SIMP HBEGIN error HEND
						        { $$=STATEMENT;
			         endBlock(NULL,CCNO); mout(MENDPRBLOCK);}

                |       EXPRESSION_SIMP
                                { STOPOBSBLOCK();         $$=STATEMENT;
                                                  mout(MENDASSIGN);}
		|	ACTIVATOR EXPRESSION SCHEDULE
						{      	  $$=STATEMENT;
						  mout(MENDSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENT);
						  moutId(activateid);
						  mout(MENDASSIGN);}
                |       HBEGIN
                                { STOPOBSBLOCK();
                                  OBSBLOCK();}
                        MBEE_DECLSTMS
                        HEND    { MBEEENDBLOCK();         $$=STATEMENT;}
		|       MBEE_TYPE HPROCEDURE
                        HIDENTIFIER
                                { MBEENEWBLOCK(); mout(MPROCEDURE);
                                          regDecl($3, type, KPROC, categ);
                                          beginBlock(KPROC);}
                        HEADING BLOCK   { endBlock(NULL,CCNO); $$=DECLARATION;
                                                  mout(MENDPROCEDURE);}
		|       HIDENTIFIER
			HCLASS
                        NO_TYPE
				{ $<ident>$=$1; }
			IMPORT_SPEC_MODULE
                        HIDENTIFIER
				{ prefquantident=$1;
				  mout(MCLASS);
                                          regDecl($6, TNOTY, KCLASS, categ);
                                          beginBlock(KCLASS);}
                        HEADING
                        BLOCK           { endBlock(NULL,CCNO); $$=DECLARATION;
                                                  mout(MENDCLASS);}
                |       HCLASS
                        NO_TYPE
                        HIDENTIFIER
                                { prefquantident=0;
                                  MBEENEWBLOCK(); mout(MCLASS);
                                          regDecl($3, TNOTY, KCLASS, categ);
                                          beginBlock(KCLASS);}
                        HEADING
                        BLOCK           { endBlock(NULL,CCNO); $$=DECLARATION;
                                                  mout(MENDCLASS);}
                |       EXT_DECLARATION			{ $$=EXTDECLARATION;}
		|       /*EMPT*/{ STOPOBSBLOCK();	  $$=EMPTYSTATEMENT;}
                ;
IMPORT_SPEC_MODULE:		{ MBEENEWBLOCK();
                                  kind=KCLASS;
				  if($<ident>0==simsetident &&
				     findDecl(simsetident,cblock,FALSE)==NULL)
				    lesinn_external_spec(simsetident,
					SIMSETATRFILE, kind);
				  if($<ident>0==simulationident && findDecl(
				    simulationident,cblock,FALSE)==NULL)
				    lesinn_external_spec(simulationident,
					SIMULATIONATRFILE, kind);
				  if(($<ident>0==fileident && findDecl(
				      fileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==outfileident && findDecl(
				      outfileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==infileident && findDecl(
				      infileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==directfileident && findDecl(
				      directfileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==printfileident && findDecl(
				      printfileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==bytefileident && findDecl(
				      bytefileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==inbytefileident && findDecl(
				      inbytefileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==outbytefileident && findDecl(
				      outbytefileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==directbytefileident && findDecl(
				      directbytefileident,cblock,FALSE)==NULL))
				    lesinn_external_spec(fileident,
					FILEATRFILE, kind);}
		;
DECLSTATEMENT	:	MODULSTATEMENT
		|       TYPE
                        HIDENTIFIER
			MBEE_CONSTANT
                        HPAREXPSEPARATOR
                                { MBEENEWBLOCK();
                                          kind=KSIMPLE;
                                          regDecl($2, type, KSIMPLE, categ);
					  categ=CLOCAL;}
                        IDENTIFIER_LISTC                { $$=DECLARATION;}
                |       TYPE
                        HIDENTIFIER
			MBEE_CONSTANT
                                { MBEENEWBLOCK();
                                          regDecl($2, type, KSIMPLE, categ);
					  categ=CLOCAL;	  $$=DECLARATION;}
                |       MBEE_TYPE
                        HARRAY  { MBEENEWBLOCK();
                                          kind=KARRAY;}
                        ARR_SEGMENT_LIST                { $$=DECLARATION;}
                |       HSWITCH
                        HIDENTIFIER
                        HASSIGN { MBEENEWBLOCK(); mout(MIDENTIFIER);
                                                  moutId($2);
                                          regDecl($2, TLABEL, KARRAY, categ);}
                        SWITCH_LIST                     { $$=DECLARATION;
                                                   mout(MSWITCH);
                                                   mout(MENDSWITCH);}
                ;
BLOCK           :       DECLSTATEMENT   { if($1<=DECLARATION)yerror (29);}
                |       HBEGIN MBEE_DECLSTMS HEND
		|	HBEGIN error HSTATEMENTSEPARATOR MBEE_DECLSTMS HEND
		|	HBEGIN error HEND
		;
MBEE_DECLSTMS   :       MBEE_DECLSTMSU  { if($1<=DECLARATION)yerror (28);
					  $$=$1;}
                ;
MBEE_DECLSTMSU  :       DECLSTATEMENT   { $$=$1;}
                |       MBEE_DECLSTMSU
                        HSTATEMENTSEPARATOR
                        DECLSTATEMENT   { if($1>=STATEMENT && $3<=DECLARATION)
                                            yerror (26);
                                          $$=$3;}
                ;
MODULS		:	MODULSTATEMENT	{ if($1==DECLARATION)
					  {separat_comp=TRUE;gettimestamp();}
                                          $$=$1;}
  		|	MODULS HSTATEMENTSEPARATOR MODULSTATEMENT
					{ if($1>=STATEMENT && $3<=DECLARATION)
                                            yerror (26);else
       					  if($1>=STATEMENT
					     && $3!=EMPTYSTATEMENT)yerror (25);
                                          if(separat_comp && $3==STATEMENT)
                                             yerror (25);
                                          if($3==DECLARATION && !separat_comp)
					  {separat_comp=TRUE;gettimestamp();}
					  $$=$3;}
		;
/* GRAMATIKK FOR DEL AV DEKLARASJONER */
ARR_SEGMENT_LIST:       ARR_SEGMENT
                |       ARR_SEGMENT_LIST
                        HPAREXPSEPARATOR
                        ARR_SEGMENT
                ;
ARR_SEGMENT	:       ARRAY_SEGMENT
                        HBEGPAR
                        BAUND_PAIR_LIST HENDPAR { mout(MARRAY);
                                                  mout(MENDARRAY);
                                                  setArrayDim($3);}
                ;
ARRAY_SEGMENT   :       ARRAY_SEGMENT_EL        { mout(MENDSEP);
                                                  mout(MARRAYSEP);}

                |       ARRAY_SEGMENT_EL
                        HPAREXPSEPARATOR
                        ARRAY_SEGMENT           { mout(MARRAYSEP);}
                ;
ARRAY_SEGMENT_EL:       HIDENTIFIER             { mout(MIDENTIFIER);
                                                  moutId($1);
                                                  regDecl($1, type, kind, categ);
				   if(lastArray==NULL)
                                     lastArray=cblock->lastparloc;}
                ;
BAUND_PAIR_LIST :       BAUND_PAIR              { mout(MENDSEP);
                                                  mout(MBOUNDSEP);
                                                  $$=1;}
                |       BAUND_PAIR
                        HPAREXPSEPARATOR
                        BAUND_PAIR_LIST         { mout(MBOUNDSEP);
                                                  $$=$3+1;}
                ;
BAUND_PAIR      :       EXPRESSION
                        HLABELSEPARATOR
                        EXPRESSION              { mout(MBOUNDPARSEP);}
                ;
SWITCH_LIST     :       EXPRESSION              { mout(MENDSEP);
                                                  mout(MSWITCHSEP);}
                |       EXPRESSION
                        HPAREXPSEPARATOR
                        SWITCH_LIST             { mout(MSWITCHSEP);}
                ;
HEADING         :       MBEE_FMAL_PAR_P HSTATEMENTSEPARATOR { kind=KNOKD;}
                        MBEE_MODE_PART  { categ=CSPEC;}
                        MBEE_SPEC_PART  { kind=KNOKD;}
                        MBEE_PROT_PART  { categ=CVIRT;}
                        MBEE_VIRT_PART
                                        { categ=CLOCAL;}
                ;
MBEE_FMAL_PAR_P :       /*EMPT*/
                |       FMAL_PAR_PART
                ;
FMAL_PAR_PART   :       HBEGPAR NO_TYPE
                        MBEE_LISTV HENDPAR
                ;
MBEE_LISTV      :       /*EMPT*/
                |       LISTV
                ;
LISTV           :       HIDENTIFIER     { regDecl($1, type, KNOKD, CDEFLT);}
                |	FPP_CATEG HDOTDOTDOT      { regDecl(varargsid, TVARARGS, KNOKD, categ);}
                |       HIDENTIFIER     { regDecl($1, type, KNOKD, CDEFLT);}
                        HPAREXPSEPARATOR LISTV {}
                |       FPP_SPEC
                |       FPP_SPEC
                        HPAREXPSEPARATOR LISTV
                ;
FPP_HEADING     :       HBEGPAR NO_TYPE
                        FPP_MBEE_LISTV HENDPAR
                ;
FPP_MBEE_LISTV  :       /*EMPT*/
                |       FPP_LISTV
                ;
FPP_LISTV       :	FPP_CATEG HDOTDOTDOT      { regDecl(varargsid, TVARARGS, KNOKD, categ);}
                |       FPP_SPEC
                |       FPP_SPEC
                        HPAREXPSEPARATOR LISTV
                ;
FPP_SPEC        :       FPP_CATEG SPECIFIER HIDENTIFIER
                                       { regDecl($3, type, kind, categ);}
		|	FPP_CATEG FPP_PROC_DECL_IN_SPEC
		;
FPP_CATEG       :       HNAME HLABELSEPARATOR
                                       { categ=CNAME;}
                |       HVALUE HLABELSEPARATOR
                                       { categ=CVALUE;}
                |       HVAR HLABELSEPARATOR
                                       { categ=CVAR;}
                |       /*EMPT*/       { categ=CDEFLT;}
                ;
FPP_PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
                        HIDENTIFIER
                                	{ $<ival>$=categ;
                                          regDecl($3, type, KPROC, categ);
                                          beginBlock(KPROC);}
                        FPP_HEADING
					{ categ=$<ival>4; /* M} settes tilbake*/}
				{ endBlock(NULL,CCNO);}
		;
IDENTIFIER_LISTV:       HIDENTIFIER     { regDecl($1, type, kind, categ);}
                |	HDOTDOTDOT {	  regDecl(varargsid, TVARARGS, kind, categ);}
                |       HIDENTIFIER     { regDecl($1, type, kind, categ);}
                        HPAREXPSEPARATOR IDENTIFIER_LISTV {}
                ;
MBEE_MODE_PART  :       /*EMPT*/
                |       MODE_PART
                ;
MODE_PART       :       NAME_PART
                |       VALUE_PART
                |       VAR_PART
                |       NAME_PART VALUE_PART
                |       VALUE_PART NAME_PART
                |       NAME_PART VAR_PART
                |       VAR_PART NAME_PART
                |       VALUE_PART VAR_PART
                |       VAR_PART VALUE_PART
                |       VAR_PART NAME_PART VALUE_PART
                |       NAME_PART VAR_PART VALUE_PART
                |       NAME_PART VALUE_PART VAR_PART
                |       VAR_PART VALUE_PART NAME_PART
                |       VALUE_PART VAR_PART NAME_PART
                |       VALUE_PART NAME_PART VAR_PART
                ;
NAME_PART       :       HNAME           { categ=CNAME;}
                        IDENTIFIER_LISTV
                        HSTATEMENTSEPARATOR
                ;
VAR_PART        :       HVAR            { categ=CVAR;}
                        IDENTIFIER_LISTV
                        HSTATEMENTSEPARATOR
                ;
VALUE_PART      :       HVALUE          { categ=CVALUE;}
                        IDENTIFIER_LISTV HSTATEMENTSEPARATOR
                ;
MBEE_SPEC_PART  :       /*EMPT*/
                |       SPEC_PART
                ;
SPEC_PART       :       ONE_SPEC
                |       SPEC_PART ONE_SPEC
                ;
ONE_SPEC	:	SPECIFIER IDENTIFIER_LIST HSTATEMENTSEPARATOR
		|	NO_TYPE HPROCEDURE HIDENTIFIER HOBJRELOPERATOR
			  { if($4!=HIS) yerror (8);}
			PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
                |       FPP_PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
                |       MBEE_TYPE HPROCEDURE HIDENTIFIER HSTATEMENTSEPARATOR
					{ yerror (45);}
                |       MBEE_TYPE HPROCEDURE HIDENTIFIER HPAREXPSEPARATOR
                        IDENTIFIER_LIST HSTATEMENTSEPARATOR
					{ yerror (45);}
		;
SPECIFIER       :       TYPE            { kind=KSIMPLE;}
                |       MBEE_TYPE
                        HARRAY          { kind=KARRAY;}
                |       HLABEL          { type=TLABEL;
                                          kind=KSIMPLE;}
                |       HSWITCH         { type=TLABEL;
                                          kind=KARRAY;}
                ;
PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
                        HIDENTIFIER
                                	{ $<ival>$=categ;
                                          regDecl($3, type, KPROC, categ);
                                          beginBlock(KPROC);}
                        HEADING
					{ categ=$<ival>4; /* M} settes tilbake*/}
			MBEE_BEGIN_END
				{ endBlock(NULL,CCNO);}
		;
MBEE_BEGIN_END	:	/* EMPTY */
		|	HBEGIN HEND
		;
MBEE_PROT_PART  :       /*EMPT*/
                |       PROTECTION_PART
                ;
PROTECTION_PART :       PROT_SPECIFIER IDENTIFIER_LIST
                        HSTATEMENTSEPARATOR
                |       PROTECTION_PART  PROT_SPECIFIER
                        IDENTIFIER_LIST HSTATEMENTSEPARATOR
                ;
PROT_SPECIFIER  :       HHIDDEN         { categ=CHIDEN;}
                |       HPROTECTED      { categ=CPROT;}
                |       HHIDDEN
                        HPROTECTED      { categ=CHIPRO;}
                |       HPROTECTED
                        HHIDDEN         { categ=CHIPRO;}
                ;
MBEE_VIRT_PART  :       /*EMPT*/
                |       VIRTUAL_PART
                ;
VIRTUAL_PART    :       HVIRTUAL
                        HLABELSEPARATOR
                        MBEE_SPEC_PART
                ;
IDENTIFIER_LIST :       HIDENTIFIER     { regDecl($1, type, kind, categ);}
                |       IDENTIFIER_LIST HPAREXPSEPARATOR
                        HIDENTIFIER     { regDecl($3, type, kind, categ);}
                ;
IDENTIFIER_LISTC:       HIDENTIFIER
			MBEE_CONSTANT   { regDecl($1, type, kind, categ);
					  categ=CLOCAL;}
                |       IDENTIFIER_LISTC HPAREXPSEPARATOR
                        HIDENTIFIER
			MBEE_CONSTANT   { regDecl($3, type, kind, categ);
					  categ=CLOCAL;}
                ;
MBEE_CONSTANT	:	/* EMPTY */
		|	HVALRELOPERATOR
				{ MBEENEWBLOCK();
			    if($1!=HEQ) yerror (8);
					  if(type==TREF)yerror (7);
					  categ=CCONSTU;
						  mout(MIDENTIFIER);
						  moutId($<token>0);}
			EXPRESSION		{ mout(MASSIGN);
						  mout(MCONST);}
		;

/* GRAMATIKK FOR UTTRYKK */
EXPRESSION      :       EXPRESSION_SIMP {}
                |       HIF
                        EXPRESSION
                        HTHEN
                        EXPRESSION
                        HELSE
                        EXPRESSION              { mout(MELSEE);
                                                  mout(MIFE);}
                ;
EXPRESSION_SIMP :	EXPRESSION_SIMP
			HASSIGN
			EXPRESSION { if($2==HASSIGNREF)mout(MASSIGNR);
                                          else    mout(MASSIGN);$$=NULL;}
		|

			EXPRESSION_SIMP
                        HCONC
                        EXPRESSION_SIMP         { mout(MCONC);$$=NULL;}
                |       EXPRESSION_SIMP HOR
                        HELSE
                        EXPRESSION_SIMP
                        %prec HORELSE           { mout(MORELSEE);$$=NULL;}
                |       EXPRESSION_SIMP HAND
                        HTHEN
                        EXPRESSION_SIMP
                        %prec HANDTHEN          { mout(MANDTHENE);$$=NULL;}
                |       EXPRESSION_SIMP
                        HEQV EXPRESSION_SIMP    { mout(MEQV);$$=NULL;}
                |       EXPRESSION_SIMP
                        HIMP EXPRESSION_SIMP    { mout(MIMP);$$=NULL;}
                |       EXPRESSION_SIMP
                        HOR EXPRESSION_SIMP     { mout(MOR);$$=NULL;}
                |       EXPRESSION_SIMP
                        HAND EXPRESSION_SIMP    { mout(MAND);$$=NULL;}
                |       HNOT EXPRESSION_SIMP    { mout(MNOT);$$=NULL;}
                |       EXPRESSION_SIMP
                        HVALRELOPERATOR
                        EXPRESSION_SIMP
                                { switch($2)
                                    {   case HEQ: mout(MEQ);break;
                                        case HNE: mout(MNE);break;
                                        case HLT: mout(MLT);break;
                                        case HLE: mout(MLE);break;
                                        case HGT: mout(MGT);break;
                                        case HGE: mout(MGE);break;
                                    }$$=NULL;}
                |       EXPRESSION_SIMP
                        HREFRELOPERATOR
                        EXPRESSION_SIMP
                                { if($2==HNER)    mout(MNER);
                                        else      mout(MEQR);$$=NULL;}
                |       EXPRESSION_SIMP
                        HOBJRELOPERATOR
                        EXPRESSION_SIMP
                                { if($2==HIS)     mout(MIS);
                                        else      mout(MINS);$$=NULL;}
                |       HTERMOPERATOR
                        EXPRESSION_SIMP %prec UNEAR
                                { if($1==HADD)    mout(MUADD);
                                        else      mout(MUSUB);$$=NULL;}
                |       EXPRESSION_SIMP
                        HTERMOPERATOR
                        EXPRESSION_SIMP
                                { if($2==HADD)    mout(MADD);
                                        else      mout(MSUB);$$=NULL;}
                |       EXPRESSION_SIMP
                        HFACTOROPERATOR
                        EXPRESSION_SIMP
                                { if($2==HMUL)    mout(MMUL); else
                                  if($2==HDIV)    mout(MDIV);
                                        else      mout(MINTDIV);$$=NULL;}
                |       EXPRESSION_SIMP
                        HPRIMARYOPERATOR
                        EXPRESSION_SIMP         { mout(MPRIMARY);$$=NULL;}
                |       HBEGPAR
                        EXPRESSION HENDPAR      { mout(MNOOP);$$=NULL;}
                |       HTEXTKONST              { mout(MTEXTKONST);
                                                  moutTval($1);$$=NULL;}
                |       HCHARACTERKONST         { mout(MCHARACTERKONST);
                                                  moutIval($1);$$=NULL;}
                |       HREALKONST              { mout(MREALKONST);
                                                  moutRval($1);$$=NULL;}
                |       HINTEGERKONST           { mout(MINTEGERKONST);
                                                  moutIval($1);$$=NULL;}
                |       HBOOLEANKONST           { mout(MBOOLEANKONST);
                                                  moutIval($1);$$=NULL;}
                |       HNONE                   { mout(MNONE);$$=NULL;}
                |       HIDENTIFIER
                                { $<ident>$=$1;}
                        MBEE_ARG_R_PT {}
                |       HTHIS HIDENTIFIER       { mout(MTHIS);
                                                  moutId($2);$$=NULL;}
                |       HNEW
                        HIDENTIFIER
                        ARG_R_PT                { mout(MNEWARG);
                                                  moutId($2);$$=NULL;}
                |       EXPRESSION_SIMP
                        HDOT
                        EXPRESSION_SIMP         { mout(MDOT);$$=NULL;}
                |       EXPRESSION_SIMP
                        HQUA HIDENTIFIER        { mout(MQUA);
                                                  moutId($3);$$=NULL;}
                ;
ARG_R_PT        :       /*EMPTY*/               { mout(MENDSEP);}
                |       HBEGPAR
                        ARGUMENT_LIST HENDPAR
                ;
MBEE_ARG_R_PT   :       /*EMPTY*/               { mout(MIDENTIFIER);
                                                  moutId($<ident>0);
						  $$=$<ident>0;}
                |       HBEGPAR
                        ARGUMENT_LIST HENDPAR   { mout(MARGUMENT);
                                                  moutId($<ident>0);}
                ;
ARGUMENT_LIST   :       EXPRESSION              { mout(MENDSEP);
                                                  mout(MARGUMENTSEP);}
                |       EXPRESSION
                        HPAREXPSEPARATOR
                        ARGUMENT_LIST           { mout(MARGUMENTSEP);}
                ;
%%
_ATEOF


# Pass plenty of options, to exercise plenty of code, even if we
# don't actually check the output.  But SEGV is watching us, and
# so might do dmalloc.
$at_traceoff
$at_verbose "existing.at:1195: bison --verbose --defines input.y"
echo existing.at:1195 >$at_check_line_file
( $at_traceon; bison --verbose --defines input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 78 shift/reduce conflicts and 10 reduce/reduce conflicts
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "existing.at:1195: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "existing.at:1207: grep '^State.*contains' input.output"
echo existing.at:1207 >$at_check_line_file
( $at_traceon; grep '^State.*contains' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "State 64 contains 14 shift/reduce conflicts.
State 164 contains 1 shift/reduce conflict.
State 201 contains 33 shift/reduce conflicts and 4 reduce/reduce conflicts.
State 206 contains 1 shift/reduce conflict.
State 240 contains 1 shift/reduce conflict.
State 335 contains 9 shift/reduce conflicts and 2 reduce/reduce conflicts.
State 356 contains 1 shift/reduce conflict.
State 360 contains 9 shift/reduce conflicts and 2 reduce/reduce conflicts.
State 427 contains 9 shift/reduce conflicts and 2 reduce/reduce conflicts.
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "existing.at:1207: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-13 ) # Banner 13. regression.at:19
    cat <<\_ATEOF

Regression tests.

_ATEOF
    ;;

  79 ) # 79. regression.at:27: Early token definitions
    at_setup_line='regression.at:27'
    $at_verbose "79. regression.at:27: testing Early token definitions..."
    $at_quiet $ECHO_N " 79: regression.at:27  $ECHO_C"
    (
      $at_traceon


# Found in GCJ: they expect the tokens to be defined before the user
# prologue, so that they can use the token definitions in it.

cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}

%union
{
  int val;
};
%{
#ifndef MY_TOKEN
# error "MY_TOKEN not defined."
#endif
%}
%token MY_TOKEN
%%
exp: MY_TOKEN;
%%
_ATEOF


$at_traceoff
$at_verbose "regression.at:53: bison -o input.c input.y"
echo regression.at:53 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:53: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "regression.at:54: \$CC \$CFLAGS \$CPPFLAGS -c input.c -o input.o"
echo regression.at:54 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c -o input.o ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:54: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  80 ) # 80. regression.at:65: Braces parsing
    at_setup_line='regression.at:65'
    $at_verbose "80. regression.at:65: testing Braces parsing..."
    $at_quiet $ECHO_N " 80: regression.at:65  $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
/* Bison used to swallow the character after `}'. */

%%
exp: { tests = {{{{{{{{{{}}}}}}}}}}; };
%%
_ATEOF


$at_traceoff
$at_verbose "regression.at:75: bison -v -o input.c input.y"
echo regression.at:75 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:75: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "regression.at:77: grep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c"
echo regression.at:77 >$at_check_line_file
( $at_traceon; grep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
(echo stdout:; cat $at_stdout) >&5
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:77: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  81 ) # 81. regression.at:87: Duplicate string
    at_setup_line='regression.at:87'
    $at_verbose "81. regression.at:87: testing Duplicate string..."
    $at_quiet $ECHO_N " 81: regression.at:87  $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
/* `Bison -v' used to dump core when two tokens are defined with the same
   string, as LE and GE below. */

%token NUM
%token LE "<="
%token GE "<="

%%
exp: '(' exp ')' | NUM ;
%%
_ATEOF


$at_traceoff
$at_verbose "regression.at:104: bison -v -o input.c input.y"
echo regression.at:104 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:6.8-14: warning: symbol \`\"<=\"' used more than once as a literal string
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:104: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  82 ) # 82. regression.at:113: Rule Line Numbers
    at_setup_line='regression.at:113'
    $at_verbose "82. regression.at:113: testing Rule Line Numbers..."
    $at_quiet $ECHO_N " 82: regression.at:113 $ECHO_C"
    (
      $at_traceon




cat >input.y <<'_ATEOF'
%%
expr:
'a'

{

}

'b'

{

}

|


{


}

'c'

{

};
_ATEOF


$at_traceoff
$at_verbose "regression.at:147: bison -o input.c -v input.y"
echo regression.at:147 >$at_check_line_file
( $at_traceon; bison -o input.c -v input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:147: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Check the contents of the report.
$at_traceoff
$at_verbose "regression.at:246: cat input.output"
echo regression.at:246 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Grammar

    0 \$accept: expr \$end

    1 @1: /* empty */

    2 expr: 'a' @1 'b'

    3 @2: /* empty */

    4 expr: @2 'c'


Terminals, with rules where they appear

\$end (0) 0
'a' (97) 2
'b' (98) 2
'c' (99) 4
error (256)


Nonterminals, with rules where they appear

\$accept (6)
    on left: 0
expr (7)
    on left: 2 4, on right: 0
@1 (8)
    on left: 1, on right: 2
@2 (9)
    on left: 3, on right: 4


state 0

    0 \$accept: . expr \$end

    'a'  shift, and go to state 1

    \$default  reduce using rule 3 (@2)

    expr  go to state 2
    @2    go to state 3


state 1

    2 expr: 'a' . @1 'b'

    \$default  reduce using rule 1 (@1)

    @1  go to state 4


state 2

    0 \$accept: expr . \$end

    \$end  shift, and go to state 5


state 3

    4 expr: @2 . 'c'

    'c'  shift, and go to state 6


state 4

    2 expr: 'a' @1 . 'b'

    'b'  shift, and go to state 7


state 5

    0 \$accept: expr \$end .

    \$default  accept


state 6

    4 expr: @2 'c' .

    \$default  reduce using rule 4 (expr)


state 7

    2 expr: 'a' @1 'b' .

    \$default  reduce using rule 2 (expr)
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:246: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  83 ) # 83. regression.at:257: Mixing %token styles
    at_setup_line='regression.at:257'
    $at_verbose "83. regression.at:257: testing Mixing %token styles..."
    $at_quiet $ECHO_N " 83: regression.at:257 $ECHO_C"
    (
      $at_traceon


# Taken from the documentation.
cat >input.y <<'_ATEOF'
%token  <operator>  OR      "||"
%token  <operator>  LE 134  "<="
%left  OR  "<="
%%
exp: ;
%%
_ATEOF


$at_traceoff
$at_verbose "regression.at:269: bison -v -o input.c input.y"
echo regression.at:269 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:269: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  84 ) # 84. regression.at:280: Invalid inputs
    at_setup_line='regression.at:280'
    $at_verbose "84. regression.at:280: testing Invalid inputs..."
    $at_quiet $ECHO_N " 84: regression.at:280 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%%
?
default: 'a' }
%&
%a
%-
%{
_ATEOF


$at_traceoff
$at_verbose "regression.at:302: bison input.y"
echo regression.at:302 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:2.1: invalid character: \`?'
input.y:3.14: invalid character: \`}'
input.y:4.1: invalid character: \`%'
input.y:4.2: invalid character: \`&'
input.y:5.1: invalid character: \`%'
input.y:6.1: invalid character: \`%'
input.y:6.2: invalid character: \`-'
input.y:7.1-8.0: unexpected end of file in a prologue
input.y:7.1-8.0: parse error, unexpected \"%{...%}\", expecting \";\" or \"|\"
" | $at_diff - $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   1) ;;
   *) $at_verbose "regression.at:302: exit code was $at_status, expected 1" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  85 ) # 85. regression.at:313: Token definitions
    at_setup_line='regression.at:313'
    $at_verbose "85. regression.at:313: testing Token definitions..."
    $at_quiet $ECHO_N " 85: regression.at:313 $ECHO_C"
    (
      $at_traceon


# Bison managed, when fed with `%token 'f' "f"' to #define 'f'!
cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%token YYEOF 0 "end of file"
%token 'a' "a"
%token b "b"
%token c 'c'
%token 'd' d
%%
exp: "a";
_ATEOF


$at_traceoff
$at_verbose "regression.at:330: bison -o input.c input.y"
echo regression.at:330 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:330: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "regression.at:331: \$CC \$CFLAGS \$CPPFLAGS -c input.c -o input.o"
echo regression.at:331 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c -o input.o ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:331: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  86 ) # 86. regression.at:341: Characters Escapes
    at_setup_line='regression.at:341'
    $at_verbose "86. regression.at:341: testing Characters Escapes..."
    $at_quiet $ECHO_N " 86: regression.at:341 $ECHO_C"
    (
      $at_traceon


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp:
  '\'' "\'"
| '\"' "\""
| '"'  "'"
;
_ATEOF


$at_traceoff
$at_verbose "regression.at:356: bison -o input.c input.y"
echo regression.at:356 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:356: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "regression.at:357: \$CC \$CFLAGS \$CPPFLAGS -c input.c -o input.o"
echo regression.at:357 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c -o input.o ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:357: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  87 ) # 87. regression.at:371: Web2c Report
    at_setup_line='regression.at:371'
    $at_verbose "87. regression.at:371: testing Web2c Report..."
    $at_quiet $ECHO_N " 87: regression.at:371 $ECHO_C"
    (
      $at_traceon




cat >input.y <<'_ATEOF'
%token	undef_id_tok const_id_tok

%start CONST_DEC_PART

%%
CONST_DEC_PART:
         CONST_DEC_LIST
        ;

CONST_DEC_LIST:
	  CONST_DEC
        | CONST_DEC_LIST CONST_DEC
        ;

CONST_DEC:
	  { } undef_id_tok '=' const_id_tok ';'
        ;
%%
_ATEOF


$at_traceoff
$at_verbose "regression.at:396: bison -v input.y"
echo regression.at:396 >$at_check_line_file
( $at_traceon; bison -v input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:396: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "regression.at:521: cat input.output"
echo regression.at:521 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "Grammar

    0 \$accept: CONST_DEC_PART \$end

    1 CONST_DEC_PART: CONST_DEC_LIST

    2 CONST_DEC_LIST: CONST_DEC
    3               | CONST_DEC_LIST CONST_DEC

    4 @1: /* empty */

    5 CONST_DEC: @1 undef_id_tok '=' const_id_tok ';'


Terminals, with rules where they appear

\$end (0) 0
';' (59) 5
'=' (61) 5
error (256)
undef_id_tok (258) 5
const_id_tok (259) 5


Nonterminals, with rules where they appear

\$accept (7)
    on left: 0
CONST_DEC_PART (8)
    on left: 1, on right: 0
CONST_DEC_LIST (9)
    on left: 2 3, on right: 1 3
CONST_DEC (10)
    on left: 5, on right: 2 3
@1 (11)
    on left: 4, on right: 5


state 0

    0 \$accept: . CONST_DEC_PART \$end

    \$default  reduce using rule 4 (@1)

    CONST_DEC_PART  go to state 1
    CONST_DEC_LIST  go to state 2
    CONST_DEC       go to state 3
    @1              go to state 4


state 1

    0 \$accept: CONST_DEC_PART . \$end

    \$end  shift, and go to state 5


state 2

    1 CONST_DEC_PART: CONST_DEC_LIST .
    3 CONST_DEC_LIST: CONST_DEC_LIST . CONST_DEC

    undef_id_tok  reduce using rule 4 (@1)
    \$default      reduce using rule 1 (CONST_DEC_PART)

    CONST_DEC  go to state 6
    @1         go to state 4


state 3

    2 CONST_DEC_LIST: CONST_DEC .

    \$default  reduce using rule 2 (CONST_DEC_LIST)


state 4

    5 CONST_DEC: @1 . undef_id_tok '=' const_id_tok ';'

    undef_id_tok  shift, and go to state 7


state 5

    0 \$accept: CONST_DEC_PART \$end .

    \$default  accept


state 6

    3 CONST_DEC_LIST: CONST_DEC_LIST CONST_DEC .

    \$default  reduce using rule 3 (CONST_DEC_LIST)


state 7

    5 CONST_DEC: @1 undef_id_tok . '=' const_id_tok ';'

    '='  shift, and go to state 8


state 8

    5 CONST_DEC: @1 undef_id_tok '=' . const_id_tok ';'

    const_id_tok  shift, and go to state 9


state 9

    5 CONST_DEC: @1 undef_id_tok '=' const_id_tok . ';'

    ';'  shift, and go to state 10


state 10

    5 CONST_DEC: @1 undef_id_tok '=' const_id_tok ';' .

    \$default  reduce using rule 5 (CONST_DEC)
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:521: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  88 ) # 88. regression.at:548: Web2c Actions
    at_setup_line='regression.at:548'
    $at_verbose "88. regression.at:548: testing Web2c Actions..."
    $at_quiet $ECHO_N " 88: regression.at:548 $ECHO_C"
    (
      $at_traceon




cat >input.y <<'_ATEOF'
%%
statement:  struct_stat;
struct_stat:  /* empty. */ | if else;
if: "if" "const" "then" statement;
else: "else" statement;
%%
_ATEOF


$at_traceoff
$at_verbose "regression.at:561: bison -v -o input.c input.y"
echo regression.at:561 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:561: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


# Check only the tables.  We don't use --no-parser, because it is
# still to be implemented in the experimental branch of Bison.
sed -n 's/  *$//;/^static const.*\[\] =/,/^}/p' input.c >tables.c

$at_traceoff
$at_verbose "regression.at:659: cat tables.c"
echo regression.at:659 >$at_check_line_file
( $at_traceon; cat tables.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "static const unsigned char yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6
};
static const unsigned char yyprhs[] =
{
       0,     0,     3,     5,     6,     9,    14
};
static const yysigned_char yyrhs[] =
{
       8,     0,    -1,     9,    -1,    -1,    10,    11,    -1,     3,
       4,     5,     8,    -1,     6,     8,    -1
};
static const unsigned char yyrline[] =
{
       0,     2,     2,     3,     3,     4,     5
};
static const char *const yytname[] =
{
  \"\$end\", \"error\", \"\$undefined\", \"\\\"if\\\"\", \"\\\"const\\\"\", \"\\\"then\\\"\",
  \"\\\"else\\\"\", \"\$accept\", \"statement\", \"struct_stat\", \"if\", \"else\", 0
};
static const unsigned short yytoknum[] =
{
       0,   256,   257,   258,   259,   260,   261
};
static const unsigned char yyr1[] =
{
       0,     7,     8,     9,     9,    10,    11
};
static const unsigned char yyr2[] =
{
       0,     2,     1,     0,     2,     4,     2
};
static const unsigned char yydefact[] =
{
       3,     0,     0,     2,     0,     0,     1,     3,     4,     3,
       6,     5
};
static const yysigned_char yydefgoto[] =
{
      -1,     2,     3,     4,     8
};
static const yysigned_char yypact[] =
{
      -2,    -1,     4,    -8,     0,     2,    -8,    -2,    -8,    -2,
      -8,    -8
};
static const yysigned_char yypgoto[] =
{
      -8,    -7,    -8,    -8,    -8
};
static const unsigned char yytable[] =
{
      10,     1,    11,     5,     6,     0,     7,     9
};
static const yysigned_char yycheck[] =
{
       7,     3,     9,     4,     0,    -1,     6,     5
};
static const unsigned char yystos[] =
{
       0,     3,     8,     9,    10,     4,     0,     6,    11,     5,
       8,     8
};
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "regression.at:659: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  banner-14 ) # Banner 14. cxx-type.at:19
    cat <<\_ATEOF

C++ Type Syntax (GLR).

_ATEOF
    ;;

  89 ) # 89. cxx-type.at:226: GLR: Resolve ambiguity, impure, no locations
    at_setup_line='cxx-type.at:226'
    $at_verbose "89. cxx-type.at:226: testing GLR: Resolve ambiguity, impure, no locations..."
    $at_quiet $ECHO_N " 89: cxx-type.at:226   $ECHO_C"
    (
      $at_traceon

cat >types.y <<'_ATEOF'
/* Simplified C++ Type and Expression Grammar.  */



%{
  #include <stdio.h>
  #define YYSTYPE const char*
  #define YYLTYPE int

  #define YYINITDEPTH 10
  int yyerror (const char *s);

  #if YYPURE
  int yylex (YYSTYPE *lvalp);
  #else
  int yylex (void);
  #endif

%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   { printf ("\n"); }
     ;

stmt : expr ';'  %dprec 1
     | decl      %dprec 2
     | error ';'
     | '@'  { YYACCEPT; }
     ;

expr : ID 		{ printf ("%s ", $$); }
     | TYPENAME '(' expr ')'
			{ printf ("%s <cast> ", $1); }
     | expr '+' expr	{ printf ("+ "); }
     | expr '=' expr	{ printf ("= "); }
     ;

decl : TYPENAME declarator ';'
			{ printf ("%s <declare> ", $1); }
     | TYPENAME declarator '=' expr ';'
			{ printf ("%s <init-declare> ", $1); }
     ;

declarator : ID		{ printf ("\"%s\" ", $1); }
     | '(' declarator ')'
     ;

%%

#include <assert.h>
#include <ctype.h>
#include <string.h>

int
main (int argc, char** argv)
{
  assert (argc == 2);
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

#if YYPURE
int
yylex (YYSTYPE *lvalp)
#else
int
yylex ()
#endif
{
  char buffer[256];
  int c;

#if YYPURE
# define yylval (*lvalp)

#endif

  while (1) {
    c = getchar ();
    switch (c) {
    case EOF:
      return 0;
    case ' ': case '\t': case '\n': case '\f':
      break;
    default:
      if (isalpha (c)) {
	ungetc (c, stdin);
	scanf ("%[A-Za-z0-9_]", buffer);
	yylval = strdup (buffer);
	return isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
      }
      return c;
    }
  }
}

int
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
  return 0;
}



_ATEOF


cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
$at_verbose "cxx-type.at:227: bison -o types.c types.y"
echo cxx-type.at:227 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:227: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "cxx-type.at:227: \$CC \$CFLAGS \$CPPFLAGS types.c -o types"
echo cxx-type.at:227 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS types.c -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:227: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "cxx-type.at:229: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:229 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error
" | $at_diff - $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "z q +
\"x\" T <declare>
\"x\" y T <init-declare>
x y =
x T <cast> y +
\"x\" T <declare>
\"y\" z q + T <init-declare>
y
z q +
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:229: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  90 ) # 90. cxx-type.at:232: GLR: Resolve ambiguity, impure, locations
    at_setup_line='cxx-type.at:232'
    $at_verbose "90. cxx-type.at:232: testing GLR: Resolve ambiguity, impure, locations..."
    $at_quiet $ECHO_N " 90: cxx-type.at:232   $ECHO_C"
    (
      $at_traceon

cat >types.y <<'_ATEOF'
/* Simplified C++ Type and Expression Grammar.  */

%locations

%{
  #include <stdio.h>
  #define YYSTYPE const char*
  #define YYLTYPE int

  #define YYINITDEPTH 10
  int yyerror (const char *s);

  #if YYPURE
  int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
  #else
  int yylex (void);
  #endif

%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   { printf ("\n"); }
     ;

stmt : expr ';'  %dprec 1
     | decl      %dprec 2
     | error ';'
     | '@'  { YYACCEPT; }
     ;

expr : ID 		{ printf ("%s ", $$); }
     | TYPENAME '(' expr ')'
			{ printf ("%s <cast> ", $1); }
     | expr '+' expr	{ printf ("+ "); }
     | expr '=' expr	{ printf ("= "); }
     ;

decl : TYPENAME declarator ';'
			{ printf ("%s <declare> ", $1); }
     | TYPENAME declarator '=' expr ';'
			{ printf ("%s <init-declare> ", $1); }
     ;

declarator : ID		{ printf ("\"%s\" ", $1); }
     | '(' declarator ')'
     ;

%%

#include <assert.h>
#include <ctype.h>
#include <string.h>

int
main (int argc, char** argv)
{
  assert (argc == 2);
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

#if YYPURE
int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
#else
int
yylex ()
#endif
{
  char buffer[256];
  int c;

#if YYPURE
# define yylval (*lvalp)
  (void) llocp;
#endif

  while (1) {
    c = getchar ();
    switch (c) {
    case EOF:
      return 0;
    case ' ': case '\t': case '\n': case '\f':
      break;
    default:
      if (isalpha (c)) {
	ungetc (c, stdin);
	scanf ("%[A-Za-z0-9_]", buffer);
	yylval = strdup (buffer);
	return isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
      }
      return c;
    }
  }
}

int
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
  return 0;
}



_ATEOF


cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
$at_verbose "cxx-type.at:233: bison -o types.c types.y"
echo cxx-type.at:233 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:233: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "cxx-type.at:233: \$CC \$CFLAGS \$CPPFLAGS types.c -o types"
echo cxx-type.at:233 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS types.c -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:233: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "cxx-type.at:235: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:235 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error
" | $at_diff - $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "z q +
\"x\" T <declare>
\"x\" y T <init-declare>
x y =
x T <cast> y +
\"x\" T <declare>
\"y\" z q + T <init-declare>
y
z q +
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:235: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  91 ) # 91. cxx-type.at:238: GLR: Resolve ambiguity, pure, no locations
    at_setup_line='cxx-type.at:238'
    $at_verbose "91. cxx-type.at:238: testing GLR: Resolve ambiguity, pure, no locations..."
    $at_quiet $ECHO_N " 91: cxx-type.at:238   $ECHO_C"
    (
      $at_traceon

cat >types.y <<'_ATEOF'
/* Simplified C++ Type and Expression Grammar.  */

%pure-parser

%{
  #include <stdio.h>
  #define YYSTYPE const char*
  #define YYLTYPE int

  #define YYINITDEPTH 10
  int yyerror (const char *s);

  #if YYPURE
  int yylex (YYSTYPE *lvalp);
  #else
  int yylex (void);
  #endif

%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   { printf ("\n"); }
     ;

stmt : expr ';'  %dprec 1
     | decl      %dprec 2
     | error ';'
     | '@'  { YYACCEPT; }
     ;

expr : ID 		{ printf ("%s ", $$); }
     | TYPENAME '(' expr ')'
			{ printf ("%s <cast> ", $1); }
     | expr '+' expr	{ printf ("+ "); }
     | expr '=' expr	{ printf ("= "); }
     ;

decl : TYPENAME declarator ';'
			{ printf ("%s <declare> ", $1); }
     | TYPENAME declarator '=' expr ';'
			{ printf ("%s <init-declare> ", $1); }
     ;

declarator : ID		{ printf ("\"%s\" ", $1); }
     | '(' declarator ')'
     ;

%%

#include <assert.h>
#include <ctype.h>
#include <string.h>

int
main (int argc, char** argv)
{
  assert (argc == 2);
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

#if YYPURE
int
yylex (YYSTYPE *lvalp)
#else
int
yylex ()
#endif
{
  char buffer[256];
  int c;

#if YYPURE
# define yylval (*lvalp)

#endif

  while (1) {
    c = getchar ();
    switch (c) {
    case EOF:
      return 0;
    case ' ': case '\t': case '\n': case '\f':
      break;
    default:
      if (isalpha (c)) {
	ungetc (c, stdin);
	scanf ("%[A-Za-z0-9_]", buffer);
	yylval = strdup (buffer);
	return isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
      }
      return c;
    }
  }
}

int
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
  return 0;
}



_ATEOF


cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
$at_verbose "cxx-type.at:239: bison -o types.c types.y"
echo cxx-type.at:239 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:239: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "cxx-type.at:239: \$CC \$CFLAGS \$CPPFLAGS types.c -o types"
echo cxx-type.at:239 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS types.c -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:239: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "cxx-type.at:241: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:241 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error
" | $at_diff - $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "z q +
\"x\" T <declare>
\"x\" y T <init-declare>
x y =
x T <cast> y +
\"x\" T <declare>
\"y\" z q + T <init-declare>
y
z q +
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:241: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  92 ) # 92. cxx-type.at:244: GLR: Resolve ambiguity, pure, locations
    at_setup_line='cxx-type.at:244'
    $at_verbose "92. cxx-type.at:244: testing GLR: Resolve ambiguity, pure, locations..."
    $at_quiet $ECHO_N " 92: cxx-type.at:244   $ECHO_C"
    (
      $at_traceon

cat >types.y <<'_ATEOF'
/* Simplified C++ Type and Expression Grammar.  */

%pure-parser
%locations

%{
  #include <stdio.h>
  #define YYSTYPE const char*
  #define YYLTYPE int

  #define YYINITDEPTH 10
  int yyerror (const char *s);

  #if YYPURE
  int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
  #else
  int yylex (void);
  #endif

%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   { printf ("\n"); }
     ;

stmt : expr ';'  %dprec 1
     | decl      %dprec 2
     | error ';'
     | '@'  { YYACCEPT; }
     ;

expr : ID 		{ printf ("%s ", $$); }
     | TYPENAME '(' expr ')'
			{ printf ("%s <cast> ", $1); }
     | expr '+' expr	{ printf ("+ "); }
     | expr '=' expr	{ printf ("= "); }
     ;

decl : TYPENAME declarator ';'
			{ printf ("%s <declare> ", $1); }
     | TYPENAME declarator '=' expr ';'
			{ printf ("%s <init-declare> ", $1); }
     ;

declarator : ID		{ printf ("\"%s\" ", $1); }
     | '(' declarator ')'
     ;

%%

#include <assert.h>
#include <ctype.h>
#include <string.h>

int
main (int argc, char** argv)
{
  assert (argc == 2);
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

#if YYPURE
int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
#else
int
yylex ()
#endif
{
  char buffer[256];
  int c;

#if YYPURE
# define yylval (*lvalp)
  (void) llocp;
#endif

  while (1) {
    c = getchar ();
    switch (c) {
    case EOF:
      return 0;
    case ' ': case '\t': case '\n': case '\f':
      break;
    default:
      if (isalpha (c)) {
	ungetc (c, stdin);
	scanf ("%[A-Za-z0-9_]", buffer);
	yylval = strdup (buffer);
	return isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
      }
      return c;
    }
  }
}

int
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
  return 0;
}



_ATEOF


cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
$at_verbose "cxx-type.at:246: bison -o types.c types.y"
echo cxx-type.at:246 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:246: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "cxx-type.at:246: \$CC \$CFLAGS \$CPPFLAGS types.c -o types"
echo cxx-type.at:246 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS types.c -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:246: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "cxx-type.at:249: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:249 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error
" | $at_diff - $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "z q +
\"x\" T <declare>
\"x\" y T <init-declare>
x y =
x T <cast> y +
\"x\" T <declare>
\"y\" z q + T <init-declare>
y
z q +
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:249: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  93 ) # 93. cxx-type.at:252: GLR: Merge conflicting parses, impure, no locations
    at_setup_line='cxx-type.at:252'
    $at_verbose "93. cxx-type.at:252: testing GLR: Merge conflicting parses, impure, no locations..."
    $at_quiet $ECHO_N " 93: cxx-type.at:252   $ECHO_C"
    (
      $at_traceon

cat >types.y <<'_ATEOF'
/* Simplified C++ Type and Expression Grammar.  */



%{
  #include <stdio.h>
  #define YYSTYPE const char*
  #define YYLTYPE int
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  int yyerror (const char *s);

  #if YYPURE
  int yylex (YYSTYPE *lvalp);
  #else
  int yylex (void);
  #endif

%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   { printf ("\n"); }
     ;

stmt : expr ';'  %merge <stmtMerge>
     | decl      %merge <stmtMerge>
     | error ';'
     | '@'  { YYACCEPT; }
     ;

expr : ID 		{ printf ("%s ", $$); }
     | TYPENAME '(' expr ')'
			{ printf ("%s <cast> ", $1); }
     | expr '+' expr	{ printf ("+ "); }
     | expr '=' expr	{ printf ("= "); }
     ;

decl : TYPENAME declarator ';'
			{ printf ("%s <declare> ", $1); }
     | TYPENAME declarator '=' expr ';'
			{ printf ("%s <init-declare> ", $1); }
     ;

declarator : ID		{ printf ("\"%s\" ", $1); }
     | '(' declarator ')'
     ;

%%

#include <assert.h>
#include <ctype.h>
#include <string.h>

int
main (int argc, char** argv)
{
  assert (argc == 2);
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

#if YYPURE
int
yylex (YYSTYPE *lvalp)
#else
int
yylex ()
#endif
{
  char buffer[256];
  int c;

#if YYPURE
# define yylval (*lvalp)

#endif

  while (1) {
    c = getchar ();
    switch (c) {
    case EOF:
      return 0;
    case ' ': case '\t': case '\n': case '\f':
      break;
    default:
      if (isalpha (c)) {
	ungetc (c, stdin);
	scanf ("%[A-Za-z0-9_]", buffer);
	yylval = strdup (buffer);
	return isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
      }
      return c;
    }
  }
}

int
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
  return 0;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  /* Use the arguments. */
  (void) x0;
  (void) x1;
  printf ("<OR> ");
  return "";
}

_ATEOF


cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
$at_verbose "cxx-type.at:253: bison -o types.c types.y"
echo cxx-type.at:253 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:253: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "cxx-type.at:253: \$CC \$CFLAGS \$CPPFLAGS types.c -o types"
echo cxx-type.at:253 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS types.c -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:253: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "cxx-type.at:256: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:256 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error
" | $at_diff - $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "z q +
\"x\" T <declare>
\"x\" y T <init-declare>
x y =
x T <cast> y +
\"x\" T <declare> x T <cast> <OR>
\"y\" z q + T <init-declare> y T <cast> z q + = <OR>
y
z q +
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:256: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  94 ) # 94. cxx-type.at:259: GLR: Merge conflicting parses, impure, locations
    at_setup_line='cxx-type.at:259'
    $at_verbose "94. cxx-type.at:259: testing GLR: Merge conflicting parses, impure, locations..."
    $at_quiet $ECHO_N " 94: cxx-type.at:259   $ECHO_C"
    (
      $at_traceon

cat >types.y <<'_ATEOF'
/* Simplified C++ Type and Expression Grammar.  */

%locations

%{
  #include <stdio.h>
  #define YYSTYPE const char*
  #define YYLTYPE int
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  int yyerror (const char *s);

  #if YYPURE
  int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
  #else
  int yylex (void);
  #endif

%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   { printf ("\n"); }
     ;

stmt : expr ';'  %merge <stmtMerge>
     | decl      %merge <stmtMerge>
     | error ';'
     | '@'  { YYACCEPT; }
     ;

expr : ID 		{ printf ("%s ", $$); }
     | TYPENAME '(' expr ')'
			{ printf ("%s <cast> ", $1); }
     | expr '+' expr	{ printf ("+ "); }
     | expr '=' expr	{ printf ("= "); }
     ;

decl : TYPENAME declarator ';'
			{ printf ("%s <declare> ", $1); }
     | TYPENAME declarator '=' expr ';'
			{ printf ("%s <init-declare> ", $1); }
     ;

declarator : ID		{ printf ("\"%s\" ", $1); }
     | '(' declarator ')'
     ;

%%

#include <assert.h>
#include <ctype.h>
#include <string.h>

int
main (int argc, char** argv)
{
  assert (argc == 2);
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

#if YYPURE
int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
#else
int
yylex ()
#endif
{
  char buffer[256];
  int c;

#if YYPURE
# define yylval (*lvalp)
  (void) llocp;
#endif

  while (1) {
    c = getchar ();
    switch (c) {
    case EOF:
      return 0;
    case ' ': case '\t': case '\n': case '\f':
      break;
    default:
      if (isalpha (c)) {
	ungetc (c, stdin);
	scanf ("%[A-Za-z0-9_]", buffer);
	yylval = strdup (buffer);
	return isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
      }
      return c;
    }
  }
}

int
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
  return 0;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  /* Use the arguments. */
  (void) x0;
  (void) x1;
  printf ("<OR> ");
  return "";
}

_ATEOF


cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
$at_verbose "cxx-type.at:260: bison -o types.c types.y"
echo cxx-type.at:260 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:260: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "cxx-type.at:260: \$CC \$CFLAGS \$CPPFLAGS types.c -o types"
echo cxx-type.at:260 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS types.c -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:260: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "cxx-type.at:263: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:263 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error
" | $at_diff - $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "z q +
\"x\" T <declare>
\"x\" y T <init-declare>
x y =
x T <cast> y +
\"x\" T <declare> x T <cast> <OR>
\"y\" z q + T <init-declare> y T <cast> z q + = <OR>
y
z q +
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:263: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  95 ) # 95. cxx-type.at:266: GLR: Merge conflicting parses, pure, no locations
    at_setup_line='cxx-type.at:266'
    $at_verbose "95. cxx-type.at:266: testing GLR: Merge conflicting parses, pure, no locations..."
    $at_quiet $ECHO_N " 95: cxx-type.at:266   $ECHO_C"
    (
      $at_traceon

cat >types.y <<'_ATEOF'
/* Simplified C++ Type and Expression Grammar.  */

%pure-parser

%{
  #include <stdio.h>
  #define YYSTYPE const char*
  #define YYLTYPE int
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  int yyerror (const char *s);

  #if YYPURE
  int yylex (YYSTYPE *lvalp);
  #else
  int yylex (void);
  #endif

%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   { printf ("\n"); }
     ;

stmt : expr ';'  %merge <stmtMerge>
     | decl      %merge <stmtMerge>
     | error ';'
     | '@'  { YYACCEPT; }
     ;

expr : ID 		{ printf ("%s ", $$); }
     | TYPENAME '(' expr ')'
			{ printf ("%s <cast> ", $1); }
     | expr '+' expr	{ printf ("+ "); }
     | expr '=' expr	{ printf ("= "); }
     ;

decl : TYPENAME declarator ';'
			{ printf ("%s <declare> ", $1); }
     | TYPENAME declarator '=' expr ';'
			{ printf ("%s <init-declare> ", $1); }
     ;

declarator : ID		{ printf ("\"%s\" ", $1); }
     | '(' declarator ')'
     ;

%%

#include <assert.h>
#include <ctype.h>
#include <string.h>

int
main (int argc, char** argv)
{
  assert (argc == 2);
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

#if YYPURE
int
yylex (YYSTYPE *lvalp)
#else
int
yylex ()
#endif
{
  char buffer[256];
  int c;

#if YYPURE
# define yylval (*lvalp)

#endif

  while (1) {
    c = getchar ();
    switch (c) {
    case EOF:
      return 0;
    case ' ': case '\t': case '\n': case '\f':
      break;
    default:
      if (isalpha (c)) {
	ungetc (c, stdin);
	scanf ("%[A-Za-z0-9_]", buffer);
	yylval = strdup (buffer);
	return isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
      }
      return c;
    }
  }
}

int
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
  return 0;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  /* Use the arguments. */
  (void) x0;
  (void) x1;
  printf ("<OR> ");
  return "";
}

_ATEOF


cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
$at_verbose "cxx-type.at:267: bison -o types.c types.y"
echo cxx-type.at:267 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:267: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "cxx-type.at:267: \$CC \$CFLAGS \$CPPFLAGS types.c -o types"
echo cxx-type.at:267 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS types.c -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:267: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "cxx-type.at:270: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:270 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error
" | $at_diff - $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "z q +
\"x\" T <declare>
\"x\" y T <init-declare>
x y =
x T <cast> y +
\"x\" T <declare> x T <cast> <OR>
\"y\" z q + T <init-declare> y T <cast> z q + = <OR>
y
z q +
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:270: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  96 ) # 96. cxx-type.at:272: GLR: Merge conflicting parses, pure, locations
    at_setup_line='cxx-type.at:272'
    $at_verbose "96. cxx-type.at:272: testing GLR: Merge conflicting parses, pure, locations..."
    $at_quiet $ECHO_N " 96: cxx-type.at:272   $ECHO_C"
    (
      $at_traceon

cat >types.y <<'_ATEOF'
/* Simplified C++ Type and Expression Grammar.  */

%pure-parser
%locations

%{
  #include <stdio.h>
  #define YYSTYPE const char*
  #define YYLTYPE int
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  int yyerror (const char *s);

  #if YYPURE
  int yylex (YYSTYPE *lvalp, YYLTYPE *llocp);
  #else
  int yylex (void);
  #endif

%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   { printf ("\n"); }
     ;

stmt : expr ';'  %merge <stmtMerge>
     | decl      %merge <stmtMerge>
     | error ';'
     | '@'  { YYACCEPT; }
     ;

expr : ID 		{ printf ("%s ", $$); }
     | TYPENAME '(' expr ')'
			{ printf ("%s <cast> ", $1); }
     | expr '+' expr	{ printf ("+ "); }
     | expr '=' expr	{ printf ("= "); }
     ;

decl : TYPENAME declarator ';'
			{ printf ("%s <declare> ", $1); }
     | TYPENAME declarator '=' expr ';'
			{ printf ("%s <init-declare> ", $1); }
     ;

declarator : ID		{ printf ("\"%s\" ", $1); }
     | '(' declarator ')'
     ;

%%

#include <assert.h>
#include <ctype.h>
#include <string.h>

int
main (int argc, char** argv)
{
  assert (argc == 2);
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

#if YYPURE
int
yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
#else
int
yylex ()
#endif
{
  char buffer[256];
  int c;

#if YYPURE
# define yylval (*lvalp)
  (void) llocp;
#endif

  while (1) {
    c = getchar ();
    switch (c) {
    case EOF:
      return 0;
    case ' ': case '\t': case '\n': case '\f':
      break;
    default:
      if (isalpha (c)) {
	ungetc (c, stdin);
	scanf ("%[A-Za-z0-9_]", buffer);
	yylval = strdup (buffer);
	return isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
      }
      return c;
    }
  }
}

int
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
  return 0;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  /* Use the arguments. */
  (void) x0;
  (void) x1;
  printf ("<OR> ");
  return "";
}

_ATEOF


cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
$at_verbose "cxx-type.at:274: bison -o types.c types.y"
echo cxx-type.at:274 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:274: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "cxx-type.at:274: \$CC \$CFLAGS \$CPPFLAGS types.c -o types"
echo cxx-type.at:274 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS types.c -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:274: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "cxx-type.at:277: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:277 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error
" | $at_diff - $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "z q +
\"x\" T <declare>
\"x\" y T <init-declare>
x y =
x T <cast> y +
\"x\" T <declare> x T <cast> <OR>
\"y\" z q + T <init-declare> y T <cast> z q + = <OR>
y
z q +
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:277: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;

  97 ) # 97. cxx-type.at:280: GLR: Verbose messages, resolve ambiguity, impure, no locations
    at_setup_line='cxx-type.at:280'
    $at_verbose "97. cxx-type.at:280: testing GLR: Verbose messages, resolve ambiguity, impure, no locations..."
    $at_quiet $ECHO_N " 97: cxx-type.at:280   $ECHO_C"
    (
      $at_traceon

cat >types.y <<'_ATEOF'
/* Simplified C++ Type and Expression Grammar.  */

%error-verbose

%{
  #include <stdio.h>
  #define YYSTYPE const char*
  #define YYLTYPE int
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  int yyerror (const char *s);

  #if YYPURE
  int yylex (YYSTYPE *lvalp);
  #else
  int yylex (void);
  #endif

%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   { printf ("\n"); }
     ;

stmt : expr ';'  %merge <stmtMerge>
     | decl      %merge <stmtMerge>
     | error ';'
     | '@'  { YYACCEPT; }
     ;

expr : ID 		{ printf ("%s ", $$); }
     | TYPENAME '(' expr ')'
			{ printf ("%s <cast> ", $1); }
     | expr '+' expr	{ printf ("+ "); }
     | expr '=' expr	{ printf ("= "); }
     ;

decl : TYPENAME declarator ';'
			{ printf ("%s <declare> ", $1); }
     | TYPENAME declarator '=' expr ';'
			{ printf ("%s <init-declare> ", $1); }
     ;

declarator : ID		{ printf ("\"%s\" ", $1); }
     | '(' declarator ')'
     ;

%%

#include <assert.h>
#include <ctype.h>
#include <string.h>

int
main (int argc, char** argv)
{
  assert (argc == 2);
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

#if YYPURE
int
yylex (YYSTYPE *lvalp)
#else
int
yylex ()
#endif
{
  char buffer[256];
  int c;

#if YYPURE
# define yylval (*lvalp)

#endif

  while (1) {
    c = getchar ();
    switch (c) {
    case EOF:
      return 0;
    case ' ': case '\t': case '\n': case '\f':
      break;
    default:
      if (isalpha (c)) {
	ungetc (c, stdin);
	scanf ("%[A-Za-z0-9_]", buffer);
	yylval = strdup (buffer);
	return isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
      }
      return c;
    }
  }
}

int
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
  return 0;
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  /* Use the arguments. */
  (void) x0;
  (void) x1;
  printf ("<OR> ");
  return "";
}

_ATEOF


cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
$at_verbose "cxx-type.at:282: bison -o types.c types.y"
echo cxx-type.at:282 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:282: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

$at_traceoff
$at_verbose "cxx-type.at:282: \$CC \$CFLAGS \$CPPFLAGS types.c -o types"
echo cxx-type.at:282 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS types.c -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
(echo stderr:; cat $at_stderr) >&5
$at_diff $at_devnull $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:282: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon


$at_traceoff
$at_verbose "cxx-type.at:285: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:285 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "parse error, unexpected ID, expecting '=' or '+' or ')'
" | $at_diff - $at_stderr >&5 || at_failed=:
echo >>$at_stdout; echo "z q +
\"x\" T <declare>
\"x\" y T <init-declare>
x y =
x T <cast> y +
\"x\" T <declare> x T <cast> <OR>
\"y\" z q + T <init-declare> y T <cast> z q + = <OR>
y
z q +
" | $at_diff - $at_stdout >&5 || at_failed=:
case $at_status in
   77) exit 77;;
   0) ;;
   *) $at_verbose "cxx-type.at:285: exit code was $at_status, expected 0" >&2
      at_failed=:;;
esac

$at_failed && exit 1
$at_traceon

    $at_times_skip || times >$at_times_file
    )
    at_status=$?
    ;;


  * )
    echo "$as_me: no such test group: $at_group" >&2
    continue
    ;;
  esac

  # Be sure to come back to the suite directory, in particular
  # since below we might `rm' the group directory we are in currently.
  cd $at_suite_dir

  case $at_group in
    banner-*) ;;
    *)
      if test ! -f $at_check_line_file; then
        sed "s/^ */$as_me: warning: /" <<_ATEOF
        A failure happened in a test group before any test could be
        run. This means that test suite is improperly designed.  Please
        report this failure to <bug-bison@gnu.org>.
_ATEOF
    	echo "$at_setup_line" >$at_check_line_file
      fi
      at_group_count=`expr 1 + $at_group_count`
      $at_verbose $ECHO_N "$at_group. $at_setup_line: $ECHO_C"
      case $at_status in
        0)  at_msg="ok"
            at_pass_list="$at_pass_list $at_group"
            # Cleanup the group directory, unless the user wants the files.
            $at_debug_p || rm -rf $at_group_dir
            ;;
        77) at_msg="ok (skipped near \``cat $at_check_line_file`')"
            at_skip_list="$at_skip_list $at_group"
            # Cleanup the group directory, unless the user wants the files.
            $at_debug_p || rm -rf $at_group_dir
            ;;
        *)  at_msg="FAILED near \``cat $at_check_line_file`'"
            at_fail_list="$at_fail_list $at_group"
            # Up failure, keep the group directory for autopsy.
            # Create the debugging script.
            {
              echo "#! /bin/sh"
              echo 'test "${ZSH_VERSION+set}" = set && alias -g '\''${1+"$@"}'\''='\''"$@"'\'''
              echo "cd $at_dir"
              echo 'exec ${CONFIG_SHELL-'"$SHELL"'}' "$0" \
                   '-v -d' "$at_debug_args" "$at_group" '${1+"$@"}'
              echo 'exit 1'
            } >$at_group_dir/run
            chmod +x $at_group_dir/run
            ;;
      esac
      echo $at_msg
      at_log_msg="$at_group. $at_setup_line: $at_msg"
      # If the group failed, $at_times_file is not available.
      test -f $at_times_file &&
        at_log_msg="$at_log_msg	(`sed 1d $at_times_file`)"
      echo "$at_log_msg" >&6
      $at_errexit_p && test -n "$at_fail_list" && break
      ;;
  esac
done

# Back to the top directory, in particular because we might
# rerun the suite verbosely.
cd $at_dir

# Compute the duration of the suite.
at_stop_date=`date`
at_stop_time=`(date +%s) 2>/dev/null`
echo "$as_me: ending at: $at_stop_date" >&6
at_duration_s=`(expr $at_stop_time - $at_start_time) 2>/dev/null`
at_duration_m=`(expr $at_duration_s / 60) 2>/dev/null`
at_duration_h=`(expr $at_duration_m / 60) 2>/dev/null`
at_duration_s=`(expr $at_duration_s % 60) 2>/dev/null`
at_duration_m=`(expr $at_duration_m % 60) 2>/dev/null`
at_duration="${at_duration_h}h ${at_duration_m}m ${at_duration_s}s"
if test "$at_duration" != "h m s"; then
  echo "$as_me: test suite duration: $at_duration" >&6
fi

# Wrap up the test suite with summary statistics.
at_skip_count=`set dummy $at_skip_list; shift; echo $#`
at_fail_count=`set dummy $at_fail_list; shift; echo $#`
if test $at_fail_count = 0; then
  if test $at_skip_count = 0; then
    sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## All $at_group_count tests were successful. ##
_ASBOX
  else
    sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## All $at_group_count tests were successful ($at_skip_count skipped). ##
_ASBOX
  fi
elif test $at_debug_p = false; then
  if $at_errexit_p; then
    cat <<\_ASBOX
## ------------------------------------------------------------ ##
## ERROR: One of the tests failed, inhibiting subsequent tests. ##
## ------------------------------------------------------------ ##
_ASBOX
  else
    sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## ERROR: Suite unsuccessful, $at_fail_count of $at_group_count tests failed. ##
_ASBOX
  fi

  # Normalize the names so that `ls' lists them in order.
  echo 'You may investigate any problem if you feel able to do so, in which'
  echo 'case the test suite provides a good starting point.'
  echo
  echo 'Now, failed tests will be executed again, verbosely, and logged'
  echo 'in the file '$as_me'.log.'

  {
    echo
    echo
    cat <<\_ASBOX
## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##
_ASBOX

    # Summary of failed and skipped tests.
    if test $at_fail_count != 0; then
      echo "Failed tests:"
      $SHELL $0 $at_fail_list --list
      echo
    fi
    if test $at_skip_count != 0; then
      echo "Skipped tests:"
      $SHELL $0 $at_skip_list --list
      echo
    fi
    echo

    cat <<\_ASBOX
## --------------------------------------- ##
## Verbosely re-running the failing tests. ##
## --------------------------------------- ##
_ASBOX
    echo
  } >&6

  exec 6>/dev/null
  $SHELL $0 -v -d $at_debug_args $at_fail_list 2>&1 | tee -a $as_me.log
  exec 6>>$as_me.log

  {
    echo
    if test -n "$at_top_srcdir"; then
      cat <<\_ASBOX
## ------------------- ##
## Configuration logs. ##
## ------------------- ##
_ASBOX
      echo
      for at_file in `find "$at_top_srcdir" -name config.log -print`
      do
  	echo "$as_me: $at_file:"
  	sed 's/^/| /' $at_file
  	echo
      done
    fi
  } >&6


  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $as_me.log is created. ##
_ASBOX

  echo
  echo "Please send \`$as_me.log' and all information you think might help:"
  echo
  echo "   To: <bug-bison@gnu.org>"
  echo "   Subject: [GNU Bison 1.50a] $as_me.log: $at_fail_count failures"
  echo
  exit 1
fi

exit 0


