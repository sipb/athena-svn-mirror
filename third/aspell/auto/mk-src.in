#
# mk-src.in -- Input file for the Perl program to automatically 
#              generate interface code.
#
# This file is part of The New Aspell
# Copyright (C) 2001 by Kevin Atkinson under the GNU LGPL
# license version 2.0 or 2.1.  You should have received a copy of the
# LGPL license along with this library if you did not you can find it
# at http://www.gnu.org/.

=head1 mk-src.in

The format of mk-src.in is as follows:

  The following charaters are literals: { } / '\ ' \n = >

  <items>
  <items> := (<item>\n)+
  <items> := <category>:\ <name> {\n<details>\n} | <<tab>><details>
  <details> := <options>\n /\n <items>
  <options> := (<option>\n)*
  <option> := <key> [=> <value>]

  <<tab>> means everything should be indented by one tab

See MkSrc::Info for a description of the categorys and options

=cut


group: type id
{
/
union: type id
	treat as object
	/
	unsigned int: num
		default => 0
	array 4 char: str
	cxx constructor:
		/
		string: str
}
methods: destructible
	/
	destructor
	
#	int: ref count
#		default => 0
#
#	method: ref count
#		desc => returns a pointer to an int which may be used
#			for refrence counting.  It will default to 0.
#			This integer is not used by the actual library
#			but may be used my some of the front ends.
#		c only
#		c impl => return &ths->ref_count;
#		/
#		int pointer

methods: copyable
	/
	destructible methods

#	type id: type id
#
#	method: type id
#		desc => To objects of the same pointer type may be
#			assigned to each other only if there type ids 
#			are the same.
#		cxx impl => return type_id_.num
#		/
#		unsigned int
#
#	int: copyable
#		default => 2
#
#	method: copyable
#		desc => Returns 0 if this object can not be copied,
#			1 if it may be copies, 2 if it should be
#			copyied.  Used by some of the front end to
#			detrime if a deep or shallow copy should be 
#			made.
#		cxx impl => return copyable_
#		/
#		int

	method: clone
		const
		/
		$
	
	method: assign
		/
		void
		const $: other

methods: can have error
	/
	cxx member: err
		headers => copy ptr, error
		what => CopyPtr<Error> err_

	method: error number
		const
		c only
		c impl => return ths->err_ == 0 ? 0 : 1;
		/
		unsigned int

	method: error message
		const
		c only
		c impl => return ths->err_ ? ths->err_->mesg : "";
		/
		string

	method: error
		const
		c only
		c impl => return ths->err_;
		/
		const error

methods: mutable container
	c impl headers => posib err
	/
	public: mutable container
	method: add
		/
		bool
		string: to_add

	method: remove
		/
		bool
		string: to_rem

	method: clear
		/
		void

	method: to mutable container
		c only
		c impl => return ths;
		/
		mutable container

group: mutable container
{
/
class: mutable container
	/
	mutable container methods
}
methods: list
	
	strip => 1
	/
	method: empty
		const
		/
		bool

	method: size
		const
		/
		unsigned int

	method: elements
		const
		/
		$ enumeration

methods: enumeration

	strip => 1
	
	/
	method: at end
		const
		/
		bool

	method: next
		/
		const $

group: key info
{
/
enum: key info type
	prefix => key info
	/
	string
	int
	bool
	list

struct: key info
	desc => The Key Info object is used for holding information
		about a valid key
	/
	string: name
		desc => the name of the key
	key info type: type
		desc => the key type
	string: def
		desc => the default value of the key
	string: desc
		desc => a brief description of the key or null if internal value
	array 16 char: otherdata
		desc => other data used by config implementations
			should be set to 0 if not used

}
group: config
{
no native
/
class: key info enumeration
	/
	enumeration methods
	copyable methods

class: config
	c impl headers => error
	/
	constructor

	copyable methods

	can have error methods

	method: set extra
		desc => sets extra keys which this config class should accept
			begin and end are expected to point to the begging 
			and end of an array of Aspell Key Info
		/
		void
		const key info: begin
		const key info: end

	method: keyinfo
		posib err
		desc => returns the KeyInfo object for the
			corresponding key or returns null and sets
			error_num to PERROR_UNKNOWN_KEY if the key is
			not valid. The pointer returned is valid for
			the lifetime of the object.
		/
		const key info
		string: key

	method: possible elements
		desc => returns a newly allocated enumeration of all the 
			possible objects this config class uses
		/
		key info enumeration
		int: include extra

	method: get default
		posib err
		desc => returns the default value for given key which
			way involve substating variables, thus it is
			not the same as keyinfo(key)->def returns null
			and sets error_num to PERROR_UNKNOWN_KEY if
			the key is not valid. Uses the temporary
			string.
		/
		string obj
		string: key

	method: elements
		desc => returns a newly alloacted enumeration of all the
			key/value pairs. This DOES not include ones
			which are set to their default values
		/
		string pair enumeration

	method: replace
		posib err
		desc => inserts an item, if the item already exists it
			will be replaced. returns true if it succesed
			or false on error. If the key in not valid it
			sets error_num to PERROR_UNKNOWN_KEY, if the
			value is not valid it will sets error_num to
			PERROR_BAD_VALUE, if the value can not be
			changed it sets error_num to
			PERROR_CANT_CHANGE_VALUE, and if the value is
			a list and you are trying to set it directory
			it sets error_num to PERROR_LIST_SET
		/
		void
		string: key
		string: value

	method: remove
		posib err
		desc => remove a key and returns true if it exists 
			otherise return false. This effictly sets the
			key to its default value. Calling replace with
			a value of "<default>" will also call
			remove. If the key does not exists sets
			error_num to 0 or PERROR_NOT, if the key in
			not valid sets error_num to
			PERROR_UNKNOWN_KEY, if the value can not be
			changed sets error_num to
			PERROR_CANT_CHANGE_VALUE
		/
		void
		string: key

	method: have
		const
		/
		bool
		string: key

	method: retrieve
		posib err
		desc => returns null on error
		/
		string obj
		string: key

	method: retrieve list
		posib err
		/
		void
		string: key
		mutable container: lst

	method: retrieve bool
		posib err
		desc => return -1 on error, 0 if false, 1 if true
		/
		bool
		string: key

	method: retrieve int
		posib err
		desc => return -1 on error
		/
		unsigned int
		string: key
}
group: error
{
/
struct: error
	/
	string: mesg
	const error info: err
	method: is a
		const
		/
		bool
		const error info: e

struct: error info
	/
	const error info: isa
	string: mesg
	unsigned int: num parms
	array 3 string: parms
}
group: can have error
{
/
class: can have error
	c impl headers => error
	/
	cxx constructor:
		cxx impl => : err_(e) {}
		/
		error: e
	can have error methods
		prefix => 
	destructible methods
}
group: errors
{
/
errors:
	/
	other
	operation not supported
		/
		cant copy
	file
		mesg => %file:
		parms => file
		/
		cant open file
			mesg => The file "%file" can not be opened
			/
			cant read file
				mesg => The file "%file" can not be opened for reading.
			cant write file
				mesg => The file "%file" can not be opened for writing.
		invalid name
			mesg => The file name "%file" is invalid.
		bad file format
			mesg => The file "%file" is not in the proper format.
	dir
		parms => dir
		/
		cant read dir
			mesg => The directory "%dir" can not be opened for reading.
			
	config
		parms => key
		/
		unknown key
			mesg => The key "%key" is unknown.
		cant change value
			mesg => The value for option "%key" can not be changed.
		bad key
			mesg => The key "%key" is not %accepted and is thus invalid.
			parms => accepted
		bad value
			mesg => The value "%value" is not %accepted and is thus invalid for the key "%key".
			parms => value, accepted
		duplicate

	language related
		parms => lang
		/
		unknown language
			mesg => The language "%lang" is not known.
		unknown soundslike
			mesg => The soundslike "%sl" is not known.
			parms => sl
		language not supported
			mesg => The language "%lang" is not supported.
		no wordlist for lang
			mesg => No word lists can be found for the language "%lang".
		mismatched language
			mesg => Expected language "%lang" but got "%prev".
			parms => prev
	encoding
		parms => encod
		/
		unknown encoding
			mesg => The encoding "%encod" is not known.
		encoding not supported
			mesg => The encoding "%encod" is not supported.
		conversion not supported
			mesg => The conversion from "%encod" to "%encod2" is not supported.
			parms => encod2
	pipe
		/
		cant create pipe
		process died
	bad input
		/
		invalid word
			mesg => The word "%word" is invalid.
			parms => word
		word list flags
			/
			invalid flag
			conflicting flags

}
group: speller
{
no native
/
class: speller
	c impl headers => error
	/
	# FIME make a "methods" of the next two contractors
	#      which will probaly involve modifying mk-src.pl

	constructor: new aspell speller
		returns alt type
		c impl =>
			PosibErr<Speller *> ret = new_speller(config);
			if (ret.has_err()) \{
			  return new CanHaveError(ret.release_err());
			\} else \{
			  return ret;
			\}
		/
		can have error
		config: config

	constructor: to aspell speller
		c impl => return static_cast<Speller *>(obj);
		/
		can have error: obj

	destructible methods

	can have error methods

	method: config
		/
		config

	method: check

		posib err
		desc => returns  0 if it is not in the dictionary, 
			1 if it is, or -1 on error.
		/
		bool
		encoded string: word
	
	method: add to personal
		
		posib err
		/
		void
		encoded string: word

	method: add to session

		posib err
		/
		void
		encoded string: word

	method: personal word list

		posib err
		/
		const word list
		
	method: session word list

		posib err
		/
		const word list

	method: main word list

		posib err
		/
		const word list

	method: save all word lists
	
		posib err
		/
		void

	method: clear session

		posib err
		/
		void

	method: suggest

		posib err
		desc => Return null on error. 
			the word list returned by suggest is only valid until the next
			call to suggest
		/
		const word list
		encoded string: word
		
	method: store replacement

		posib err
		/
		bool
		encoded string: mis
		encoded string: cor

}

group: filter
{
no native
/
class: filter
	c impl headers => error
	/
	destructible methods
	
	can have error methods

	# FIME make a "methods" of the next two contractors

#	constructor: new aspell filter
#		returns alt type
#		c impl =>
#			PosibErr<Filter *> ret = new_filter(config);
#			if (ret.has_err()) \{
#			  return new CanHaveError(ret.release_err());
#			\} else \{
#			  return ret;
#			\}
#		/
#		can have error
#		config: config

	constructor: to aspell filter
		c impl => return static_cast<Filter *>(obj);
		/
		can have error: obj

#	method: setup
#
#		posib err
#		/
#		void
#		speller: speller
#		config: config
#
#	method: reset
#
#		/
#		void
#
#	method: process
#	
#		/
#		void
#		char pointer: str
#		int: size
#
#	method: config
#
#		/
#		config
}

group: document checker
{
no native
/
struct: token
	/
	unsigned int: offset
	unsigned int: len

class: document checker
	c impl headers => error
	/
	destructible methods
	
	can have error methods

	# FIME make a "methods" of the next two contractors

	constructor: new aspell document checker
		returns alt type
		c impl =>
			PosibErr<DocumentChecker *> ret = new_document_checker(speller);
			if (ret.has_err()) \{
			  return new CanHaveError(ret.release_err());
			\} else \{
			  return ret;
			\}
		desc => Creates a new document checker.
			The speller class is expect to last until this
			class is destroyed.
			If config is given it will be used to overwide
			any relevent options set by this speller class.
			The config class is not once this function is done.
			If filter is given then it will take ownership of 
			the filter class and use it to do the filtering.
			You are expected to free the checker when done.
		/
		can have error
		speller: speller

	constructor: to aspell document checker
		c impl => return static_cast<DocumentChecker *>(obj);
		/
		can have error: obj

	method: reset

		desc => reset the internal state of the filter.
			should be called whenever a new document is being filtered
		/
		void

	method: process
	
		desc => process a string
			The string passed in should only be split on white space
			characters.  Furthermore, between calles to reset, each string
			should be passed in exactly once and in the order they appeared
			in the document.  Passing in stings out of order, skipping
			strings or passing them in more than once may lead to undefined
			results.
		/
		void
		string: str
		int: size

	method: next misspelling
	
		desc => returns the next misspelled word in the processed string
			if there are no more misspelled word than token.word
			will be null and token.size will be 0
		/
		token object

	method: filter

		desc => returns the underlying filter class
		/
		filter
}

group: word list
{
/
class: word list
	c impl headers => string enumeration
	/
	cxx member: from internal
		what => class Convert * from_internal_
		default => 0

	method: empty
		const
		/
		bool

	method: size
		const
		/
		unsigned int

	method: elements
		const
		c impl =>
			StringEnumeration * els = ths->elements();
			els->from_internal_ = ths->from_internal_;
			return els;
		/
		string enumeration
}
group: string enumeration
{
/
class: string enumeration
	c impl headers => convert
	/
	copyable methods
	method: at end
		const
		/
		bool

	method: next
		c impl =>
			const char * s = ths->next();
			if (s == 0 || ths->from_internal_ == 0) \{
			  return s;
			\} else \{
			  ths->temp_str.clear();
			  ths->from_internal_->convert(s,-1,ths->temp_str);
			  ths->from_internal_->append_null(ths->temp_str);
			  return ths->temp_str.data();
			\}
		/
		const string

}
group: info
{
/
struct: module info
	/
	string: name
	double: order num
	string: lib dir
	string list: dict dirs
	string list: dict exts

struct: dict info
	/
	string: name
		desc => name to identify the dictionary by
	string: code
	string: jargon
	int: size
	string: size str
	module info: module

class: module info list
	/
	constructor: get aspell module info list
		/
		config: config

	list methods

class: dict info list
	/
	constructor: get aspell dict info list
		/
		config: config

	list methods

class: module info enumeration
	/
	enumeration methods
	copyable methods

class: dict info enumeration
	/
	enumeration methods
	copyable methods
}

group: string list
{
/
class: string list
	/
	constructor

	list methods

	mutable container methods

	copyable methods
}

group: string map
{
/
class: string map
	/
	constructor

	mutable container methods

	copyable methods

	list methods: string pair
	
	method: insert
		desc => Insert a new element. 
			Will NOT overright an existing entry.
			Returns false if the element already exists.
		/
		bool
		string: key
		string: value

	method: replace
		desc => Insert a new element. 
			Will overright an existing entry.
			Always returns true.
		/
		bool
		string: key
		string: value

	method: lookup
		const
		desc => Looks up an element.
			Returns null if the element did not exist.
			Returns an empty string if the element exists but has a null value.
			Otherwises returns the value
		/
		string
		string: key
}

group: string pair
{
/
struct: string pair
	treat as object
	/
	string: first
		default => ""
	string: second
		default => ""
}
group: string pair enumeration
{
/
class: string pair enumeration
	/
	enumeration methods
	copyable methods
}
