/*
 * vlserver.h:
 * This file is automatically generated; please do not edit it.
 */
/* Including vlserver.p.h at beginning of vlserver.h file. */

/*
 * P_R_P_Q_# (C) COPYRIGHT IBM CORPORATION 1987, 1988
 * LICENSED MATERIALS - PROPERTY OF IBM
 * REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER G120-2083
 */

#ifndef	_VLSERVER_
#define	_VLSERVER_

#include "vldbint.h"

extern struct vldstats dynamic_statistics;



#define	HASHSIZE		8191	/* Must be prime */
#define	NULLO			0
#define	VLDBALLOCCOUNT		40

/* Current upper limits limits on certain entries; increase with care! */
#define	BADSERVERID	255
#define	MAXSERVERID	254  /* permits 255 servers; was == 30 in version 1 */
#define	MAXSERVERFLAG	0x80
#define	MAXPARTITIONID	255
#define	MAXBUMPCOUNT	0x7fffffff  /* Infinite  upper bound on bumping for now */
#define	MAXLOCKTIME	0x7fffffff  /* Infinite locking for now */

/* Order of entries in the volumeid[] array */
#define	RWVOL		0
#define	ROVOL		1
#define	BACKVOL		2

/* Header struct holding stats, internal pointers and the hash tables */
struct vlheader {
    struct  vital_vlheader  vital_header;   /* all small critical stuff are in here */
    u_int32  IpMappedAddr[MAXSERVERID+1];    /* Mapping of ip addresses to relative ones */
    int32    VolnameHash[HASHSIZE];	    /* hash table for vol names */
    int32    VolidHash[MAXTYPES][HASHSIZE];  /* hash table for vol ids */
    int32    SIT;                            /* spare for poss future use */
};

/* Vlentry's flags state */
#define	VLFREE		1		/* If in free list */
#define	VLDELETED	2		/* Entry is soft deleted */
#define	VLLOCKED	4		/* Advisory lock on entry */
#define	VLCONTBLOCK	8		/* Special continuation block entry */

/* Vlentry's flags also used to stamp type of ongoing operation */
#define	VLOP_MOVE	0x10
#define	VLOP_RELEASE	0x20
#define	VLOP_BACKUP	0x40
#define	VLOP_DELETE	0x80
#define	VLOP_DUMP	0x100
#define	VLOP_ALLOPERS	(VLOP_MOVE | VLOP_RELEASE | VLOP_BACKUP | VLOP_DELETE | VLOP_DUMP)

/* Valid RelaseLock types */
#define	LOCKREL_TIMESTAMP   1
#define	LOCKREL_OPCODE	    2
#define	LOCKREL_AFSID	    4

/* Per repsite flags (serverFlags) */
#define	VLREPSITE_NEW   1		/* Replication site is got new release */

/* Internal representation of vldbentry; trying to save any bytes */
struct vlentry {
    u_int32  volumeId[MAXTYPES];		/* Corresponding volume of each type */
    int32    flags;			/* General flags */
    int32    LockAfsId;			/* Person who locked entry */
    int32    LockTimestamp;		/* lock time stamp */
    int32    cloneId;			/* used during cloning */
    int32    spares0;			/* XXXX was AssociatedChain XXXX */
    int32    nextIdHash[MAXTYPES];	/* Next id hash table pointer (or freelist ->[0]) */
    int32    nextNameHash;		/* Next name hash table pointer */
    int32    spares1[2];			/* long spares */
    char    name[VL_MAXNAMELEN];	/* Volume name */
    char    spares3;			/* XXX was volumeType XXXX */
    u_char  serverNumber[OMAXNSERVERS];	/* Server # for each server that holds volume */
    u_char  serverPartition[OMAXNSERVERS];/* Server Partition number */
    u_char  serverFlags[OMAXNSERVERS];	/* Server flags */
    char    spares4;			/* XXX was RefCount XXX */
    char    spares2[1];			/* for 32-bit alignment */
};

struct nvlentry {
    u_int32  volumeId[MAXTYPES];		/* Corresponding volume of each type */
    int32    flags;			/* General flags */
    int32    LockAfsId;			/* Person who locked entry */
    int32    LockTimestamp;		/* lock time stamp */
    int32    cloneId;			/* used during cloning */
    int32    nextIdHash[MAXTYPES];	/* Next id hash table pointer (or freelist ->[0]) */
    int32    nextNameHash;		/* Next name hash table pointer */
    char    name[VL_MAXNAMELEN];	/* Volume name */
    u_char  serverNumber[NMAXNSERVERS];	/* Server # for each server that holds volume */
    u_char  serverPartition[NMAXNSERVERS];/* Server Partition number */
    u_char  serverFlags[NMAXNSERVERS];	/* Server flags */
};

typedef struct vlheader vlheader;
typedef struct vlentry vlentry;
typedef struct nvlentry nvlentry;

#define COUNT_REQ(op) static int this_op = op-VL_LOWEST_OPCODE; dynamic_statistics.requests[this_op]++
#define COUNT_ABO dynamic_statistics.aborts[this_op]++
#define	DOFFSET(abase,astr,aitem) ((abase)+(((char *)(aitem)) - ((char *)(astr))))

#define	VL_MHSRV_PERBLK		64
#define	VL_MAXIPADDRS_PERMH	15
#define VL_MAX_ADDREXTBLKS	4
#define	VL_ADDREXTBLK_SIZE	8192
struct extentaddr {
    union ex_un {
	struct {
	    int32  count;		/* # of valid addresses */
	    int32  spares1[2];
	    int32  flags;		/* must match vlentry's flags field XXX */
	    u_int32 contaddrs[VL_MAX_ADDREXTBLKS];
	    int32  spares2[24];
	} _ex_header;
	struct {
	    afsUUID hostuuid;
	    int32 uniquifier;
	    u_int32 addrs[VL_MAXIPADDRS_PERMH];
	} _ex_addrentry;
    } _ex_un;
};
#define	ex_count	_ex_un._ex_header.count
#define	ex_flags	_ex_un._ex_header.flags
#define	ex_contaddrs	_ex_un._ex_header.contaddrs
#define	ex_hostuuid	_ex_un._ex_addrentry.hostuuid
#define	ex_addrs	_ex_un._ex_addrentry.addrs
#define	ex_uniquifier	_ex_un._ex_addrentry.uniquifier

extern int LogLevel;
#define VLog(level, str)  if ((level) <= LogLevel) (VLLog str)

#endif /* _VLSERVER_ */

/* End of prolog file vlserver.p.h. */

#define VL_IDEXIST                               (363520L)
#define VL_IO                                    (363521L)
#define VL_NAMEEXIST                             (363522L)
#define VL_CREATEFAIL                            (363523L)
#define VL_NOENT                                 (363524L)
#define VL_EMPTY                                 (363525L)
#define VL_ENTDELETED                            (363526L)
#define VL_BADNAME                               (363527L)
#define VL_BADINDEX                              (363528L)
#define VL_BADVOLTYPE                            (363529L)
#define VL_BADSERVER                             (363530L)
#define VL_BADPARTITION                          (363531L)
#define VL_REPSFULL                              (363532L)
#define VL_NOREPSERVER                           (363533L)
#define VL_DUPREPSERVER                          (363534L)
#define VL_RWNOTFOUND                            (363535L)
#define VL_BADREFCOUNT                           (363536L)
#define VL_SIZEEXCEEDED                          (363537L)
#define VL_BADENTRY                              (363538L)
#define VL_BADVOLIDBUMP                          (363539L)
#define VL_IDALREADYHASHED                       (363540L)
#define VL_ENTRYLOCKED                           (363541L)
#define VL_BADVOLOPER                            (363542L)
#define VL_BADRELLOCKTYPE                        (363543L)
#define VL_RERELEASE                             (363544L)
#define VL_BADSERVERFLAG                         (363545L)
#define VL_PERM                                  (363546L)
#define VL_NOMEM                                 (363547L)
#define VL_BADVERSION                            (363548L)
#define VL_INDEXERANGE                           (363549L)
#define VL_MULTIPADDR                            (363550L)
#define VL_BADMASK                               (363551L)
extern void initialize_vl_error_table ();
#define ERROR_TABLE_BASE_vl (363520L)

/* for compatibility with older versions... */
#define init_vl_err_tbl initialize_vl_error_table
#define vl_err_base ERROR_TABLE_BASE_vl
